<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>dcokerdesktop小问题排查</title>
    <url>/hexoblog/2021/03/14/md/docker/dcokerdesktop%E5%B0%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<!-- toc -->

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="启动问题"><a href="#启动问题" class="headerlink" title="启动问题"></a>启动问题</h2><h3 id="docker启动失败"><a href="#docker启动失败" class="headerlink" title="docker启动失败"></a>docker启动失败</h3><span id="more"></span>

<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/Error%202021_3_14%2017_02_08.png" alt="启动失败"></p>
<p>&emsp;&emsp;dockerdesktop在启动时，发生此错误，因为wsl未启动或者wsl启动出现问题。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>&emsp;&emsp;解决掉对应的wsl错误即可。这里的问题是：</p>
<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/Ubuntu%2020.04%20LTS%202021_3_14%2016_01_57.png" alt="参考的对象不支持的操作"></p>
<p>&emsp;&emsp;是因为wsl的问题，将其解决即可。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>docker启动springboot</title>
    <url>/hexoblog/2021/04/12/md/docker/docker%E5%90%AF%E5%8A%A8springboot/</url>
    <content><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>&emsp;&emsp;需要准备东西有：</p>
<ol>
<li>docker环境</li>
<li>sprinboot项目</li>
</ol>
<span id="more"></span>

<hr>
<h1 id="手动"><a href="#手动" class="headerlink" title="手动"></a>手动</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>&emsp;&emsp;首先将springboot项目通过maven打包，得到可执行jar包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除编译文件</span></span><br><span class="line">mvn clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将项目打包，得到可执行jar包</span></span><br><span class="line">mvn package</span><br></pre></td></tr></table></figure>

<h3 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h3><p>&emsp;&emsp;将得到的可执行jar包构建成docker镜像。</p>
<p>&emsp;&emsp;将得到的jar包放入指定目录下，并且在同目录下建立Dockerfile文件(文件名不能错)。<br>&emsp;&emsp;Dockerfile文件内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像，环境</span></span><br><span class="line">FROM java:8</span><br><span class="line"><span class="comment"># springboot内嵌tomcat的工作目录</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"><span class="comment"># 拷贝文件并重命名</span></span><br><span class="line">ADD &lt;包名称&gt;.jar &lt;镜像名称&gt;.jar</span><br><span class="line"><span class="comment"># 启动时的命令</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;&lt;包名称&gt;.jar&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行docker构建命令，得到docker镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t &lt;镜像名称&gt; .</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>&emsp;&emsp;构建完成后，就可以在镜像列表查看是否有新构建的镜像，也可以运行该镜像。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="jar包名称问题"><a href="#jar包名称问题" class="headerlink" title="jar包名称问题"></a>jar包名称问题</h3><p>&emsp;&emsp;docker中镜像名称应该是使用小写字母，不可以使用大写字母，否则报错，命令行中不允许大写字母及特殊字符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">invalid argument <span class="string">&quot;learn-0.0.1-SNAPSHOT&quot;</span> <span class="keyword">for</span> <span class="string">&quot;-t, --tag&quot;</span> flag: invalid reference format: repository name must be lowercase</span><br><span class="line">See <span class="string">&#x27;docker build --help&#x27;</span>.</span><br></pre></td></tr></table></figure>

<h3 id="执行路径问题"><a href="#执行路径问题" class="headerlink" title="执行路径问题"></a>执行路径问题</h3><p>&emsp;&emsp;执行构建镜像命令应该进入所创建的目录，即在Dockerfile文件所在目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">failed to solve with frontend dockerfile.v0: failed to <span class="built_in">read</span> dockerfile: open /var/lib/docker/tmp/buildkit-mount528762</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="自动"><a href="#自动" class="headerlink" title="自动"></a>自动</h1><p>&emsp;&emsp;借助docker提供的maven工具，可自动构建docker镜像。</p>
<h2 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>&emsp;&emsp;首先需要引入docker的maven构建工具。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 低版本的会报错--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 1.0.0不支持docker-desktop--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">imageName</span>&gt;</span>springboot/learn<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Dockerfile文件所在的文件位置，可以用配置替代 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;dockerDirectory&gt;src/main/docker&lt;/dockerDirectory&gt; --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 基础镜像，运行一个springboot应用只需要基础的java环境就行 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">baseImage</span>&gt;</span>java:8<span class="tag">&lt;/<span class="name">baseImage</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- docker启动的时候执行的命令 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">entryPoint</span>&gt;</span>[&quot;java&quot;, &quot;-jar&quot;, &quot;/$&#123;project.build.finalName&#125;.jar&quot;]<span class="tag">&lt;/<span class="name">entryPoint</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h3><p>&emsp;&emsp;添加完依赖就可以对项目打包，构建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先将项目打包</span></span><br><span class="line">mvn package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用添加的maven插件将项目构建成docker镜像</span></span><br><span class="line">mvn docker:build</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;构建完成就可以在docker镜像列表中查看。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>springboot</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>docker启动vue</title>
    <url>/hexoblog/2021/04/12/md/docker/docker%E5%90%AF%E5%8A%A8vue/</url>
    <content><![CDATA[<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>&emsp;&emsp;需要准备东西有：</p>
<ol>
<li>docker环境</li>
<li>vue项目</li>
</ol>
<span id="more"></span>

<hr>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="项目build"><a href="#项目build" class="headerlink" title="项目build"></a>项目build</h2><p>&emsp;&emsp;将vue项目build得到dist文件夹。这里是页面等资源文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>&emsp;&emsp;将得到的可执行dist构建成docker镜像。</p>
<p>&emsp;&emsp;将得到的dist文件放入指定目录下，并且在同目录下建立Dockerfile文件(文件名不能错)。<br>&emsp;&emsp;Dockerfile文件内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置基础镜像，这里使用最新的nginx镜像，前面已经拉取过了</span></span><br><span class="line">FROM nginx</span><br><span class="line"><span class="comment"># 定义作者 Edison</span></span><br><span class="line">MAINTAINER Edison </span><br><span class="line"><span class="comment"># 将dist文件中的内容复制到 /usr/share/nginx/html/ 这个目录下面</span></span><br><span class="line">COPY dist/  /usr/share/nginx/html/</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行docker构建命令，得到docker镜像。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t &lt;镜像名称&gt; .</span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>&emsp;&emsp;构建完成后，就可以在镜像列表查看是否有新构建的镜像，也可以运行该镜像。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>tool</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装与使用</title>
    <url>/hexoblog/2021/03/05/md/docker/docker%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="docker介绍："><a href="#docker介绍：" class="headerlink" title="docker介绍："></a>docker介绍：</h1><p>&emsp;&emsp;docker是个鲸鱼，拉了很多集装箱的鲸鱼。<br>&emsp;&emsp;docker是个开源的容器引擎。可以让开发者快速将他们的应用及依赖打包到一个可移植的容器中，然后发布到不同的平台。</p>
<h2 id="docker的优点："><a href="#docker的优点：" class="headerlink" title="docker的优点："></a>docker的优点：</h2><p><strong>省时，省事，省钱。</strong></p>
<span id="more"></span>

<hr>
<h1 id="docker安装："><a href="#docker安装：" class="headerlink" title="docker安装："></a>docker安装：</h1><p>&emsp;&emsp;这里介绍docker在windows平台家庭版下的安装。</p>
<p>&emsp;&emsp;在windows家庭版下，安装docker需要先开启计算机的虚拟化功能，并且需要先安装wsl。</p>
<h2 id="开启计算机的虚拟化功能："><a href="#开启计算机的虚拟化功能：" class="headerlink" title="开启计算机的虚拟化功能："></a>开启计算机的虚拟化功能：</h2><p>&emsp;&emsp;在控制面板-&gt;程序-&gt;启用或关闭Windows功能中开启即可：</p>
<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/Windows%20%E5%8A%9F%E8%83%BD%202021_3_5%2015_47_19.png" alt="windows功能"></p>
<p>&emsp;&emsp;我么这里将虚拟机平台（hyper-v）和适用于linux的windows子系统同时勾选，下面的勾选为了下一步的安装wsl的ubuntu。<br>&emsp;&emsp;点击确定，等待执行完，重启电脑就可以了。</p>
<h2 id="安装Ubuntu"><a href="#安装Ubuntu" class="headerlink" title="安装Ubuntu"></a>安装Ubuntu</h2><p>&emsp;&emsp;我们在microsoft store中直接搜索linux，就会出现很多linux发行版，这里我选择的时ubuntu，也可以选择其他自己喜欢的发行版。</p>
<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/Microsoft%20Store%202021_3_5%2015_54_47.png" alt="microsoft store"></p>
<h2 id="安装docker-desktop"><a href="#安装docker-desktop" class="headerlink" title="安装docker-desktop"></a>安装docker-desktop</h2><p>&emsp;&emsp;这里去官网下载<a href="https://www.docker.com/products/docker-desktop">docker-desktop</a>。<br>&emsp;&emsp;下载后双击打开下载的exe文件，完成安装。整个安装过程还是很简单的，不过这里的只是社区版，仅提供4个月的支持，不推荐生产使用。<br>&emsp;&emsp;点击右上角的齿轮图标可以设置界面，可以设置不自动启动，也可以在配置安装的wsl连接docker。</p>
<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/Settings%202021_3_5%2016_18_18.png" alt="设置不自动启动" title="不自动启动"></p>
<p>开启refresh后，wsl中可以连接docker。</p>
<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/Settings%202021_3_5%2016_18_08.png" alt="wsl连接docker" title="wsl连接docker"></p>
<p>&emsp;&emsp;安装完成后可以用命令进行验证，查看版本号等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker -v</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;出现下面的结果即为安装成功：</p>
<img src="https://gitee.com/linqiankun/picurl/raw/master/java/Windows%20PowerShell%202021_3_5%2016_25_22.png" alt="Windows PowerShell 2021_3_5 16_25_22"  />

<p>&emsp;&emsp;当然这样安装的docker是运行在一个轻量级的linux虚拟机上的，（图中的**OS/Arch选项）当然docker也提供了在windows的，但是那必须在win10 专业版，教育版，企业版上才行。<br>&emsp;&emsp;接下来就可以愉快的玩耍了。</p>
<h1 id="基础使用："><a href="#基础使用：" class="headerlink" title="基础使用："></a>基础使用：</h1><h2 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h2><p>&emsp;&emsp;这样安装的docker安装成功后就启动起来了，就可以直接使用了。<br>&emsp;&emsp;这样的貌似不能用syatemctl进行启动。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看镜像列表</span></span><br><span class="line">docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在仓库中查找镜像</span></span><br><span class="line">docker search &lt;imagetitle&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载镜像</span></span><br><span class="line">docker pull &lt;imagetitle&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除镜像(需要无运行该镜像的容器)</span></span><br><span class="line">docker rmi &lt;imageId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看镜像</span></span><br><span class="line">docker inspect &lt;imageId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行镜像</span></span><br><span class="line">docker run -p &lt;port&gt;:&lt;port&gt; &lt;imagetitle&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看容器列表（运行中的镜像）</span></span><br><span class="line">docker container ls</span><br><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm &lt;containerId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以直接运行容器</span></span><br><span class="line">docker start &lt;containerId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">docker restart &lt;contarinerId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">docker stop &lt;containerId&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it &lt;containerId&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>wsl</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>dubboSPI扩展机制基本使用，自动包装</title>
    <url>/hexoblog/2021/04/15/md/dubbo/dubboSPI%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%8C%85%E8%A3%85/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;DubboSPI是基于JavaSPI的一个扩展与补充。<br><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/spi/">https://dubbo.apache.org/zh/docs/v2.7/dev/spi/</a></p>
<h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><ol>
<li>Java SPI 每次都会把所有实现类都加载并实例化(是在迭代器迭代的时候创建实例)，而 Dubbo SPI 是分两段创建实例，先进行类加载，然后在使用到具体实现的时候才实例化，并且 Dubbo SPI 大量使用缓存，会把 Class 对象和实例对象都缓存起来，性能更好。</li>
<li>Java SPI 在类加载失败的时候难以定位异常；</li>
<li>Dubbo SPI 还支持 IOC 和 AOP 。</li>
</ol>
<span id="more"></span>

<h2 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h2><ol>
<li>基本使用</li>
<li>扩展点自动包装</li>
<li>扩展点自适应</li>
<li>扩展点自动适配</li>
<li>扩展点自动激活</li>
</ol>
<hr>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>&emsp;&emsp;dubboSPI的基本使用和javaSPI并无太大差异。</p>
<p>主要区别：</p>
<blockquote>
<p>JDK标准的SPI会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。dubboSPI可以选择性实例某个实现。</p>
</blockquote>
<ol>
<li><p>dubboSPI需要SPI注解。</p>
</li>
<li><p>文件夹命名格式不同，文件内容格式不同。</p>
<blockquote>
<p>dubbo为META-INF/dubbo，文件内容为key=value(实现类全限定名)。<br>java为META-INF/services，文件内容直接为实现类全限定名。</p>
</blockquote>
</li>
<li><p>启动的API不同。</p>
<blockquote>
<p>dubbo为ExtensionLoader。<br>java为ServiceLoader，是java。</p>
</blockquote>
</li>
<li><p>java会扫描所有的类，无法按需加载，dubbo可以。</p>
</li>
</ol>
<h2 id="定义一个接口"><a href="#定义一个接口" class="headerlink" title="定义一个接口"></a>定义一个接口</h2><p>&emsp;&emsp;需要使用SPI注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dubbo需要SPI注解，SPI注解的值为默认的实现</span></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExtendService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定义实现类"><a href="#定义实现类" class="headerlink" title="定义实现类"></a>定义实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendServiceImpl</span> <span class="keyword">implements</span> <span class="title">ExtendService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><p>&emsp;&emsp;在classpath下创建指定文件夹及文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件夹</span></span><br><span class="line"><span class="comment"># 与javaSPI文件夹不同</span></span><br><span class="line">MATA-INF/dubbo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名（接口的全路径名）</span></span><br><span class="line">com.lin.extendwrapper.extend.ExtendService</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件内容</span></span><br><span class="line"><span class="comment"># key=value形式，与javaSPI不同格式</span></span><br><span class="line"><span class="comment"># 可以有多个实现</span></span><br><span class="line"><span class="comment"># java内容为实现类全限定名</span></span><br><span class="line">ExtendService=com.lin.extendwrapper.extend.impl.ExtendServiceImpl</span><br></pre></td></tr></table></figure>

<h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 与javaSPI的API不同</span></span><br><span class="line">        ExtensionLoader&lt;ExtendService&gt; extensionLoader = ExtensionLoader.getExtensionLoader(ExtendService.class);</span><br><span class="line">        ExtendService extendService = extensionLoader.getExtension(<span class="string">&quot;ExtendService&quot;</span>);</span><br><span class="line">        extendService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="扩展点自动包装"><a href="#扩展点自动包装" class="headerlink" title="扩展点自动包装"></a>扩展点自动包装</h1><p>&emsp;&emsp;ExtensionLoader在加载扩展点时，如果加载到的扩展点有拷贝构造函数，则判定为扩展点Wrapper类。<br>&emsp;&emsp;这个类似于AOP。</p>
<h2 id="增加一个实现类-包装类"><a href="#增加一个实现类-包装类" class="headerlink" title="增加一个实现类(包装类)"></a>增加一个实现类(包装类)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendServiceImplWrapper</span> <span class="keyword">implements</span> <span class="title">ExtendService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ExtendService extendService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtendServiceImplWrapper</span><span class="params">(ExtendService extendService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.extendService = extendService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">        extendService.sayHello();</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改META-INF下文件内容"><a href="#修改META-INF下文件内容" class="headerlink" title="修改META-INF下文件内容"></a>修改META-INF下文件内容</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ExtendService=com.lin.extendwrapper.extend.impl.ExtendServiceImpl</span><br><span class="line"><span class="comment"># 增加一行</span></span><br><span class="line">ExtendService=com.lin.extendwrapper.extend.impl.ExtendServiceImplWrapper</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;扩展点自动包装，会在通过ExtensionLoader获取扩展点时判断是否是包装类。如果是wrapper包装类，就是调用wrapper的service中的方法，包装后执行。</p>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>dubboSPI扩展点自动激活</title>
    <url>/hexoblog/2021/04/20/md/dubbo/dubboSPI%E6%89%A9%E5%B1%95%E7%82%B9%E8%87%AA%E5%8A%A8%E6%BF%80%E6%B4%BB/</url>
    <content><![CDATA[<h1 id="扩展点自动激活"><a href="#扩展点自动激活" class="headerlink" title="扩展点自动激活"></a>扩展点自动激活</h1><p>&emsp;&emsp;对于集合类扩展点，比如：Filter, InvokerListener, ExportListener, TelnetHandler, StatusChecker 等，可以同时加载多个实现，此时，可以用自动激活来简化配置。</p>
<span id="more"></span>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 激活过滤器</span></span><br><span class="line"><span class="meta">@Activate</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterOne</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>dubboSPI扩展机制自适应</title>
    <url>/hexoblog/2021/04/19/md/dubbo/dubboSPI%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%E8%87%AA%E9%80%82%E5%BA%94/</url>
    <content><![CDATA[<h1 id="扩展点自适应"><a href="#扩展点自适应" class="headerlink" title="扩展点自适应"></a>扩展点自适应</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>&emsp;&emsp;ExtensionLoader注入的依赖扩展点是一个Adaptive实例，直到扩展点方法执行时才决定调用是哪一个扩展点实现。<br>&emsp;&emsp;dubbo使用url对象传递对象信息，包含key和value。<br>&emsp;&emsp;扩展点方法调用会有URL参数（或是参数有URL成员）这样依赖的扩展点也可以从URL拿到配置信息，所有的扩展点自己定好配置的 Key后，配置信息从URL上从最外层传入。URL在配置传递上即是一条总线。</p>
<span id="more"></span>
<h2 id="Adaptive注解"><a href="#Adaptive注解" class="headerlink" title="@Adaptive注解"></a>@Adaptive注解</h2><p>&emsp;&emsp;表示该类是一个扩展类（Adaptive实例），不需要生成代理方法直接使用即可。<br>&emsp;&emsp;在方法上则表示该方法需生成代理, 此时就需要用到上面提到的URL参数。<br>&emsp;&emsp;如果作用在方法会帮我们在运行时动态生成一个Adaptive实例（只包含扩展方法的），如果作用在类上就相当于自己定义了一个现成的。</p>
<h3 id="注解在实现类上"><a href="#注解在实现类上" class="headerlink" title="注解在实现类上"></a>注解在实现类上</h3><p>&emsp;&emsp;表示该类是一个扩展类，不需要生成代理方法直接使用即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩展的接口</span></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdaptiveService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是扩展类</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveServiceImpl</span> <span class="keyword">implements</span> <span class="title">AdaptiveService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样需要文件</span></span><br><span class="line"><span class="comment">// 文件名为接口全限定名</span></span><br><span class="line"><span class="comment">// 内容为key=value，value为实现类全限定名</span></span><br><span class="line">AdaptiveService=com.lin.extendAdaptive.extend.impl.AdaptiveServiceImpl</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendAdaptiveMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;AdaptiveService&gt; extensionLoader = ExtensionLoader.getExtensionLoader(AdaptiveService.class);</span><br><span class="line">        AdaptiveService adaptiveExtension = extensionLoader.getAdaptiveExtension();</span><br><span class="line">        adaptiveExtension.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注解在接口方法上"><a href="#注解在接口方法上" class="headerlink" title="注解在接口方法上"></a>注解在接口方法上</h3><p>&emsp;&emsp;在方法上则表示该方法需生成代理, 此时就需要用到上面提到的URL参数。<br>&emsp;&emsp;当注解在接口方法上时，方法中需要传入一个URL参数，或者包装有URL参数时，会通过动态编译获得一个Adaptive实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodAdaptiveService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive(&#123;&quot;key&quot;&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAdaptiveServiceImpl</span> <span class="keyword">implements</span> <span class="title">MethodAdaptiveService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(URL url)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// META—INF文件与注解在类上时相同</span></span><br><span class="line">MethodAdaptiveService=com.lin.extendAdaptive.extend.impl.MethodAdaptiveServiceImpl</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;MethodAdaptiveService&gt; extensionLoader = ExtensionLoader.getExtensionLoader(MethodAdaptiveService.class);</span><br><span class="line">        MethodAdaptiveService adaptiveExtension = extensionLoader.getAdaptiveExtension();</span><br><span class="line">        HashMap hashMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">// key与接口中注解的key相同，value与文件中声明的名称相同</span></span><br><span class="line">        hashMap.put(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;MethodAdaptiveService&quot;</span>);</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;dubbo&quot;</span>,<span class="string">&quot;localhost&quot;</span>,<span class="number">8080</span>,hashMap);</span><br><span class="line">        adaptiveExtension.sayHello(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成的实例</span></span><br><span class="line"><span class="keyword">package</span> com.lin.extendAdaptive.extend;</span><br><span class="line"><span class="keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAdaptiveService</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">lin</span>.<span class="title">extendAdaptive</span>.<span class="title">extend</span>.<span class="title">MethodAdaptiveService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(org.apache.dubbo.common.URL arg0)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">        org.apache.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to get extension (com.lin.extendAdaptive.extend.MethodAdaptiveService) name from url (&quot;</span> + url.toString() + <span class="string">&quot;) use keys([key])&quot;</span>);</span><br><span class="line">        com.lin.extendAdaptive.extend.MethodAdaptiveService extension = (com.lin.extendAdaptive.extend.MethodAdaptiveService)ExtensionLoader.getExtensionLoader(com.lin.extendAdaptive.extend.MethodAdaptiveService.class).getExtension(extName);</span><br><span class="line">        extension.sayHello(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, dubbo version: <span class="number">2.7</span><span class="number">.1</span>, current host: <span class="number">192.168</span><span class="number">.139</span><span class="number">.15</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;程序运行时，会经过动态编译过程生成MethodAdaptiveService对应的Adaptive实例，即MethodAdaptiveService$Adaptive。<br>&emsp;&emsp;就是在程序运行过程中，根据条件，通过拼接字符串的形式生成java源码，然后进行编译获得对应的实例。</p>
<hr>
<h1 id="扩展点自动注入"><a href="#扩展点自动注入" class="headerlink" title="扩展点自动注入"></a>扩展点自动注入</h1><p>有bug稍后。</p>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo基础及介绍</title>
    <url>/hexoblog/2021/04/15/md/dubbo/dubbo%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>&emsp;&emsp;RPC，Remote Procedure Call 即远程过程调用，远程过程调用其实对标的是本地过程调用。<br>&emsp;&emsp;远程调用的方法可以走http协议也可以是基于tcp的自定义协议。</p>
<span id="more"></span>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>&emsp;&emsp;一个RPC框架要做的就是约定通信协议，序列化格式，容错机制，负载均衡策略，监控运维和一个注册中心。</p>
<ol>
<li>服务消费者</li>
<li>服务提供者</li>
<li>注册中心</li>
<li>监控中心</li>
</ol>
<hr>
<h1 id="DUBBO"><a href="#DUBBO" class="headerlink" title="DUBBO"></a>DUBBO</h1><p>&emsp;&emsp;它实现了面向接口的代理 RPC 调用，并且可以配合 ZooKeeper 等组件实现服务注册和发现功能，并且拥有负载均衡、容错机制等。<br>&emsp;&emsp;<a href="https://juejin.cn/post/6870276943448080392#heading-9">https://juejin.cn/post/6870276943448080392#heading-9</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="dubbo的作用"><a href="#dubbo的作用" class="headerlink" title="dubbo的作用"></a>dubbo的作用</h3><ol>
<li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li>
<li>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li>
<li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除。</li>
</ol>
<h3 id="dubbo分层结构"><a href="#dubbo分层结构" class="headerlink" title="dubbo分层结构"></a>dubbo分层结构</h3><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/a26bba7ba53849b9b9efbdf844f720c2_tplv-k3u1fbpfcp-zoom-1.jpg" alt="dubbo的十层结构"></p>
<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/25609524-edfea2d2c42798d0.jpg" alt="dubbo的十层结构"></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/dubbo-architecture.jpg" alt="dubbo结构"></p>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者Provider向注册中心注册自己所能提供的服务。</li>
<li>服务消费者Consumer启动向注册中心订阅自己所需的服务。</li>
<li>注册中心将提供者元信息通知给消费者，消费者从注册中心获取提供者的地址。</li>
<li>通过负载均衡选择一个Provider直接调用。如果失败，则会重新选择另一台进行调用。</li>
<li>如果提供者有变更，注册中心会将变更推送给消费者。</li>
<li>服务提供者和消费者都会在内存中记录着调用的次数和时间，然后定时（每分钟）的发送统计数据到监控中心。</li>
</ol>
<h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h3><ol>
<li>注册中心和监控中心是可选的，可以直接在配置中写提供者和消费者直连。</li>
<li>注册中心、提供方和消费方之间都是长连接，和监控方不是长连接，并且消费方是直接调用提供方，不经过注册中心。</li>
<li>注册中心和监控中心宕机了也不会影响到已经正常运行的提供者和消费者，因为消费者有本地缓存提供者的信息。</li>
</ol>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP三次握手四次挥手</title>
    <url>/hexoblog/2021/04/30/md/internet/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;在网络层通过IP协议可以实现两个主机之间的通信，但是无法确定是主机中的那个进程之间进行的通信，而实际及性能通信的则是主机中的进程。  </p>
<span id="more"></span>

<p>&emsp;&emsp;TCP面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此TCP是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有SMTP,TELNET,HTTP,FTP等。<br>&emsp;&emsp;TCP把连接作为最基本的对象，每一条TCP连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到IP地址即构成了套接字，例如，若IP地址为127.0.0.1 而端口号为80，那么得到的套接字为127.0.0.1:80。<br>&emsp;&emsp;TCP采用全双工通信，这要求了服务端与客户端必须双方都能进行向对方发送数据，所以建立断开连接必须建立或者断开两次。</p>
<hr>
<h1 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/tcp%E6%8A%A5%E6%96%87%E9%A6%96%E9%83%A8.jpg" alt="TCP报文"></p>
<ol>
<li>源端口和目的端口：分别写入源端口和目的接口。</li>
<li>序号：占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。当前为301时，如果传输100个字节后，下一个报文段从401开始。</li>
<li>确认号：占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。</li>
<li>数据偏移：占4位（半个字节），它指出TCP报文的数据距离TCP报文段的起始处有多远。</li>
<li>保留位置：占6位，保留今后使用，但目前应都位0。</li>
<li>紧急URG：当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据。</li>
<li>确认ACK：仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1。</li>
<li>推送PSH：当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1。</li>
<li>复位RST：当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。</li>
<li>同步SYN：在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1。</li>
<li>终止FIN：用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放。</li>
<li>窗口：占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受。</li>
<li>检验和：占2字节，校验首部和数据这两部分。</li>
<li>紧急指针：占2字节，指出本报文段中的紧急数据的字节数。</li>
<li>选项：长度可变，定义一些其他的可选的参数。</li>
</ol>
<hr>
<h1 id="TCP连接的建立（三次握手）"><a href="#TCP连接的建立（三次握手）" class="headerlink" title="TCP连接的建立（三次握手）"></a>TCP连接的建立（三次握手）</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP连接建立"></p>
<ol>
<li>服务端先创建传输控制块，准备监听客户端进程的连接请求，此时服务器就进入了Listen状态。</li>
<li>客户端也建立传输控制块，向服务端发送连接请求报文，此时客户端进入SYN-SENT状态（同步已发送）。<blockquote>
<p>TCP规定，SYN报文段（SYN=1的报文段）<strong>不能携带数据</strong>，但需消耗掉一个序号。<br>此时报文内容SYN=1，seq=x。</p>
</blockquote>
</li>
<li>服务器接收到请求后，如果同意连接，则发出确认报文，此时服务器进入SYN-RCVD状态（同步收到）。<blockquote>
<p>这个报文同样不能携带数据，需要消耗一个序号。<br>此时报文内容为SYN=1,ACK=1,seq=y,ack=x+1。seq为自己发送的序列号，ack因为上一次的发连接请求报文不带数据，所以确认号直接为x+。</p>
</blockquote>
</li>
<li>客户端进程收到确认后，还要向服务器给出确认。确认后，TCP连接建立，客户端进入ESTABLISHED状态（已建立连接）。<blockquote>
<p>TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。<br>此时的报文内容为ACK=1,seq=x+1,ack=y+1；这里相对于同步请求是客户端发给服务端的第二个请求，所有seq为x+1。</p>
</blockquote>
</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<hr>
<h1 id="TCP连接的断开（四次回收）"><a href="#TCP连接的断开（四次回收）" class="headerlink" title="TCP连接的断开（四次回收）"></a>TCP连接的断开（四次回收）</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手"></p>
<ol>
<li>客户端发送连接释放报文，停止发送数据，客户端进入FIN-WAIT-1状态（终止等待1）。<blockquote>
<p>TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。与SYN报文段相似。<br>此时报文内容为FIN=1,seq=u。这里的序列号跟随前面的数据的序列号，为最后一个字节数据的序列号加一。</p>
</blockquote>
</li>
<li>服务器收到连接释放报文，发送出自己的释放报文，服务端进入CLOSE-WAIT状态（关闭等待）。<blockquote>
<p>TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个过程需要持续一段时间，等待服务器将数据发送完。<br>此时报文内容为ACK=1,seq=v,ack=u+1。</p>
</blockquote>
</li>
<li>客户端收到服务器的释放确认后，进入FIN-WAIT-2状态，等待服务器发送连接释放报文，这个过程中会继续接受服务器发送的数据内容。</li>
<li>服务器将数据发送完毕后，向客户端发送连接释放报文，服务器进入LAST-ACK状态，等待最后的确认。<blockquote>
<p>此时报文内容为FIN=1,ACK=1,seq=w,ack=u+1，在上个过程中，客户端不会向服务端发送信息所以ack不变，而服务端会向客户端发送所以seq会变化。</p>
</blockquote>
</li>
<li>客户端收到连接释放后，向服务器发出确认，客户端进入TIME-WAIT状态。<blockquote>
<p>注意此时TCP连接还没有释放，必须经过2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。<br>此时报文内容为ACK=1,seq=u+1,ack=w+1。</p>
</blockquote>
</li>
<li>服务器收到确认信息后，会立即进入CLOSED状态，撤销TCB结束连接。</li>
</ol>
<hr>
<h1 id="通俗一点"><a href="#通俗一点" class="headerlink" title="通俗一点"></a>通俗一点</h1><p>&emsp;&emsp;举个例子：</p>
<ul>
<li>甲方：你好，我是甲方，你能听到吗？</li>
<li>乙方：你好，我能听到，我是乙方，你能听到吗？&lt;甲方收到，甲方建立连接&gt;</li>
<li>甲方：我能听到。&lt;乙方收到，乙方建立连接&gt;</li>
<li></li>
<li>连接建立，开始扯皮。</li>
<li>甲方乙方：。。。（扯皮中）。</li>
<li></li>
<li>甲方：我说完了，就这样吧。</li>
<li>乙方：你说完了好的，我最后在说一下。</li>
<li>乙方：。。。乙方批斗需求中。</li>
<li>乙方：我也说完了，挂了吧。</li>
<li>甲方：好的，挂了。&lt;乙方收到，乙方挂掉了&gt;</li>
<li></li>
<li>甲方：{等了一个来回的时间了，他应该收到了}。&lt;甲方挂掉了&gt;</li>
</ul>
<hr>
<h1 id="一点问题"><a href="#一点问题" class="headerlink" title="一点问题"></a>一点问题</h1><h2 id="为什么TCP客户端最后还要发送一次确认呢？（为什么不是2次握手）"><a href="#为什么TCP客户端最后还要发送一次确认呢？（为什么不是2次握手）" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？（为什么不是2次握手）"></a>为什么TCP客户端最后还要发送一次确认呢？（为什么不是2次握手）</h2><p>&emsp;&emsp;防止因网络抖动各种原因造成的连接请求，突然又传送到了服务端，从而产生错误。<br>&emsp;&emsp;采用两次握手的情况下，假设第一次的连接请求在网络中阻塞了，服务端没有收到客户端的请求报文就不会处理，客户端一直收不到确认就会认为服务器没有收到，则会重新发送这条请求，此后客户端和服务端完成握手，建立连接。<br>&emsp;&emsp;这时，在网络中阻塞的第一次的请求突然到达服务器就会出现问题。</p>
<blockquote>
<p>如果建立连接后传输完成数据且关闭连接了，就会产生重新建立连接的问题，而采用3次握手，即使服务端收到了出错的连接请求而发送了确认信息，但是客户端没有需要传输的数据，不会进行第三次握手操作，就不会产生问题。<br>如果传输数据过程中收到了错误的连接请求，即使进行确认，也不会第三次进行握手。（这里待议）</p>
</blockquote>
<h2 id="服务端易受到SYN攻击？"><a href="#服务端易受到SYN攻击？" class="headerlink" title="服务端易受到SYN攻击？"></a>服务端易受到SYN攻击？</h2><p>&emsp;&emsp;服务端的资源是在第二次进行握手的时候分配的，而客户端的资源是在进行第三次握手的时候分配的。所以服务器容易收到SYN洪泛攻击，就是在短时间内伪造大量不存在的ip，不断的向服务器发送SYN包，服务端则回复并等待确认包，但是源地址是虚构的，所有不会收到确认包，服务端将不断重发进行重试知道超时，这些伪造的SYN包将占用大量且长时间的占用未连接队列，导致正常请求将被丢弃，引起网络瘫痪。<br>&emsp;&emsp;可以通过降低主机的等待时间释放未连接占用，或者短时间收到某ip的重复SYN报文将丢弃后续请求。</p>
<h2 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h2><p>&emsp;&emsp;保证客户端的最后一个ACK报文能够到达服务器，在服务端，没有接受到客户端的ACK就会认为服务器没有收到自己发送的FIN请求，这时就会重发FIN请求。对于客户端而言，收到FIN请求后，发送ACK确认信息，假设服务端没有收到ACK信息，就会重新发送FIN请求，客户端就会重新收到FIN请求，没有收到重新发送的FIN请求，就认为没有问题就可以断开连接了。</p>
<h2 id="如果已经建立了连接，但是客户端突然出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办？"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2><p>&emsp;&emsp;TCP设置有一个保活器，服务器每一次收到数据就会重新复位这个计时器，若计时器走完，没有收到客户端的数据，服务器就会发送探测报文，75秒一个探测报文，连续10个探测报文没有收到恢复，就认为客户端故障，断开连接。</p>
<h2 id="为什么是四次挥手而不是三次或者五次呢？"><a href="#为什么是四次挥手而不是三次或者五次呢？" class="headerlink" title="为什么是四次挥手而不是三次或者五次呢？"></a>为什么是四次挥手而不是三次或者五次呢？</h2><p>&emsp;&emsp;第二次挥手和第三次挥手都是服务端向客户端发送报文，第二次挥手是服务端收到了客户端的断开请求，通知客户端收到了，此时客户端没有数据向服务端发送了，但不代表服务端也没有数据向客户端发送，因为服务端要把剩余还没有发送的报文发送完毕再断开连接；第三次挥手是服务端数据全部发送完毕，向客户端发送断开请求报文（FIN=1）。<br>&emsp;&emsp;如果将这两次合二为一，就会出现服务端收到请求后立即确认并且断开连接，会造成服务端发送到客户端的数据不完整。五次则没有必要。</p>
<h2 id="问什么连接是三次断开是四次呢？"><a href="#问什么连接是三次断开是四次呢？" class="headerlink" title="问什么连接是三次断开是四次呢？"></a>问什么连接是三次断开是四次呢？</h2><p>&emsp;&emsp;断开是四次的原因和上面的问题的解答是一样的。<br>&emsp;&emsp;对于建立连接，3次其实是建立可靠连接的最小次数。可参考第一道问题。<br>&emsp;&emsp;因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭连接，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。<br>&emsp;&emsp;四次挥手相比于三次握手，将服务端返回给客户端的ACK+SYN报文，拆成了2次发送。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>filter_interceptor</title>
    <url>/hexoblog/2021/03/01/md/java/filter-interceptor/</url>
    <content><![CDATA[<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>&emsp;&emsp;过滤器是用来过滤的，java的过滤器能够为我们提供系统级别的过滤，也就是说能够过滤所有的web请求，这一点是拦截器做不到的。<br>&emsp;&emsp;在java web中，你传入的request，response提前过滤掉一些信息，或者提前设置一些参数，然后在传入Servlet进行业务逻辑，比如过滤掉非法url和非法字符串。<br>&emsp;&emsp;filter流程是线性的，url传来之后，检查之后，可保持原来的流程继续向下执行，被下一个filter，servlet接收。</p>
<span id="more"></span>

<hr>
<h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>&emsp;&emsp;java里面的拦截器提供的是非系统级别的拦截，也就是说，就覆盖面来说，拦截器不如过滤器强大但是更有针对性。<br>&emsp;&emsp;java中的拦截器是基于java反射机制实现的，更准确的划分，应该是基于jdk实现的动态代理。它依赖于具体的接口，在运行期间动态生成字节码。<br>&emsp;&emsp;拦截器是动态拦截Action调用的对象，他提供了一种机制可以使开发者在一个ation执行的前后执行一段代码，也可以在一个action执行前阻止其执行，同时也提供了一种可以提取action中可重用代码的方式。在AOP中，拦截器用于在某个方法或字段被访问之前，进行拦截然后再之前或之后加入某些操作。java的拦截器主要用于插件上，扩展件上，有点类似于面向切面的技术，在用之前要先在配置文件里声明。</p>
<hr>
<h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>&emsp;&emsp;java的监听器也是系统级别的监听。监听器随web应用的启动而启动。<br>&emsp;&emsp;java的监听器在c/s模式里面经常用到，它会对特定的事件产生一个处理。监听器在很多模式下用到，比如说观察者模式，就是使用监听器来实现的，又比如统计网站的在线人数。servlet监听器用于监听一些重要事件的发生，监听器对象可以在事件发生前，发生后做一些必要的处理。</p>
<hr>
<h1 id="对照"><a href="#对照" class="headerlink" title="对照"></a>对照</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/interceptor_filter_1.jpg" alt="对照"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>filter</tag>
        <tag>interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title>javaSPI扩展</title>
    <url>/hexoblog/2021/04/16/md/java/javaSPI%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;SPI就是一种服务发现机制。<br>&emsp;&emsp;SPI 是一种将服务接口与服务实现分离以达到解耦、大大提升了程序可扩展性的机制。引入服务提供者就是引入了 spi 接口的实现者，通过本地的注册发现获取到具体的实现类，轻松可插拔。<br>&emsp;&emsp;Java SPI 就是把某个接口的 指定实现类 （通过在指定文件配置的方式）给实例化出来了。</p>
<span id="more"></span>

<hr>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>&emsp;&emsp;需要准备一个maven工程，以此为蓝本，进行开发。</p>
<h2 id="创建接口及实现类"><a href="#创建接口及实现类" class="headerlink" title="创建接口及实现类"></a>创建接口及实现类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl1</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl2</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建META-INF-service文件夹，建立文件"><a href="#创建META-INF-service文件夹，建立文件" class="headerlink" title="创建META-INF/service文件夹，建立文件"></a>创建META-INF/service文件夹，建立文件</h2><p>&emsp;&emsp;这里建立的文件名与接口的全限定名相同，文件的内容为接口实现类的全限定名。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">com.lin.javaspi.service.impl.HelloServiceImpl1</span><br><span class="line">com.lin.javaspi.service.impl.HelloServiceImpl2</span><br></pre></td></tr></table></figure>

<h2 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a>启动方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException </span>&#123;</span><br><span class="line">        ServiceLoader&lt;HelloService&gt; load = ServiceLoader.load(HelloService.class);</span><br><span class="line">        Iterator&lt;HelloService&gt; iterator = load.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            HelloService next = iterator.next();</span><br><span class="line">            next.sayHello();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        Class&lt;?&gt; aClass = Class.forName(&quot;com.lin.javaspi.service.impl.HelloServiceImpl1&quot;);</span></span><br><span class="line"><span class="comment">//        HelloServiceImpl1 o = (HelloServiceImpl1) aClass.newInstance();</span></span><br><span class="line"><span class="comment">//        o.sayHello();</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol>
<li>应用程序调用ServiceLoader.load方法。<blockquote>
<p>ServiceLoader.load方法内先创建一个新的ServiceLoader，并实例化该类中的成员变量。</p>
</blockquote>
</li>
<li>应用程序通过迭代器接口获取对象实例。<blockquote>
<p>ServiceLoader先判断成员变量providers对象中<code>LinkedHashMap&lt;String,S&gt;</code>类型是否有缓存实例对象，如果有缓存，直接返回。</p>
</blockquote>
<ol>
<li>读取META-INF/services/下的配置文件，获得所有能被实例化的类的名称，值得注意的是，ServiceLoader可以跨越jar包获取META-INF下的配置文件。</li>
<li>通过反射方法<code>Class.forName()</code>加载类对象，并用<code>instance()</code>方法将类实例化。</li>
<li>把实例化后的类缓存到providers对象中，<code>LinkedHashMap&lt;String,S&gt;</code>类型然后返回实例对象。</li>
</ol>
</li>
</ol>
<hr>
<h1 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h1><ol>
<li>必须要有接口</li>
<li>对应要有实现类，且具备空参构造方法。</li>
<li>文件夹META-INF/services放置classpath目录下。</li>
<li>以“接口全限定名”命名的文件。</li>
<li>文件内容为接口实现类的全路径。</li>
</ol>
<hr>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>&emsp;&emsp;调用者根据实际使用需要，启用、扩展、或者替换框架的实现策略</p>
<ol>
<li><p>jdbc</p>
<blockquote>
<p>不同的数据库使用不同的jdbc驱动，他们实现了相同的接口，java.sql.Driver</p>
</blockquote>
</li>
<li><p>日志门面接口实现类加载</p>
<blockquote>
<p>slf4j加载不同的提供商的日志实现类</p>
</blockquote>
</li>
<li><p>spring</p>
</li>
<li><p>dubbo</p>
</li>
</ol>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>&emsp;&emsp;使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。<br>&emsp;&emsp;相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p>
<ol>
<li>代码硬编码import 导入实现类。</li>
<li>指定类全路径反射获取，<code>Class.forName()</code>。</li>
<li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例。</li>
</ol>
<p>&emsp;&emsp;通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF/services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类。</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。</li>
<li>多个并发多线程使用ServiceLoader类的实例是不安全的。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>SPI</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>threadpool</title>
    <url>/hexoblog/2021/03/01/md/java/threadpool/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><a href="https://my.oschina.net/linqiankun/blog/3192649">线程池</a><br><a href="https://gitee.com/linqiankun/codes/cshv4db0eq7znx6a5g2im43">线程池demo</a></p>
<h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool:"></a>newCachedThreadPool:</h2><h3 id="底层："><a href="#底层：" class="headerlink" title="底层："></a>底层：</h3><p>&emsp;&emsp;创建一个可缓存的线程池实例，如果线程池长度超过处理需要，可灵活回收空闲线程。<br>&emsp;&emsp;返回ThreadPoolExecutor实例，corePoolSize为0；maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为60L；unit为TimeUnit.SECOhexoNDS；workQueue为SynchronousQueue(同步队列)。</p>
<span id="more"></span>

<h3 id="通俗："><a href="#通俗：" class="headerlink" title="通俗："></a>通俗：</h3><p>&emsp;&emsp;当有新任务到来，则插入到SynchronousQueue中，由于SynchronousQueue是同步队列，因此会在池中寻找可用线程来执行，若有可以线程则执行，若没有可用线程则创建一个线程来执行该任务；若池中线程空闲时间超过指定大小，则该线程会被销毁。</p>
<h3 id="适用："><a href="#适用：" class="headerlink" title="适用："></a>适用：</h3><p>&emsp;&emsp;执行很多短期异步的小程序或者负载较轻的服务器。</p>
<hr>
<h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool:"></a>newFixedThreadPool:</h2><h3 id="底层：-1"><a href="#底层：-1" class="headerlink" title="底层："></a>底层：</h3><p>&emsp;&emsp;创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。<br>&emsp;&emsp;返回ThreadPoolExecutor实例，接收参数为所设定线程数量nThread，corePoolSize为nThread，maximumPoolSize为nThread；keepAliveTime为0L(不限时)；unit为：TimeUnit.MILLISECONDS；WorkQueue为：new LinkedBlockingQueue&lt;Runnable&gt;() 无界阻塞队列。</p>
<h3 id="通俗：-1"><a href="#通俗：-1" class="headerlink" title="通俗："></a>通俗：</h3><p>&emsp;&emsp;创建可容纳固定数量线程的池子，每隔线程的存活时间是无限的，当池子满了就不在添加线程了；如果池中的所有线程均在繁忙状态，对于新任务会进入阻塞队列中(无界的阻塞队列)。</p>
<h3 id="适用：-1"><a href="#适用：-1" class="headerlink" title="适用："></a>适用：</h3><p>&emsp;&emsp;执行长期任务，性能好很多。</p>
<hr>
<h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor:"></a>newSingleThreadExecutor:</h2><h3 id="底层：-2"><a href="#底层：-2" class="headerlink" title="底层："></a>底层：</h3><p>&emsp;&emsp;创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有线程按照指定顺序执行。<br>&emsp;&emsp;FinalizableDelegatedExecutorService包装的ThreadPoolExecutor实例，corePoolSize为1；maximumPoolSize为1；keepAliveTime为0L；unit为：TimeUnit.MILLISECONDS；workQueue为：new LinkedBlockingQueue&lt;Runnable&gt;() 无解阻塞队列。</p>
<h3 id="通俗：-2"><a href="#通俗：-2" class="headerlink" title="通俗："></a>通俗：</h3><p>&emsp;&emsp;创建只有一个线程的线程池，且线程的存活时间是无限的；当该线程正繁忙时，对于新任务会进入阻塞队列中(无界的阻塞队列)。</p>
<h3 id="适用：-2"><a href="#适用：-2" class="headerlink" title="适用："></a>适用：</h3><p>&emsp;&emsp;一个任务一个任务执行的场景。</p>
<hr>
<h2 id="NewScheduledThreadPool"><a href="#NewScheduledThreadPool" class="headerlink" title="NewScheduledThreadPool:"></a>NewScheduledThreadPool:</h2><h3 id="底层：-3"><a href="#底层：-3" class="headerlink" title="底层："></a>底层：</h3><p>&emsp;&emsp;创建一个定长线程池，支持定时及周期性执行任务。<br>&emsp;&emsp;创建ScheduledThreadPoolExecutor实例，corePoolSize为传递来的参数，maximumPoolSize为Integer.MAX_VALUE；keepAliveTime为0；unit为：TimeUnit.NANOSECONDS；workQueue为：new DelayedWorkQueue() 一个按超时时间升序排序的队列。</p>
<h3 id="通俗：-3"><a href="#通俗：-3" class="headerlink" title="通俗："></a>通俗：</h3><p>&emsp;&emsp;创建一个固定大小的线程池，线程池内线程存活时间无限制，线程池可以支持定时及周期性任务执行，如果所有线程均处于繁忙状态，对于新任务会进入DelayedWorkQueue队列中，这是一种按照超时时间排序的队列结构。</p>
<h3 id="适用：-3"><a href="#适用：-3" class="headerlink" title="适用："></a>适用：</h3><p>&emsp;&emsp;周期性执行任务的场景。</p>
<hr>
<h1 id="线程池任务执行流程："><a href="#线程池任务执行流程：" class="headerlink" title="线程池任务执行流程："></a>线程池任务执行流程：</h1><ol>
<li>当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li>
<li>当线程池达到corePoolSize时，新提交任务将被放入workQueue中，等待线程池中任务调度执行</li>
<li>当workQueue已满，且maximumPoolSize&gt;corePoolSize时，新提交任务会创建新线程执行任务</li>
<li>当提交任务数超过maximumPoolSize时，新提交任务由RejectedExecutionHandler处理</li>
<li>当线程池中超过corePoolSize线程，空闲时间达到keepAliveTime时，关闭空闲线程</li>
<li>当设置allowCoreThreadTimeOut(true)时，线程池中corePoolSize线程空闲时间达到keepAliveTime也将关闭</li>
</ol>
<hr>
<h1 id="参数解释："><a href="#参数解释：" class="headerlink" title="参数解释："></a>参数解释：</h1><h2 id="corePoolSize-amp-maximumPoolSize："><a href="#corePoolSize-amp-maximumPoolSize：" class="headerlink" title="corePoolSize &amp; maximumPoolSize："></a>corePoolSize &amp; maximumPoolSize：</h2><p>&emsp;&emsp;当一个新任务被提交到池中，如果当前运行线程小于核心线程数（corePoolSize），即使当前有空闲线程，也会新建一个线程来处理新提交的任务；如果当前运行线程数大于核心线程数（corePoolSize）并小于最大线程数（maximumPoolSize），只有当等待队列已满的情况下才会新建线程。</p>
<h2 id="keepAliveTime-amp-unit"><a href="#keepAliveTime-amp-unit" class="headerlink" title="keepAliveTime &amp; unit:"></a>keepAliveTime &amp; unit:</h2><p>&emsp;&emsp;keepAliveTime为超过corePoolSize线程数量的线程最大空闲时间，unit为时间单位。</p>
<h2 id="等待队列："><a href="#等待队列：" class="headerlink" title="等待队列："></a>等待队列：</h2><p>&emsp;&emsp;任何阻塞队列（BlockingQueue）都可以用来转移或保存提交的任务，线程池大小和阻塞队列相互约束线程池：</p>
<ol>
<li>如果运行线程数小于corePoolSize，提交新任务时就会新建一个线程来运行；</li>
<li>如果运行线程数大于或等于corePoolSize，新提交的任务就会入列等待；如果队列已满，并且运行线程数小于maximumPoolSize，也将会新建一个线程来运行；</li>
<li>如果线程数大于maximumPoolSize，新提交的任务将会根据拒绝策略来处理。</li>
</ol>
<h3 id="入队列策略："><a href="#入队列策略：" class="headerlink" title="入队列策略："></a>入队列策略：</h3><h4 id="直接传递："><a href="#直接传递：" class="headerlink" title="直接传递："></a>直接传递：</h4><p>&emsp;&emsp;通过 SynchronousQueue 直接把任务传递给线程。如果当前没可用线程，尝试入队操作会失败，然后再创建一个新的线程。当处理可能具有内部依赖性的请求时，该策略会避免请求被锁定。直接传递通常需要无界的最大线程数（maximumPoolSize），避免拒绝新提交的任务。当任务持续到达的平均速度超过可处理的速度时，可能导致线程的无限增长。</p>
<h4 id="无界队列："><a href="#无界队列：" class="headerlink" title="无界队列："></a>无界队列：</h4><p>&emsp;&emsp;使用无界队列（如 LinkedBlockingQueue）作为等待队列，当所有的核心线程都在处理任务时， 新提交的任务都会进入队列等待。因此，不会有大于corePoolSize的线程会被创建（maximumPoolSize 也将失去作用）。这种策略适合每个任务都完全独立于其他任务的情况；例如网站服务器。这种类型的等待队列可以使瞬间爆发的高频请求变得平滑。当任务持续到达的平均速度超过可处理速度时，可能导致等待队列无限增长。</p>
<h4 id="有界队列："><a href="#有界队列：" class="headerlink" title="有界队列："></a>有界队列：</h4><p>&emsp;&emsp;当使用有限的最大线程数时，有界队列（如 ArrayBlockingQueue）可以防止资源耗尽，但是难以调整和控制。队列大小和线程池大小可以相互作用：使用大的队列和小的线程数可以减少CPU使用率、系统资源和上下文切换的开销，但是会导致吞吐量变低，如果任务频繁地阻塞（例如被I/O限制），系统就能为更多的线程调度执行时间。使用小的队列通常需要更多的线程数，这样可以最大化CPU使用率，但可能会需要更大的调度开销，从而降低吞吐量。</p>
<h2 id="拒绝策略："><a href="#拒绝策略：" class="headerlink" title="拒绝策略："></a>拒绝策略：</h2><p>&emsp;&emsp;当线程池已经关闭或达到饱和（最大线程和队列都已满）状态时，新提交的任务将会被拒绝。<br>ThreadPoolExecutor定义了四种拒绝策略:</p>
<h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy:"></a>AbortPolicy:</h3><p>&emsp;&emsp;默认策略，在需要拒绝任务时抛出RejectedExecutionException。</p>
<h3 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy:"></a>CallerRunsPolicy:</h3><p>&emsp;&emsp;直接在execute方法的调用线程中运行被拒绝的任务，如果线程池已经关闭，任务将被丢弃。</p>
<h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy:"></a>DiscardPolicy:</h3><p>&emsp;&emsp;直接丢弃任务。</p>
<h3 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy:"></a>DiscardOldestPolicy:</h3><p>&emsp;&emsp;丢弃队列中等待时间最长的任务，并执行当前提交的任务，如果线程池已经关闭，任务将被丢弃。</p>
<h3 id="自定义策略："><a href="#自定义策略：" class="headerlink" title="自定义策略："></a>自定义策略：</h3><p>&emsp;&emsp;我们也可以自定义拒绝策略，只需要实现 RejectedExecutionHandler；需要注意的是，拒绝策略的运行需要指定线程池和队列的容量。</p>
<hr>
<h1 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h1><ol>
<li>newFixedThreadPool和newSingleThreadExecutor：主要问题是堆积的请求处理队列可能会耗费非常大的内存，甚至OOM。</li>
<li>newCachedThreadPool和newScheduledThreadPool：主要问题是线程数最大数是Integer.MAX_VALUE，可能会创建数量非常多的线程，甚至OOM。</li>
</ol>
<hr>
<h1 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h1><p>&emsp;&emsp;一般如果线程池任务队列采用LinkedBlockingQueue队列的话，那么不会拒绝任何任务（因为队列大小没有限制），这种情况下，ThreadPoolExecutor最多仅会按照最小线程数来创建线程，也就是说线程池大小被忽略了。<br>&emsp;&emsp;如果线程池任务队列采用ArrayBlockingQueue队列的话，那么ThreadPoolExecutor将会采取一个非常负责的算法，比如假定线程池的最小线程数为4，最大为8所用的ArrayBlockingQueue最大为10。随着任务到达并被放到队列中，线程池中最多运行4个线程（即最小线程数）。即使队列完全填满，也就是说有10个处于等待状态的任务，ThreadPoolExecutor也只会利用4个线程。如果队列已满，而又有新任务进来，此时才会启动一个新线程，这里不会因为队列已满而拒接该任务，相反会启动一个新线程。新线程会运行队列中的第一个任务，为新来的任务腾出空间。<br>&emsp;&emsp;这个算法背后的理念是：该池大部分时间仅使用核心线程（4个），即使有适量的任务在队列中等待运行。这时线程池就可以用作节流阀。如果挤压的请求变得非常多，这时该池就会尝试运行更多的线程来清理；这时第二个节流阀—最大线程数就起作用了。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>thread</tag>
        <tag>threadpool</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化与反序列化</title>
    <url>/hexoblog/2021/03/08/md/java/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><ol>
<li>序列化：把对象转换为字节数组的过程称为对象的序列化。</li>
<li>反序列化：把字节序列转换为对象的过程称为对象的反序列化。</li>
</ol>
<span id="more"></span>

<hr>
<h1 id="什么时候需要序列化与反序列化？"><a href="#什么时候需要序列化与反序列化？" class="headerlink" title="什么时候需要序列化与反序列化？"></a>什么时候需要序列化与反序列化？</h1><p>&emsp;&emsp;当我们只在本地 JVM 里运行下 Java 实例，这个时候是不需要什么序列化和反序列化的，但当我们需要将内存中的对象持久化到磁盘，数据库中时， 当我们需要与浏览器进行交互时，当我们需要实现 RPC 时， 这个时候就需要序列化和反序列化了。<br>&emsp;&emsp;对于与浏览器的交互，采用json格式，json格式本身就是将一个对象转换为字符串，而字符串同样是实现了序列化的。<br>&emsp;&emsp;对于将数据持久化到数据库，我们同样是将属性保存到数据库，而不是将对象保存到数据库。</p>
<hr>
<h1 id="为什么要实现-Serializable-接口"><a href="#为什么要实现-Serializable-接口" class="headerlink" title="为什么要实现 Serializable 接口?"></a>为什么要实现 Serializable 接口?</h1><p>&emsp;&emsp;在 Java 中实现了 Serializable 接口后， JVM 会在底层帮我们实现序列化和反序列化。</p>
<hr>
<h1 id="为什么还要指定serialVersionUID的值"><a href="#为什么还要指定serialVersionUID的值" class="headerlink" title="为什么还要指定serialVersionUID的值?"></a>为什么还要指定serialVersionUID的值?</h1><p>&emsp;&emsp;如果不显示指定serialVersionUID，JVM在序列化时会根据属性自动生成一个serialVersionUID，然后与属性一起序列化，再进行持久化或网络传输。<br>&emsp;&emsp;在反序列化时，JVM会再根据属性自动生成一个新版 serialVersionUID，然后将这个新版serialVersionUID与序列化时生成的旧版serialVersionUID进行比较，如果相同则反序列化成功，否则报错。<br>&emsp;&emsp;如果显示指定了serialVersionUID，JVM在序列化和反序列化时仍然都会生成一个serialVersionUID，但值为我们显示指定的值，这样在反序列化时新旧版本的 serialVersionUID 就一致了。<br>&emsp;&emsp;默认的serialVersionUID，是根据类的属性生成的，如果类的属性发生变化，serialVersionUID的值对应会发生变化，这时候去反序列化原有的对象就会失败。而显式指定之后则解决了这个问题。</p>
<hr>
<h1 id="序列化的其他特性"><a href="#序列化的其他特性" class="headerlink" title="序列化的其他特性"></a>序列化的其他特性</h1><p>&emsp;&emsp;被transient关键字修饰的属性不会被序列化，static属性也不会被序列化。</p>
<h2 id="static-属性为什么不会被序列化"><a href="#static-属性为什么不会被序列化" class="headerlink" title="static 属性为什么不会被序列化?"></a>static 属性为什么不会被序列化?</h2><p>&emsp;&emsp;因为序列化是针对对象而言的，而static属性优先于对象存在，随着类的加载而加载，所以不会被序列化。<br>&emsp;&emsp;其实serialVersionUID属性并没有被序列化，JVM在序列化对象时会自动生成一个serialVersionUID，然后将我们显示指定的serialVersionUID属性值赋给自动生成的serialVersionUID。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>强软弱虚引用</title>
    <url>/hexoblog/2021/04/23/md/java/%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>可以通过代码的方式决定某些对象的生命周期。</li>
<li>有利于JVM进行垃圾回收。</li>
</ol>
<span id="more"></span>

<hr>
<h1 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h1><p>&emsp;&emsp;对象的一般状态，初始化new出来的对象就是强引用。<br>&emsp;&emsp;可达性分析算法中，根据GC Roots向下查找是用的就是强引用。</p>
<hr>
<h1 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h1><blockquote>
<p>&emsp;&emsp;软参考对象，由垃圾收集器根据内存需求自行清除。软引用通常用于实现内存敏感缓存。<br>假设垃圾收集器在某个时间点确定对象是softly reachable 。 那时候，它可能会选择原子地清除对该对象的所有软引用，以及对任何其他可轻松访问的对象的所有软引用，该对象可以通过一个强引用链来访问该对象。 在同一时间或稍后的时间，它将排入在引用队列中注册的新清除的软引用。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;在虚拟机抛出OutOfMemoryError之前，所有软引用对象可以保证被清除。 否则，在清除软引用的时间或者对一组对不同对象的引用将被清除的顺序没有约束。 但是，鼓励虚拟机实现偏离清除最近创建或最近使用的软参考。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;此类的直接实例可用于实现简单的缓存; 此类或派生子类也可用于较大的数据结构以实现更复杂的高速缓存。 只要软参考的指示是强有力的，即实际使用中，软参考将不会被清除。 因此，复杂的缓存可以例如阻止其最近使用的条目被丢弃，通过保持对这些条目的强烈的指示，使剩余的条目由垃圾收集器判断丢弃。</p>
</blockquote>
<p>&emsp;&emsp;用来描述一些有用但不是必须的对象，类似于生活总可有可无的物品，在java中使用<code>java.lang.ref.SoftReference</code>类来表示。<br>&emsp;&emsp;对于软引用关联着的对象，只有在内存空间不足的时候，垃圾回收器才会回收这些对象。<br>&emsp;&emsp;只要垃圾回收器没有回收掉，程序就可以使用它。<br>&emsp;&emsp;软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被JVM回收，这个软引用就会被加入到与之关联的引用队列中。<br>&emsp;&emsp;软引用可以用来实现内存敏感的高速缓存。当内存足够大时可以把数组存入软引用，取数据时就可从内存里取数据，提高运行效率。如浏览器的后退按钮。</p>
<hr>
<h1 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h1><blockquote>
<p>&emsp;&emsp;弱参考对象，不会阻止其指定对象的最终确定，最终确定，然后被回收。弱引用最常用于实现规范化映射。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;假设垃圾收集器在某个时间点确定对象是weakly reachable 。 那时，它将原子地清除对该对象的所有弱引用，以及所有弱引用到任何其他弱可触及的对象，通过一连串强软引用可以从该对象到达该对象。 同时，它将声明所有以前弱可触及的对象都是可以确定的。 在同一时间或稍后的时间，它将排列在引用队列中注册的新清除的弱引用。</p>
</blockquote>
<p>&emsp;&emsp;弱引用也是描述非必须对象的。与软引用相比，弱引用具有更短暂的生命周期，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象，在Java中用<code>java.lang.ref.WeakReference</code>来表示。<br>&emsp;&emsp;在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回 收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
<hr>
<h1 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h1><blockquote>
<p>&emsp;&emsp;在收集者确定其指示物可能被回收之后排入队列的Phantom参考对象。幻像引用最常用于以比Java完成机制可能更灵活的方式安排事先清理操作。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;如果垃圾收集器在某个时间点确定幻像引用的引用是phantom reachable ，那么在那个时间或稍后的时间，它将引入引用。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;为了确保可回收对象保持原样，可能无法检索幻像引用的引用：虚幻引用的get方法始终返回null 。</p>
</blockquote>
<blockquote>
<p>&emsp;&emsp;与软弱引用不同，幻像引用在垃圾收集器排入队列时不会自动清除。 通过幻影引用可访问的对象将一直保持到所有这样的引用被清除或者自身变得不可访问。</p>
</blockquote>
<p>&emsp;&emsp;虚引用主要用来跟踪对象被垃圾回收器回收的活动。<br>&emsp;&emsp;与软弱引用不同，虚引用不影响对象的生命周期，虚引用必须和引用队列 （ReferenceQueue）联合使用。<br>&emsp;&emsp;在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。<br>&emsp;&emsp;当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。由于Object.finalize()方法的不安全性、低效性，常常使用虚引用完成对象回收前的资源释放工作。</p>
<blockquote>
<p>&emsp;&emsp;当GC一但发现了虚引用对象，将会将PhantomReference对象插入ReferenceQueue队列. * 而此时PhantomReference所指向的对象并没有被GC回收，而是要等到ReferenceQueue被你真正的处理后才会被回收。</p>
</blockquote>
<p>&emsp;&emsp;当JVM将虚引用插入到引用队列的时候，虚引用执行的对象内存还是存在的。但是PhantomReference并没有暴露API返回对象。所以如果我想做清理工作，需要继承PhantomReference类，以便访问它指向的对象。如NIO直接内存的自动回收，就使用到了sun.misc.Cleaner。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table>
<thead>
<tr>
<th>引用类型</th>
<th>被回收时间</th>
<th>用途</th>
<th>生存时间</th>
</tr>
</thead>
<tbody><tr>
<td>强引用</td>
<td>从来不会</td>
<td>对象的一般状态</td>
<td>jvm停止运行时</td>
</tr>
<tr>
<td>软引用</td>
<td>内存不足时</td>
<td>对象缓存</td>
<td>内存不足时</td>
</tr>
<tr>
<td>弱引用</td>
<td>jvm垃圾回收时</td>
<td>对象缓存</td>
<td>gc后</td>
</tr>
<tr>
<td>虚引用</td>
<td>不知</td>
<td>不知</td>
<td>不知</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;利用软引用和弱引用可以解决OOM的问题。</p>
<p><strong>利用软引用和弱引用解决OOM问题：</strong> 假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。</p>
<p><strong>设计思路是：</strong> 用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>类加载机制</title>
    <url>/hexoblog/2021/03/02/md/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h1><h2 id="什么是类的加载？"><a href="#什么是类的加载？" class="headerlink" title="什么是类的加载？"></a>什么是类的加载？</h2><p>​&emsp;​&emsp;类的加载是指将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.class对象，用来封装类在方法区内的数据结构。<br>​​&emsp;​&emsp;类的加载的最终产品是位于堆区中的class对象，class对象封装了类在方法区内的数据结构，并且提供了访问方法区内的数据结构的接口。</p>
<span id="more"></span>

<h2 id="在什么时候启动类加载？"><a href="#在什么时候启动类加载？" class="headerlink" title="在什么时候启动类加载？"></a>在什么时候启动类加载？</h2><p>​​&emsp;​&emsp;类的加载并不需要某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被预先使用时就预先加载它，如果在预先加载过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误，如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。</p>
<h2 id="从哪个地方加载类？"><a href="#从哪个地方加载类？" class="headerlink" title="从哪个地方加载类？"></a>从哪个地方加载类？</h2><ol>
<li>从本地系统中直接加载。</li>
<li>通过网络下载.class文件。</li>
<li>从zip、jar等归档文件中加载.class文件。</li>
<li>从专有数据库中提取.class文件。</li>
<li>将java源代码编译为.class文件。</li>
</ol>
<hr>
<h1 id="类加载机制："><a href="#类加载机制：" class="headerlink" title="类加载机制："></a>类加载机制：</h1><p>​&emsp;​&emsp;加载主要是将.class文件（也可以是zip包）通过二进制流读入到jvm中，在加载阶段JVM需要完成3件事情。</p>
<h2 id="加载："><a href="#加载：" class="headerlink" title="加载："></a>加载：</h2><p>​&emsp;​&emsp;加载主要是将.class文件（也可以是zip包）通过二进制流读入到jvm中，在加载阶段JVM需要完成3件事情。</p>
<ol>
<li>通过classloader在classpath中获取XXX.class文件，将其以二进制流的方式读入内存。</li>
<li>将字节流代表的静态存储结构，转化为方法区的运行时存储结构。</li>
<li>在内存中生成一个该类的java.lang.class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h2 id="连接："><a href="#连接：" class="headerlink" title="连接："></a>连接：</h2><h3 id="验证："><a href="#验证：" class="headerlink" title="验证："></a>验证：</h3><p>​&emsp;​&emsp;主要是确保加载进来的字节流符合JVM规范，验证阶段会有4个检验动作：</p>
<ol>
<li>文件格式验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。这里主要被魔数、主版本号、常量池等等的校验。</li>
<li>元数据验证：验证是否符合java语言规范，主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合java语言规范的要求，比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。</li>
<li>字节码验证：确保程序语义合法，符合逻辑，是整个验证过程最复杂的阶段。主要是通过数据流和控制流分析，确保程序语义是合法的、符合逻辑。在元数据验证那个阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出危害虚拟机安全的事。</li>
<li>符号引用验证：确保下一步的解析能正常执行，它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。</li>
</ol>
<p>​&emsp;​&emsp;对整个类加载机制而言，验证阶段是一个很重要但是非必需的阶段，如果我们的代码能够确保没有问题，那么我们就没有必要去验证，毕竟验证需要花费一定的的时间。当然我们可以使用-Xverfity:none来关闭大部分的验证。</p>
<h3 id="准备："><a href="#准备：" class="headerlink" title="准备："></a>准备：</h3><p>​&emsp;​&emsp;准备是连接阶段的第二步，主要为静态变量在方法区分配内存，并设置默认初始值。</p>
<ol>
<li>类变量会分配内存，但是实例变量不会，实例变量主要随着对象的实例化一块分配到java堆中。</li>
<li>这里的初始值指的是数据类型默认值，而不是代码中被显式赋予的值，但是如果同时被static和final修饰准备阶段后就已经赋值了，普通赋值位于其他阶段。</li>
</ol>
<h3 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h3><p>​&emsp;​&emsp;解析是连接阶段的第三步，是虚拟机将常量池内的符合引用替换为直接引用的过程。</p>
<ol>
<li>符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好。</li>
<li>直接引用：直接引用可以是指向目标的指针、相对偏移量或者是一个能直接引用或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。</li>
</ol>
<p>​&emsp;​&emsp;解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h2><p>​​&emsp;​&emsp;这是类加载机制的最后一步，在这个阶段，java代码才开始真正执行。我们知道，在准备阶段已经为类变量赋过一次值，在初始化阶段，程序员可以根据自己的需求来赋值了。<br>​​&emsp;​&emsp;在初始化阶段，主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ol>
<li>声明变量是指定初始值。</li>
<li>使用静态代码块为类变量指定初始值。</li>
</ol>
<h3 id="JVM初始化步骤："><a href="#JVM初始化步骤：" class="headerlink" title="JVM初始化步骤："></a>JVM初始化步骤：</h3><ol>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类。</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类。</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句。</li>
</ol>
<h3 id="类的初始化时机："><a href="#类的初始化时机：" class="headerlink" title="类的初始化时机："></a>类的初始化时机：</h3><p>​&emsp;​&emsp;只有对类的主动使用时才会导致类的初始化，主动使用包括以下6种：</p>
<ol>
<li>创建类的实例，也就是new的时候。</li>
<li>访问某个类或接口的静态变量，或者对静态变量赋值。</li>
<li>调用类的静态方法。</li>
<li>反射操作。</li>
<li>初始化某个类，则其父类也会被初始化。</li>
<li>虚拟机启动时被标明为启动类的类，直接用java.exe来运行某个类。</li>
</ol>
<hr>
<h1 id="类加载器："><a href="#类加载器：" class="headerlink" title="类加载器："></a>类加载器：</h1><h2 id="自带类加载器："><a href="#自带类加载器：" class="headerlink" title="自带类加载器："></a>自带类加载器：</h2><p>java语言系统自带有3个类加载器：</p>
<ol>
<li>BootStrap ClassLoader：跟类（启动，引导）加载器。它负责加载java的核心类。他比较特殊，因为它是由原生c++代码实现的，并不是java.lang.ClassLoader的子类。</li>
<li>Extension ClassLoader：扩展类加载器。它负责加载jre的扩展目录（%JAVA_HOME%/jre/lib/ext）中的jar包的类，我们可以通过把自己开发的类打成jar包放入扩展目录来为java提供核心类以外的新功能。</li>
<li>System ClassLoader（Application ClassLoader）：系统类加载器。它负责再jvm启动时加载来自java命令的-classpath选项、java.class.path系统属性，或CLASSPATH环境变量所指定的jar包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader来获取系统类加载器。</li>
</ol>
<p>​​&emsp;​&emsp;应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为jvm自带的 ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果我们编写了自己的ClassLoader，便可以做到以下几点：</p>
<ol>
<li>在执行非置信代码前，自动验证数字签名。</li>
<li>动态的创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库和网络中。</li>
</ol>
<h2 id="自定义类加载器："><a href="#自定义类加载器：" class="headerlink" title="自定义类加载器："></a>自定义类加载器：</h2><p>​​&emsp;​&emsp;Custom ClassLoader：通过java.lang.ClassLoader的子类自定义加载class，属于应用程序根据自身需要定义的ClassLoader，如Tomcat，jboss都会根据j2ee规范自行实现ClassLoader。<br>​​&emsp;​&emsp;自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。有几点需要注意：</p>
<ol>
<li>这里传递的文件名是类的全限定名。</li>
<li>重写findClass而不重新loadClass，重新loadClass会破坏双亲委派模式。</li>
</ol>
<h2 id="类的三种加载方式："><a href="#类的三种加载方式：" class="headerlink" title="类的三种加载方式："></a>类的三种加载方式：</h2><ol>
<li>通过命令行启动应用时由jvm初始化加载含有main()方法的主类。</li>
<li>通过Class.forName()方法动态加载，会默认执行初始化块（static{}），但是Class.forName(name,initlize,loader)中的initlize可指定是否要执行初始化块。</li>
<li>通过ClassLoader.loadClass()方法动态加载，不会执行初始化块。</li>
</ol>
<h3 id="Class-forName-和ClassLoader-loadClass-的区别："><a href="#Class-forName-和ClassLoader-loadClass-的区别：" class="headerlink" title="Class.forName()和ClassLoader.loadClass()的区别："></a>Class.forName()和ClassLoader.loadClass()的区别：</h3><ol>
<li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ol>
<h2 id="JVM类加载机制："><a href="#JVM类加载机制：" class="headerlink" title="JVM类加载机制："></a>JVM类加载机制：</h2><ol>
<li>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</li>
<li>父类委托：先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</li>
<li>缓存机制：缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</li>
</ol>
<h2 id="双亲委派模型："><a href="#双亲委派模型：" class="headerlink" title="双亲委派模型："></a>双亲委派模型：</h2><ol>
<li>当AppClassLoader加载一个Class时，他首先不会自己去尝试加载这个类，而是把这个加载请求委托给父类加载器ExtClassLoader去完成。</li>
<li>当ExtClassLoader加载一个Class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。</li>
<li>如果BootStrapClassLoader加载失败（例如再$JAVSA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载。</li>
<li>若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</li>
</ol>
<h3 id="意义："><a href="#意义：" class="headerlink" title="意义："></a>意义：</h3><ol>
<li>系统类防止内存中出现多份的同样的字节码。</li>
<li>保证Java程序安全稳定运行。</li>
</ol>
<h2 id="结束生命周期："><a href="#结束生命周期：" class="headerlink" title="结束生命周期："></a>结束生命周期：</h2><p>在以下几种情况，Java虚拟机将结束生命周期：</p>
<ol>
<li>执行了System.exit()方法。</li>
<li>程序正常执行结束。</li>
<li>程序在执行过程中，遇到了异常或错误而异常终止。</li>
<li>由于操作系统出现错误，而导致Java虚拟机进程终止。</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>classloader</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin安装docker</title>
    <url>/hexoblog/2021/04/11/md/linux/deepin%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>&emsp;&emsp;写个毛啊，官方的直接搞来，<a href="https://wiki.deepin.org/wiki/Docker">https://wiki.deepin.org/wiki/Docke</a>。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1>]]></content>
      <categories>
        <category>deepin</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>tool</tag>
        <tag>linux</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>锁</title>
    <url>/hexoblog/2021/03/02/md/java/%E9%94%81/</url>
    <content><![CDATA[<h1 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h1><p>&emsp;&emsp;乐观锁不是数据库自带的，需要我们去实现。总是假设最好的情况，每次去拿数据时都会认为数据没有被修改，所以不会上锁，但是在提交更新的时候会去判断一下在此期间别人有没有更改数据，可以使用版本号机制算法或者CAS算法实现。乐观锁适用于读多于写的情况，可以提高吞吐量。</p>
<span id="more"></span>

<p>&emsp;&emsp;乐观锁：假设不会出现并发冲突，只在提交操作时检查是否违反数据完整性。</p>
<p>&emsp;&emsp;Java JUC中的atomic包就是乐观锁的一种实现，AtomicInteger 通过CAS（Compare And Set）操作实现线程安全的自增。</p>
<h2 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h2><ol>
<li>使用数据版本记录机制实现，这是乐观锁最常用的一种实现方式。为当前数据增加一个版本标识，一般是为数据库表增加一个数据类型的version字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新时，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行对比，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。</li>
<li>使用时间戳，乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。</li>
<li>CAS算法：即是compare and swap（比较与交换），是一种有名的无锁算法，无锁编程，在不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。CAS算法涉及到三个操作数：需要读写的内存值 V、进行比较的值 A、拟写入的新值 B。当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个自旋操作，即不断的重试。</li>
</ol>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><h3 id="ABA问题是一个乐观锁的常见问题："><a href="#ABA问题是一个乐观锁的常见问题：" class="headerlink" title="ABA问题是一个乐观锁的常见问题："></a>ABA问题是一个乐观锁的常见问题：</h3><p>&emsp;&emsp;如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</p>
<p>&emsp;&emsp;JDK 1.5 以后的 AtomicStampedReference 类就提供了此种能力，其中的 compareAndSet 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。</p>
<h3 id="循环时间长开销大："><a href="#循环时间长开销大：" class="headerlink" title="循环时间长开销大："></a>循环时间长开销大：</h3><p>&emsp;&emsp;自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。</p>
<h3 id="只能保证一个共享变量的原子操作："><a href="#只能保证一个共享变量的原子操作：" class="headerlink" title="只能保证一个共享变量的原子操作："></a>只能保证一个共享变量的原子操作：</h3><p>&emsp;&emsp;CAS只对单个共享变量有效，当操作涉及跨多个共享变量时CAS无效。但是从JDK 1.5开始，提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作.所以我们可以使用锁或者利用AtomicReference类把多个共享变量合并成一个共享变量来操作。</p>
<h1 id="悲观锁："><a href="#悲观锁：" class="headerlink" title="悲观锁："></a>悲观锁：</h1><p>&emsp;&emsp;总是假设最坏的情况，每次去拿数据时都认为别人会修改，所以每次在拿数据时都会上锁，这样别人想拿数据就会阻塞直到他拿到锁。共享资源每次只给一个线程使用，其他线程阻塞，用完后再把资源转让给其他线程。传统的关系型数据库里面就用到了很多这种锁机制，行锁，表锁，读锁，写锁等，都是在操作之前先上锁。</p>
<p>&emsp;&emsp;悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。</p>
<p>&emsp;&emsp;Java synchronized和ReentrantLock就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被block。</p>
<h2 id="区别与场景："><a href="#区别与场景：" class="headerlink" title="区别与场景："></a>区别与场景：</h2><h3 id="区别："><a href="#区别：" class="headerlink" title="区别："></a>区别：</h3><p>&emsp;&emsp;乐观锁的思路一般是表中增加版本字段，更新时where语句中增加版本的判断，算是一种CAS（Compare And Swep）操作，商品库存场景中number起到了版本控制（相当于version）的作用（ AND number=#{number}）。</p>
<p>&emsp;&emsp;悲观锁之所以是悲观，在于他认为本次操作会发生并发冲突，所以一开始就对商品加上锁（SELECT … FOR UPDATE），然后就可以安心的做判断和更新，因为这时候不会有别人更新这条商品库存。</p>
<h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>&emsp;&emsp;乐观锁适用于读多于写的情况，即冲突很少的情况，可以省去很大加锁的开销。多写的情况，冲突会比较多，不适合上面的场景，因为冲突的数据会导致应用不断的retry，一般多写的场景适合适用悲观锁。</p>
<h3 id="CAS与synchronized："><a href="#CAS与synchronized：" class="headerlink" title="CAS与synchronized："></a>CAS与synchronized：</h3><ol>
<li>对于资源竞争较少（线程冲突较轻）的情况，使用synchronized同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗cpu资源；而CAS基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li>
<li>对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</li>
<li>补充：Java并发编程这个领域中synchronized关键字一直都是元老级的角色，很久之前很多人都会称它为 “重量级锁” 。但是，在JavaSE 1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 偏向锁 和 轻量级锁 以及其它各种优化之后变得在某些情况下并不是那么重了。</li>
<li>synchronized的底层实现主要依靠 Lock-Free 的队列，基本思路是 自旋后阻塞，竞争切换后继续竞争锁，稍微牺牲了公平性，但获得了高吞吐量。在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS。</li>
</ol>
<h3 id="MySQL隐式和显示锁定："><a href="#MySQL隐式和显示锁定：" class="headerlink" title="MySQL隐式和显示锁定："></a>MySQL隐式和显示锁定：</h3><p>&emsp;&emsp;MySQL InnoDB采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB会根据事务隔离级别在需要的时候自动加锁。</p>
<p>&emsp;&emsp;另外，InnoDB也支持通过特定的语句进行显示锁定，这些语句不属于SQL规范：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">SELECT</span></span> ... LOCK IN SHARE MODE</span><br><span class="line"><span class="function"><span class="title">SELECT</span></span> ... <span class="keyword">FOR</span> UPDATE</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="共享锁："><a href="#共享锁：" class="headerlink" title="共享锁："></a>共享锁：</h1><p>&emsp;&emsp;共享锁（S锁），又称读锁，用于不更改或不更新数据的操作。</p>
<p>&emsp;&emsp;若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p>
<h1 id="排它锁："><a href="#排它锁：" class="headerlink" title="排它锁："></a>排它锁：</h1><p>&emsp;&emsp;排它锁（X锁），又称写锁，用于数据修改，确保不会同时同一资源进行多重更新。</p>
<p>&emsp;&emsp;若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p>
<h2 id="解决死锁："><a href="#解决死锁：" class="headerlink" title="解决死锁："></a>解决死锁：</h2><p>共享锁与排它锁会导致死锁问题。</p>
<p>预防死锁发生：</p>
<ol>
<li> 要求每一个事务必须一次封锁所要使用的全部数据（要么全成功，要么全不成功）。</li>
<li> 规定封锁数据的顺序，所有事务必须按这个顺序实行封锁。</li>
</ol>
<p>&emsp;&emsp;允许死锁发生，然后解除它，如果发现死锁，则将其中一个代价较小的事物撤消，回滚这个事务，并释放此事务持有的封锁，使其他事务继续运行。</p>
<hr>
<h1 id="更新锁："><a href="#更新锁：" class="headerlink" title="更新锁："></a>更新锁：</h1><p>&emsp;&emsp;更新锁用于防止常见形式的死锁，比如共享锁和排他锁产生的死锁问题。</p>
<p>&emsp;&emsp;更新锁（U锁）并不能保证不会产生死锁，只是针对共享锁和排他锁提出了一种较为简单的解决方式。共享锁解决死锁，实际上是阻碍了事务T1和T2的并发执行。</p>
<ol>
<li>S锁只能读取数据，不能升级成X锁。</li>
<li>U锁给予事务T读取属性A的权限，没有写的权限，但是可以升级成X锁。</li>
<li>属性A上面有共享锁，可以添加U锁；但是有U锁，不能添加任何锁。</li>
</ol>
<table>
<thead>
<tr>
<th>—</th>
<th>S</th>
<th>X</th>
<th>U</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td>X</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>U</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<h1 id="增量锁："><a href="#增量锁：" class="headerlink" title="增量锁："></a>增量锁：</h1><p>&emsp;&emsp;对于一部分数据库，对数据库的操作仅仅只涉及加与减操作。这样针对这种情况，我们引入增量锁。</p>
<p>&emsp;&emsp;只有在事务获取了增量锁的前提下，才能够进行增量操作。</p>
<table>
<thead>
<tr>
<th>—</th>
<th>S</th>
<th>X</th>
<th>I</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>YES</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>X</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>I</td>
<td>NO</td>
<td>NO</td>
<td>YES</td>
</tr>
</tbody></table>
<hr>
<h1 id="行锁："><a href="#行锁：" class="headerlink" title="行锁："></a>行锁：</h1><p>&emsp;&emsp;顾名思义，行锁就是一锁锁一行或者多行记录，mysql的行锁是基于索引加载的，所以行锁是要加在索引响应的行上，即命中索引。否则自动扫描全表，走表锁。</p>
<p>&emsp;&emsp;行锁的特征：锁冲突概率低，并发性高，但是会有死锁的情况出现。</p>
<ol>
<li> 行锁必须有索引才能实现，否则会自动锁全表，那么就不是行锁了。</li>
<li> 两个事务不能锁同一个索引。</li>
<li> insert ，delete ， update在事务中都会自动默认加上排它锁。</li>
</ol>
<p>&emsp;&emsp;当选中某一行时，如果是通过主键或者索引选中的，这个时候是行级锁；如果是通过其它条件选中的，这个时候行级锁会升级成表锁，其它事务无法对当前表进行更新或插入操作。</p>
<h1 id="表锁："><a href="#表锁：" class="headerlink" title="表锁："></a>表锁：</h1><p>&emsp;&emsp;顾名思义，表锁就是一锁锁一整张表，在表被锁定期间，其他事务不能对该表进行操作，必须等当前表的锁被释放后才能进行操作。表锁响应的是非索引字段，即全表扫描，全表扫描时锁定整张表。</p>
<h2 id="区别与场景：-1"><a href="#区别与场景：-1" class="headerlink" title="区别与场景："></a>区别与场景：</h2><h3 id="区别：-1"><a href="#区别：-1" class="headerlink" title="区别："></a>区别：</h3><p>表锁：不会出现死锁，发生锁冲突几率高，并发低。</p>
<p>行锁：会出现死锁，发生锁冲突几率低，并发高。开销大，加锁慢，锁定粒度小。</p>
<p>&emsp;&emsp;锁冲突：例如说事务A将某几行上锁后，事务B又对其上锁，锁不能共存否则会出现锁冲突。（但是共享锁可以共存，共享锁和排它锁不能共存，排它锁和排他锁也不可以）。</p>
<p>&emsp;&emsp;死锁：例如说两个事务，事务A锁住了1-5行，同时事务B锁住了6-10行，此时事务A请求锁住6-10行，就会阻塞直到事务B施放6-10行的锁，而随后事务B又请求锁住1-5行，事务B也阻塞直到事务A释放1-5行的锁。死锁发生时，会产生Deadlock错误。</p>
<h2 id="记录锁："><a href="#记录锁：" class="headerlink" title="记录锁："></a>记录锁：</h2><p>&emsp;&emsp;记录锁是在行锁上衍生的锁。</p>
<p>&emsp;&emsp;记录锁：记录锁锁的是表中的某一条记录，记录锁的出现条件必须是精准命中索引并且索引是唯一索引。</p>
<h2 id="间隙锁："><a href="#间隙锁：" class="headerlink" title="间隙锁："></a>间隙锁：</h2><p>&emsp;&emsp;间隙锁又称之为区间锁，每次锁定都是锁定一个区间，隶属行锁。既然间隙锁隶属行锁，那么，间隙锁的触发条件必然是命中索引的，当我们查询数据用范围查询而不是相等条件查询时，查询条件命中索引，并且没有查询到符合条件的记录，此时就会将查询条件中的范围数据进行锁定(即使是范围库中不存在的数据也会被锁定)。</p>
<p>&emsp;&emsp;间隙锁只会出现在可重复读的事务隔离级别中，mysql5.7默认就是可重复读。间隙锁锁的是一个区间范围，查询命中索引但是没有匹配到相关记录时，锁定的是查询的这个区间范围。</p>
<h2 id="临间锁："><a href="#临间锁：" class="headerlink" title="临间锁："></a>临间锁：</h2><p>&emsp;&emsp;学习完间隙锁后我们再来看看什么是临间锁，mysql的行锁默认就是使用的临间锁，临间锁是由记录锁和间隙锁共同实现的，上面我们学习间隙锁时，间隙锁的触发条件是命中索引，范围查询没有匹配到相关记录。而临键锁恰好相反，临间锁的触发条件也是查询条件命中索引，不过，临间锁有匹配到数据库记录。</p>
<p>&emsp;&emsp;间隙锁所锁定的区间是一个左开右闭的集合，而临间锁锁定是当前记录的区间和下一个记录的区间。</p>
<p>&emsp;&emsp;临间锁锁定区间和查询范围后匹配值很重要，如果后匹配值存在，则只锁定查询区间，否则锁定查询区间和后匹配值与它的下一个值的区间。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title>deepin搭建java开发环境</title>
    <url>/hexoblog/2021/04/11/md/linux/deepin%E6%90%AD%E5%BB%BAjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="安装jdk"><a href="#安装jdk" class="headerlink" title="安装jdk"></a>安装jdk</h1><p>&emsp;&emsp;安装之前最好先获取管理员权限。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取后需要输入密码</span></span><br><span class="line">sudo su</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="下载jdk"><a href="#下载jdk" class="headerlink" title="下载jdk"></a>下载jdk</h2><p>&emsp;&emsp;进入指定目录，下载jdk文件，我自己通常喜欢下载在<code>/usr/local/src/jdk</code>目录中，<a href="https://www.oracle.com/java/technologies/javase-jdk16-downloads.html">jdk16</a>。<br>&emsp;&emsp;<code>/usr/bin</code>是系统的软件存放的位置。<br>&emsp;&emsp;<code>/usr/local/bin</code>是我们自己的软件存放的位置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/jdk</span><br><span class="line"></span><br><span class="line">wget https://download.oracle.com/otn-pub/java/jdk/16+36/7863447f0ab643c585b9bdebf67c69db/jdk-16_linux-x64_bin.tar.gz?AuthParam=1618140718_ccecc5f8b3763f1feed74a49a7f7cbb8</span><br></pre></td></tr></table></figure>

<h2 id="将下载的jdk解压缩"><a href="#将下载的jdk解压缩" class="headerlink" title="将下载的jdk解压缩"></a>将下载的jdk解压缩</h2><p>&emsp;&emsp;通过wget下载的压缩包文件名称会奇奇怪怪的。如果通过浏览器下载则没有该问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line">mv <span class="string">&#x27;jdk-16_linux-x64_bin.tar.gz?AuthParam=1618140718_ccecc5f8b3763f1feed74a49a7f7cbb8&#x27;</span> jdk-16_linux-x64_bin.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar xvf jdk-16_linux-x64_bin.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="重命名文件夹（可选）"><a href="#重命名文件夹（可选）" class="headerlink" title="重命名文件夹（可选）"></a>重命名文件夹（可选）</h2><p>&emsp;&emsp;对解压后的文件夹重命名，也可以不做。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv jdk-16_linux-x64_bin jdk16</span><br></pre></td></tr></table></figure>

<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>&emsp;&emsp;jdk需要配置PATH和CLASSPATH环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 系统的环境变量写在/etc/profile文件中</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在编辑器末尾添加对应的环境变量</span></span><br><span class="line"><span class="comment"># 这里的路径结合自己的实际安装路径</span></span><br><span class="line">JAVA_HOME=/usr/<span class="built_in">local</span>/jdk/jdk16</span><br><span class="line">CLASSPATH=<span class="variable">$JAVA_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> CLASSPATH</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:&amp;JAVA_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出vi并保存，这里需要强制保存</span></span><br><span class="line">esc</span><br><span class="line">:wq!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证，查看版本号</span></span><br><span class="line">java -version</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="安装maven"><a href="#安装maven" class="headerlink" title="安装maven"></a>安装maven</h1><h2 id="下载maven"><a href="#下载maven" class="headerlink" title="下载maven"></a>下载maven</h2><p>&emsp;&emsp;将maven下载进指定目录，这里依照个人习惯，我放在<code>/usr/local/src/maven</code>。<a href="https://mirrors.bfsu.edu.cn/apache/maven/maven-3/3.8.1/binaries/apache-maven-3.8.1-bin.tar.gz">maven3.8.1</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/maven</span><br><span class="line"></span><br><span class="line">wget https://mirrors.bfsu.edu.cn/apache/maven/maven-3/3.8.1/binaries/apache-maven-3.8.1-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="解压缩文件"><a href="#解压缩文件" class="headerlink" title="解压缩文件"></a>解压缩文件</h2><p>&emsp;&emsp;对下载的maven文件解压缩。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvf apache-maven-3.8.1-bin.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="重命名文件夹"><a href="#重命名文件夹" class="headerlink" title="重命名文件夹"></a>重命名文件夹</h2><p>&emsp;&emsp;这一步可选操作，目的是为了文件目录整洁。也可以不做。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv apache-maven-3.8.1-bin maven3</span><br></pre></td></tr></table></figure>

<h2 id="配置环境变量-1"><a href="#配置环境变量-1" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>&emsp;&emsp;maven也需要配置PATH环境变量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在编辑器末尾添加对应的环境变量</span></span><br><span class="line"><span class="comment"># 这里的路径结合自己的实际安装路径</span></span><br><span class="line">MAVEN_HOME=/usr/<span class="built_in">local</span>/maven/maven3</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:&amp;MAVEN_HOME/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出vi并保存，这里需要强制保存</span></span><br><span class="line">esc</span><br><span class="line">:wq!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新使环境变量生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证，查看版本号</span></span><br><span class="line">mvn -v</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h1><h2 id="下载tomcat"><a href="#下载tomcat" class="headerlink" title="下载tomcat"></a>下载tomcat</h2><p>&emsp;&emsp;将tomcat下载进指定的位置，我放在<code>/usr/local/src/tomcat</code>。<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-10/v10.0.5/bin/apache-tomcat-10.0.5.tar.gz">tomcat10</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/tomcat</span><br><span class="line"></span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-10/v10.0.5/bin/apache-tomcat-10.0.5.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="解压压缩包"><a href="#解压压缩包" class="headerlink" title="解压压缩包"></a>解压压缩包</h2><p>&emsp;&emsp;解压下载的压缩文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xvf apache-tomcat-10.0.5.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="重命名文件夹-1"><a href="#重命名文件夹-1" class="headerlink" title="重命名文件夹"></a>重命名文件夹</h2><p>&emsp;&emsp;这一步可选操作，目的是为了文件目录整洁。也可以不做。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv apache-tomcat-10.0.5 tomcat10</span><br></pre></td></tr></table></figure>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>&emsp;&emsp;进入tomcat的安装目录就可以启动tomcat了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入tomcat的安装位置</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/tomcat/tomcat10/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动tomcat</span></span><br><span class="line">startup.sh</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;启动完成后可以在localhost:8080查看是否启动成功。</p>
]]></content>
      <categories>
        <category>deepin</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>linux</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>linux基本操作</title>
    <url>/hexoblog/2021/04/10/md/linux/linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="移动文件-重命名文件"><a href="#移动文件-重命名文件" class="headerlink" title="移动文件/重命名文件"></a>移动文件/重命名文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line">mv [源文件目录] [目标文件目录]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line"><span class="built_in">cd</span> [目标目录]</span><br><span class="line">mv [源文件名] [目标文件名]</span><br></pre></td></tr></table></figure>

<h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp [源文件目录/源文件名] [目标文件目录]</span><br></pre></td></tr></table></figure>

<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> [目标文件目录]</span><br><span class="line">rm -rf [目标文件名]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl小问题排查</title>
    <url>/hexoblog/2021/03/14/md/linux/wsl%E5%B0%8F%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<!-- toc -->

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h2><h3 id="参考的对象类型不支持尝试的操作"><a href="#参考的对象类型不支持尝试的操作" class="headerlink" title="参考的对象类型不支持尝试的操作"></a>参考的对象类型不支持尝试的操作</h3><p>&emsp;&emsp;这种问题一般是因为有启动过代理软件，造成代理冲突。</p>
<span id="more"></span>

<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/Ubuntu%2020.04%20LTS%202021_3_14%2016_01_57.png" alt="参考的对象不支持的操作"></p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>&emsp;&emsp;临时解决方案，重新网络信息：（管理员运行命令行）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重置网络信息</span></span><br><span class="line">netsh winsock reset</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>wsl</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>happens-before</title>
    <url>/hexoblog/2021/03/03/md/jvm/happens-before/</url>
    <content><![CDATA[<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>&emsp;&emsp;在JMM中，由于存在线程本地内存和主内存的原因，再加上重排序，会导致多线程环境下存在可见性的问题。<br>&emsp;&emsp;JDK5开始，JMM使用happens-before概念来阐述多线程之间的内存可见性问题。</p>
<blockquote>
<p>&emsp;&emsp;在JMM中，如果一个操作的执行结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。  </p>
</blockquote>
<p>&emsp;&emsp;happens-before原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个规则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。</p>
<span id="more"></span>

<hr>
<h1 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h1><h2 id="happens-before原则定义："><a href="#happens-before原则定义：" class="headerlink" title="happens-before原则定义："></a>happens-before原则定义：</h2><ol>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序在第二个操作之前。</li>
<li>两个操作之间存在happens-before原则，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li>
</ol>
<h2 id="happens-before原则规则："><a href="#happens-before原则规则：" class="headerlink" title="happens-before原则规则："></a>happens-before原则规则：</h2><ol>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作；</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；</li>
</ol>
<h3 id="程序次序规则："><a href="#程序次序规则：" class="headerlink" title="程序次序规则："></a>程序次序规则：</h3><p>&emsp;&emsp;一段代码在单线程中的执行结果是有序的，注意是执行结果，因为虚拟机、处理器会对指令进行重排序（重排序后面会详细介绍）。虽然重排序了，但是并不会影响程序的执行结果，所以程序最终执行的结果与顺序执行的结果是一致的。故而这个规则只对单线程有效，在多线程环境下无法保证正确性。</p>
<h3 id="锁定规则："><a href="#锁定规则：" class="headerlink" title="锁定规则："></a>锁定规则：</h3><p>&emsp;&emsp;这个规则比较好理解，无论是在单线程环境还是多线程环境，一个锁处于被锁定状态，那么必须先执行unlock操作后面才能进行lock操作。</p>
<h3 id="volatile变量规则："><a href="#volatile变量规则：" class="headerlink" title="volatile变量规则："></a>volatile变量规则：</h3><p>&emsp;&emsp; 这是一条比较重要的规则，它标志着volatile保证了线程可见性。通俗点讲就是如果一个线程先去写一个volatile变量，然后一个线程去读这个变量，那么这个写操作一定是happens-before读操作的。</p>
<h3 id="传递规则："><a href="#传递规则：" class="headerlink" title="传递规则："></a>传递规则：</h3><p>&emsp;&emsp;提现了happens-before原则具有传递性，即A happens-before B , B happens-before C，那么A happens-before C。</p>
<h3 id="线程启动规则："><a href="#线程启动规则：" class="headerlink" title="线程启动规则："></a>线程启动规则：</h3><p>&emsp;&emsp;假定线程A在执行过程中，通过执行ThreadB.start()来启动线程B，那么线程A对共享变量的修改在接下来线程B开始执行后确保对线程B可见。</p>
<h3 id="线程终结规则："><a href="#线程终结规则：" class="headerlink" title="线程终结规则："></a>线程终结规则：</h3><p>&emsp;&emsp;假定线程A在执行的过程中，通过制定ThreadB.join()等待线程B终止，那么线程B在终止之前对共享变量的修改在线程A等待返回后可见。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;上面八条是原生Java满足Happens-before关系的规则，但是我们可以对他们进行推导出其他满足happens-before的规则：</p>
<ol>
<li>将一个元素放入一个线程安全的队列的操作Happens-Before从队列中取出这个元素的操作。</li>
<li>将一个元素放入一个线程安全容器的操作Happens-Before从容器中取出这个元素的操作。</li>
<li>在CountDownLatch上的倒数操作Happens-Before CountDownLatch#await()操作。</li>
<li>释放Semaphore许可的操作Happens-Before获得许可操作。</li>
<li>Future表示的任务的所有操作Happens-Before Future#get()操作。</li>
<li>向Executor提交一个Runnable或Callable的操作Happens-Before任务开始执行操作。</li>
<li>如果两个操作不满足上述任意一个happens-before规则，那么这两个操作就没有顺序的保障，JVM就可以对这两个操作进行重排序。如果操作Ahappens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的。</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Volatile</title>
    <url>/hexoblog/2021/03/03/md/jvm/Volatile/</url>
    <content><![CDATA[<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p>&emsp;&emsp;Java内存模型，是虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层计算机之间的区别。<br>&emsp;&emsp;Java内存模型描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量，存储到内存和从内存中读取变量这样的底层细节。</p>
<span id="more"></span>

<h2 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h2><p>&emsp;&emsp;所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，不存在竞争问题。<br>&emsp;&emsp;线程对所有变量的操作都必须在工作内存中完成，而不能直接操作主内存中的变量。<br>&emsp;&emsp;不同的线程也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p>
<hr>
<h1 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a>可见性问题</h1><h2 id="通过加synchronized来解决可见性问题："><a href="#通过加synchronized来解决可见性问题：" class="headerlink" title="通过加synchronized来解决可见性问题："></a>通过加synchronized来解决可见性问题：</h2><p>&emsp;&emsp;因为某一个线程进入synchronized代码块前后，线程会获得锁，清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码，将修改后的副本的值刷新回主内存中，线程释放锁。<br>&emsp;&emsp;而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。</p>
<h2 id="通过volatile解决可见性问题："><a href="#通过volatile解决可见性问题：" class="headerlink" title="通过volatile解决可见性问题："></a>通过volatile解决可见性问题：</h2><p>&emsp;&emsp;每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写回了，其他已经读取的线程的变量副本就会失效了，需要对数据进行操作又要再次去主内存中读取了。</p>
<hr>
<h1 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h1><h2 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h2><p>&emsp;&emsp;多个处理器的运算任务涉及同一块主内存区域时，将导致各自的缓存数据不一致，问题在于同步回主内存时以谁的缓存数据为准。<br>&emsp;&emsp;为了解决一致性的问题，需要各个处理器在访问缓存时都遵循一些协议，在读写时要根据协议操作，这类协议有MSI，MESI，Synapse，Firefly，Firefly等。</p>
<h2 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h2><p>&emsp;&emsp;当cpu写数据时，如果发现操作的变量是工作内存，即在其他cpu中也存在该变量的副本，会发出信号通知其他cpu将该变量的缓存行设置为无效状态，因此当其他cpu要读取这个变量时，会发现自己缓存中缓存该变量的缓存行是无效的，那么他就会从内存重新读取。</p>
<h2 id="嗅探："><a href="#嗅探：" class="headerlink" title="嗅探："></a>嗅探：</h2><p>&emsp;&emsp;每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作时，会重新从系统内存中把数据读到处理器缓存里。</p>
<h2 id="总线风暴："><a href="#总线风暴：" class="headerlink" title="总线风暴："></a>总线风暴：</h2><p>&emsp;&emsp;由于volatile的MESI缓存一致性协议，需要不断的从主内存嗅探和CAS不断循环，无效交互会导致总线带宽达到峰值。所以不应该大量使用volatile，什么时候使用volatile什么时候使用锁，需要具体判断。</p>
<hr>
<h1 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h1><p>&emsp;&emsp;为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。</p>
<h2 id="过程"><a href="#过程" class="headerlink" title="过程:"></a>过程:</h2><blockquote>
<p> 源代码——&gt;编译器优化重排序——&gt;指令级并行重排序——&gt;内存系统重排序——〉最终执行指令序列</p>
</blockquote>
<p>&emsp;&emsp;一个好的内存模型，实际上会放松对处理器和编译器规则的束缚，也就是说软件技术和硬件技术都为同一个目标，而进行奋斗。在不改变程序执行结果的前提下，尽可能提高运行效率。<br>&emsp;&emsp;JMM对底层减少约束，使其能够发挥自身优势。</p>
<h2 id="三种重排序"><a href="#三种重排序" class="headerlink" title="三种重排序"></a>三种重排序</h2><ol>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来讲多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得读取和存储操作看上去可能是在乱序执行的。</li>
</ol>
<h2 id="as-if-serial："><a href="#as-if-serial：" class="headerlink" title="as-if-serial："></a>as-if-serial：</h2><p>&emsp;&emsp;不管怎么重排序，单线程下的执行结果不能被改变。<br>&emsp;&emsp;编译器、runtime和处理器都必须遵守as-if-serial语义。</p>
<h2 id="内存屏障："><a href="#内存屏障：" class="headerlink" title="内存屏障："></a>内存屏障：</h2><p>&emsp;&emsp;java编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。<br>&emsp;&emsp;为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：</p>
<table>
<thead>
<tr>
<th>是否能重排序</th>
<th>第二个操作</th>
<th>普通读写</th>
<th>vol读</th>
<th>vol写</th>
</tr>
</thead>
<tbody><tr>
<td>第一个操作</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>普通读写</td>
<td></td>
<td></td>
<td></td>
<td>NO</td>
</tr>
<tr>
<td>vol读</td>
<td></td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>vol写</td>
<td></td>
<td></td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody></table>
<p>需要注意的是：</p>
<ol>
<li>volatile写是分别在前面和后面插入内存屏障.</li>
<li>而volatile读是在后面插入两个内存屏障。</li>
</ol>
<h3 id="写内存屏障："><a href="#写内存屏障：" class="headerlink" title="写内存屏障："></a>写内存屏障：</h3><blockquote>
<p>普通读——&gt;普通写——&gt;storestore屏障(禁止上面写和其他重排序)——&gt;vol写——&gt;storestore屏障(禁止下面读和其他重排序)</p>
</blockquote>
<h3 id="读内存屏障："><a href="#读内存屏障：" class="headerlink" title="读内存屏障："></a>读内存屏障：</h3><blockquote>
<p>vol读——&gt;loadload屏障(禁止下面读重排序)——&gt;loadload屏障(禁止下面写重排序)——&gt;普通读——&gt;普通写</p>
</blockquote>
<p>&emsp;&emsp;为了提高处理速度，JVM会对代码进行编译优化，也就是指令重排序优化，并发编程下指令重排序会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。<br>&emsp;&emsp;从JDK5开始，提出了happens-before的概念，通过这个概念来阐述操作之间的内存可见性。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before:"></a>happens-before:</h3><p>&emsp;&emsp;<a href="">happens-before</a><br>&emsp;&emsp;如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。<br>&emsp;&emsp;volatile域规则：对一个volatile的写操作，happens-before于任意线程后续对这volatile域的读。</p>
<h3 id="volatile无法保证原子性："><a href="#volatile无法保证原子性：" class="headerlink" title="volatile无法保证原子性："></a>volatile无法保证原子性：</h3><p>&emsp;&emsp;假设现在有N个线程对同一个变量进累加也是没办法保证结果是对的，因为读写这个过并不是原子性的。<br>&emsp;&emsp;要解决也简单，要么用原子类，比AtomicInteger，要么加锁(记得关注Atomic的底层。</p>
<h3 id="volatile与synchronized的区别："><a href="#volatile与synchronized的区别：" class="headerlink" title="volatile与synchronized的区别："></a>volatile与synchronized的区别：</h3><p>&emsp;&emsp;volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。<br>&emsp;&emsp;volatile保证数据的可见性，但是保证原子性(多线程进行写操作，不保证线程安全)而synchronized是一种排他(互斥)的机制。  &amp;emsp&emsp;volatile用于禁止指令重排序：可以解决例双重检查对象初始化代码执行乱序问题。<br>&emsp;&emsp;volatile可以看做是轻量版synchronized，volatile不保证原子性，但是如是对一个共享变量进行多个线程的赋值，     而有其他的操作，那么就可以用volatile来代synchronized，因为赋值本身是有原子性的，volatile又保证了可见性，所以就可以保证线程安了。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>volatile修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值，比如boolean flag;或者作为触发器，实现轻量级同步。</li>
<li>volatile属性的读写操作都是无锁的，它不能替代synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁_上，所以说它是低成本的。</li>
<li>volatile只能作用于属性，我们用volatile修饰属性，这样compilers就不会对这个属性做指令重排序。</li>
<li>volatile提供了可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主存中读取。</li>
<li>volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作。</li>
<li>volatile可以使得long和double的赋值是原子的。</li>
<li>volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存分配策略</title>
    <url>/hexoblog/2021/04/27/md/jvm/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;就是java对象在堆上分配空间的策略。<br>&emsp;&emsp;具体的分配策略取决于使用那种垃圾回收器的组合，还有虚拟机中参数的设置。这里的一般是分代收集算法下的情况。</p>
<span id="more"></span>

<hr>
<h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%A0%86%E5%86%85%E5%AD%98%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.jpg" alt="堆内存垃圾回收"></p>
<p>&emsp;&emsp;这里的内存结构说的是虚拟机对jvm规范中堆区域的实现，不同的虚拟机可能稍有不同。<br>&emsp;&emsp;根据分代回收算法，将堆分为新生代、老年代。新生代默认占堆空间的1/3，老年代默认占堆空间的2/3。<br>&emsp;&emsp;新生代使用复制算法，有3个区，Eden、To Survivor、From Survivor，它们的默认占比是8:1:1，它的执行流程如下：</p>
<blockquote>
<p>&emsp;&emsp;设置Survivore区可以防止频繁触发FULL GC。如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代，这样会使老年代很快被填满，导致老年代触发FULL GC，由于老年代的内存空间远大于新生代，所以进行一次Full GC消耗的时间比Minor GC长得多。<br>&emsp;&emsp;两个Survivor防止产生内存空间碎片。如果只有Survivor1，那么每一次当Eden区满时，触发Minor GC并把对象移入Survivor1中，如此循环对导致Survivor1中产生大量的空间碎片；所以需要有Survivor2，当Eden再一次满时，触发Minor GC，虚拟机会把 Eden中和Survivor1中的存活对象通过复制算法移入Survivor2中，这样Survivor2就不会产生内存碎片，同时Eden和Survivor1会清理内存，保证下一次Minor GC触发时的操作。</p>
</blockquote>
<ol>
<li>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To Survivor区”，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中。</li>
<li>清空Eden和From Survivor分区。</li>
<li>这时From Survivor和To Survivor分区会互换角色，分区交换，From Survivor变To Survivor，To Survivor变From Survivor。</li>
<li>每次在From Survivor到To Survivor移动时都存活的对象，年龄就+1，当年龄到达15（默认配置是 15）时，升级为老生代。大对象也会直接进入老生代。</li>
</ol>
<p>&emsp;&emsp;老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p>
<hr>
<h1 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h1><p>&emsp;&emsp;常见的内存分配策略为：</p>
<ol>
<li><p>对象优先在Eden分配。</p>
</li>
<li><p>大对象直接进入老年代。</p>
</li>
<li><p>长期存活的对象进入老年代。</p>
</li>
<li><p>动态对象年龄判断。</p>
</li>
<li><p>空间分配担保。</p>
<h2 id="对象优先在Eden区"><a href="#对象优先在Eden区" class="headerlink" title="对象优先在Eden区"></a>对象优先在Eden区</h2></li>
</ol>
<p>&emsp;&emsp;多数情况下，新对象都在新生代Eden区分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，即发生在新生代的垃圾收集。<br>&emsp;&emsp;如果分配后还是没有足够的空间，就会启动分配担保机制在老年代分配空间。</p>
<h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><p>&emsp;&emsp;所谓大对象就是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。可以通过虚拟机参数<code>-XX:PretenureSizeThreshold</code>控制大对象的最小临界值。<br>&emsp;&emsp;新生代使用的是复制算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致Eden区和两个Survivor区之间发生大量的内存复制。<br>&emsp;&emsp;经常出现大对象，会导致在内存还有不少时就触发垃圾回收。</p>
<ul>
<li><strong>Minor GC</strong>：指发生在新生代的GC，一般速度非常快。</li>
<li><strong>Full GC</strong>：是指发生在老年代的GC，一般出现这种必然会伴随Minor GC，通常会被Minor GC慢10倍。</li>
</ul>
<h2 id="长期存活的对象进入老年代"><a href="#长期存活的对象进入老年代" class="headerlink" title="长期存活的对象进入老年代"></a>长期存活的对象进入老年代</h2><p>&emsp;&emsp;在分代收集算法中需要确定那些对象该进入老年代，那些不用进入。<br>&emsp;&emsp;虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden区出生，并且能够被Survivor容纳，将被移动到Survivor空间中，这时设置对象年龄为1。对象在Survivor区中每过一次Minor GC年龄就加 1，当年龄达到一定程度（默认 15）就会被晋升到老年代。可以通过参数<code>-XX:MaxTenuringThreshold</code>设置进入老年代的年龄上限。</p>
<h2 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h2><p>&emsp;&emsp;虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。</p>
<h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>&emsp;&emsp;在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，这这时也要改为进行一次Full GC（指发生在老年代的GC，会发生STW）。实际上，在 JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则就进行Full GC。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm中方法区_永久代_元空间</title>
    <url>/hexoblog/2021/04/25/md/jvm/jvm%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA-%E6%B0%B8%E4%B9%85%E4%BB%A3-%E5%85%83%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h1><p>&emsp;&emsp;来看点jvm规范中的原文，7和8一样的。  </p>
<span id="more"></span>

<blockquote>
<p>&emsp;The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the “text” segment in an operating system process. <strong>It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods (§2.9) used in class and instance initialization and interface initialization.</strong>  </p>
<p>&emsp;The method area is created on virtual machine start-up. <strong>Although the method area is logically part of the heap,</strong> simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.</p>
<blockquote>
<p>&emsp;A Java Virtual Machine implementation may provide the programmer or the user control over the initial size of the method area, as well as, in the case of a varying-size method area, control over the maximum and minimum method area size.</p>
</blockquote>
<p>The following exceptional condition is associated with the method area:</p>
<ul>
<li>If memory in the method area cannot be made available to satisfy an allocation request, the Java Virtual Machine throws an <strong>OutOfMemoryError.</strong></li>
</ul>
</blockquote>
<p>&emsp;&emsp;方法区是逻辑上的东西，是JVM规范的东西，所有虚拟机必须遵守的。<br>&emsp;&emsp;根据JVM规范中，<strong>它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法（2.9）。</strong><br>&emsp;&emsp;jvm规范中也说了，方法区域是在虚拟机启动时创建的。虽然方法区域是<strong>在堆的逻辑部分</strong>，简单实现可以选择不垃圾收集或压缩。此版本的Java虚拟机规范<strong>不强制指定方法区域的位置</strong>或用于管理的策略编译的代码。<br>&emsp;&emsp;因此不同的虚拟机，或者不同的版本对方法区有了不同的实现，比如1.7中的永久代，1.8中的元空间。而方法区也被称为非堆。</p>
<hr>
<h1 id="永久代（PermGen）"><a href="#永久代（PermGen）" class="headerlink" title="永久代（PermGen）"></a>永久代（PermGen）</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%86%85%E5%AD%98.jpg" alt="堆与永久代是连续的"></p>
<p>&emsp;&emsp;在HotSpot虚拟中永久代是jdk1.7的实现，在HotSpot上把<strong>GC分代收集扩展至方法区</strong>，或者说使用永久代来实现方法区，而在其他虚拟机中并没有永久代的说法。<br>&emsp;&emsp;HotSpot使用GC分代来实现方法区内存回收。这里的垃圾回收是和老年代是绑定在一起的。<br>&emsp;&emsp;永久代的大小是启动时限制死的没有办法调整的，在动态生成类较多的情况下，容易出现内存溢出的问题，比如大量jsp页面的情况下，每个jsp都会生成servlet。<br>&emsp;&emsp;在1.7中，永久代和java堆是隔离的，但是他们使用的内存空间是连续的，也可以说永久代使用的是jvm的内存。<br>&emsp;&emsp;在HotSpot虚拟中这个实现在jdk1.8中被移除了。  </p>
<hr>
<h1 id="元空间（matespace）"><a href="#元空间（matespace）" class="headerlink" title="元空间（matespace）"></a>元空间（matespace）</h1><p>&emsp;&emsp;元空间是HotSpot虚拟机在jdk1.8对jvm规范的实现。<br>&emsp;&emsp;在1.8中，将1.7中永久代保存的数据一部分转移到了java堆中，一部分转移到了元空间中。<br>&emsp;&emsp;1.8中，元空间不在与堆连续，也就是不在jvm中了，而是使用本地内存。<br>&emsp;&emsp;本地内存又称为C-heap，是jvm自身进程使用的。元空间在的这部分内存因为不在jvm中，而不会发生GC。<br>&emsp;&emsp;理论上元空间不在会发生向永久代的内存溢出的问题，因为主机内存可以无限使用，这样可以加载的类的数量就不再受限制，但是一般可以通过参数设置最大空间。<br>&emsp;&emsp;元空间的大小如果不进行设置，JVM会自动根据类的元数据大小动态增加元空间的容量。<br>&emsp;&emsp;对于元空间的内存管理，jvm采用元空间虚拟机管理。在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。<br>&emsp;&emsp;每一个类加载的存储区域都称为一个元空间，也就是元空间再主存中是零散的，所有的元空间合起来就是说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;永久代是jdk1.7的实现，元空间是1.8的实现。</p>
<h2 id="移除永久代原因"><a href="#移除永久代原因" class="headerlink" title="移除永久代原因"></a>移除永久代原因</h2><ol>
<li><p>字符串存在永久代中，现实使用中易出问题, 由于永久代内存经常不够用或发生内存泄露，爆出异常。这一步再1.6更新到1.7时已经完成，也就是说移除永久代是持续的，分布的。</p>
<blockquote>
<p>JDK1.7及之后版本的JVM已经将字符串常量池从方法区中移了出来，在Java 堆（Heap）中开辟了一块区域存放字符串常量池。</p>
</blockquote>
</li>
<li><p>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p>
</li>
<li><p>永久代会为GC带来不必要的复杂度，并且回收效率偏低。</p>
</li>
<li><p>为了HotSpot和JRockit合并产生一个超级JVM。</p>
<p>&emsp;&emsp;移除工作从jdk1.7就开始了，只是没有完全移除。譬如符号引用(Symbols)转移到了native heap：字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。</p>
<blockquote>
<p>字面量就是<code>String hello = &quot;helle&quot;</code>，中引号中的部分，声明为final的（基本数据类型）常量值。<br>符号引用就是编译阶段，引用代替其他类的地址的东西。</p>
</blockquote>
</li>
</ol>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>1.7与1.8的版本区别。</li>
<li>永久代在jvm中，元空间不在。 </li>
<li>永久代大小是固定的，元空间不固定。</li>
<li>永久代内存是连续的且与堆相连，元空间内存是分散的。</li>
<li>永久代由JVM管理，元空间由元空间虚拟机管理。</li>
<li>永久代的GC与老年代绑定在一起，元空间是所持有其的类加载器被标记不在存活则会释放，还给操作系统。</li>
</ol>
<h2 id="存储内容"><a href="#存储内容" class="headerlink" title="存储内容"></a>存储内容</h2><p><a href="https://blog.csdn.net/WatsonYee/article/details/82839688?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control">java永久代，元空间，常量池，方法区详解</a><br><a href="https://blog.csdn.net/leunging/article/details/80599282#comments_15970151">Java中局部变量、实例变量和静态变量在方法区、栈内存、堆内存中的分配</a></p>
<p>&emsp;&emsp;根据JVM规范，方法区存储类的结构、运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法。<br>&emsp;&emsp;所以：—&gt;线程共享的，主要存储类信息、常量池、静态变量、JIT编译后的代码等数据。方法区理论上来说是堆的逻辑组成部分；<br>&emsp;对于常量池：</p>
<ol>
<li>class文件常量池</li>
<li>运行时常量池</li>
<li>字符串常量池</li>
</ol>
<h3 id="class文件常量池"><a href="#class文件常量池" class="headerlink" title="class文件常量池"></a>class文件常量池</h3><p>&emsp;&emsp;Class文件常量池指的是编译生成的class字节码文件，其结构中有一项是常量池（Constant Pool Table），用于存放编译期生成的各种<strong>字面量和符号引用</strong>（这里会被拆分、搬迁，看上面），这部分内容将在类加载后进入方法区的运行时常量池中存放。这里的数据貌似在jdk1.7被拆分了。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>&emsp;&emsp;根据规范-&gt;运行时常量池是类文件中constant_pool表的每个类或每个接口的运行时表示形式（4.4）。<br>&emsp;&emsp;Class文件常量池将在类加载后进入方法区的运行时常量池中存放（移除永久代的搬迁中会没了吧）。</p>
<h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串<em>常量池</em></h3><p><a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html">深入解析String#intern</a></p>
<blockquote>
<p>感觉有问题<br>String s = new String(“1”); 不考虑引用的情况下，不仅仅在堆上会分配一块内存，还会再字符串常量池生成一个对象。引号里面的再常量池，new出来的再堆上上，s在栈里，指向了堆里new的玩意。</p>
</blockquote>
<ol>
<li>在jdk1.6（含）之前也是方法区的一部分，并且其中存放的是字符串的实例。</li>
<li>在jdk1.7（含）之后是在堆内存之中，存储的是字符串对象的引用，也存储实例，字符串实例是在堆中。</li>
<li>jdk1.8已移除永久代，字符串常量池是在本地内存当中，存储的也只是引用，也存储实例，实例在堆中。</li>
</ol>
<p>&emsp;&emsp;JVM 中除了字符串常量池，8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池，超出此范围仍然会去创建新的对象。</p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm内存结构</title>
    <url>/hexoblog/2021/04/25/md/jvm/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><p>&emsp;&emsp;我们称的内存结构，在虚拟机规范中称为<strong>运行时数据区</strong>。</p>
<p>&emsp;&emsp;看下原文解释：</p>
<blockquote>
<p>&emsp;&emsp;Java虚拟机定义了在程序执行过程中使用的各种运行时数据区域。<strong>其中一些数据区域在Java虚拟机启动时创建，只有在Java虚拟机退出时才被销毁。其他数据区域是每个线程。每个线程的数据区域在创建线程时被创建，并在线程退出时被销毁。</strong></p>
</blockquote>
<span id="more"></span>

<p>&emsp;&emsp;在JVM虚拟机规范中，规范了jvm中逻辑上的内存区域。jvm规范中共有6大块：</p>
<ol>
<li>程序计数器（The pc Register）。</li>
<li>java虚拟机栈（Java Virtual Machine Stacks）。</li>
<li>堆（Heap）。</li>
<li>方法区（Method Area）。</li>
<li>运行时常量池（Run-Time Constant Pool）。</li>
<li>本地方法栈（Native Method Stacks）。</li>
</ol>
<hr>
<h1 id="程序计数器（The-pc-Register）"><a href="#程序计数器（The-pc-Register）" class="headerlink" title="程序计数器（The pc Register）"></a>程序计数器（The pc Register）</h1><p>&emsp;&emsp;原文机翻一波：</p>
<blockquote>
<p>&emsp;&emsp;Java虚拟机可以同时支持许多执行线程（JLS17）。<strong>每个Java虚拟机线程都有它自己的pc（程序计数器）寄存器。</strong> 在任何时候，每个Java虚拟机线程都在执行一个单一方法的代码，即该线程的当前方法（2.6）。<strong>如果该方法不是本机的，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。如果该线程当前要执行的方法是本机的，则未定义Java虚拟机的pc寄存器的值。</strong> Java虚拟机的pc寄存器足够宽，可以在特定的平台上保存一个返回地址或一个本机指针。</p>
</blockquote>
<p>&emsp;&emsp;当前线程所执行的字节码的行号指示器，它会指出下一条将要执行的指令的地址，字节码解释器就是通过改变计数器的值来选取程序接下来执行的操作。<br>&emsp;&emsp;程序计数器是线程私有的一小块内存，每个线程都有独立的程序计数器，保证线程切换后回到正确的位置。<br>&emsp;&emsp;保存内容：</p>
<ol>
<li>执行的如果是是Native方法，则为空。</li>
<li>线程正在执行java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址。</li>
</ol>
<blockquote>
<p>唯一一个不会出现OOM的内存区域。</p>
</blockquote>
<hr>
<h1 id="java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="java虚拟机栈（Java Virtual Machine Stacks）"></a>java虚拟机栈（Java Virtual Machine Stacks）</h1><p>&emsp;&emsp;机翻一波：</p>
<blockquote>
<p>&emsp;&emsp;<strong>每个Java虚拟机线程都有一个私有的Java虚拟机堆栈，它与线程同时创建。</strong> Java虚拟机堆栈可存储帧（2.6）。Java虚拟机堆栈类似于传统语言如C的堆栈：<strong>它包含局部变量和部分结果，并在方法调用和返回中发挥作用。</strong> 因为Java虚拟机堆栈永远不会被直接操作，除非是推送和弹出帧，所以帧可以被堆分配。Java虚拟机堆栈的内存不需要是连续的。</p>
</blockquote>
<p>&emsp;&emsp;和程序计数器一样，Java虚拟机栈也是线程私有的，在线程创建时Java虚拟机栈会被创建，每个方法在执行的同时都会创建一个栈帧，用于存放局部变量表，操作数栈，动态链接，方法出口等信息。调用方法时压栈，方法返回时出栈。</p>
<p><a href="https://blog.csdn.net/Jbinbin/article/details/86302768">jvm-操作数栈</a></p>
<ol>
<li>局部变量表：是存放方法参数和局部变量的区域，存放了各种基本类型。对象引用，returnAddress类型，局部变量表所需空间在编译期间就已经确定并完成分配，在方法运行期间不会被改变。<blockquote>
<p>&emsp;&emsp;虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。</p>
</blockquote>
</li>
<li>操作数栈：是个初始状态为空的桶式结构栈。<blockquote>
<p>&emsp;&emsp;虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。<br>&emsp;&emsp;虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，看看下面的示例，它演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的。</p>
</blockquote>
</li>
<li>动态链接：每个栈帧中包含一个在常量池中对当前方法的引用，目的是支持方法调用过程的动态连接。</li>
<li>方法出口：<ol>
<li>正常退出：遇到方法的返回字节码指令。</li>
<li>异常退出：<ol>
<li>栈溢出：StackOverFlowError，如果线程中的计算需要比允许的更大的 Java 虚拟机堆栈。</li>
<li>内存溢出：如果 Java 虚拟机堆栈可以动态扩展，并且尝试扩展，但无法提供足够的内存来实现扩展，或者如果无法提供足够的内存来为新线程创建初始 Java 虚拟机堆栈。</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h1 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h1><p>&emsp;&emsp;来一波：</p>
<blockquote>
<p>&emsp;&emsp;Java虚拟机有一个由所有<strong>Java虚拟机线程共享的堆。堆是用来分配所有类实例和数组的内存的运行时数据区域。</strong><br>&emsp;&emsp;该堆是在虚拟机启动时创建的。对象的堆存储由自动存储管理系统（称为垃圾回收器）回收；永远不会显式释放对象。Java虚拟机假设没有特定类型的自动存储管理系统，并且可以根据实现者的系统要求来选择存储管理技术。堆可能是固定的大小，也可以根据计算的要求进行扩展，如果没有必要使用更大的堆，则可以进行收缩。堆的内存不需要是连续的。<br>&emsp;&emsp;本规范允许Java虚拟机堆栈具有固定的大小，或者按照计算的需要动态扩展和收缩。如果Java虚拟机堆栈是固定大小的，则在创建每个Java虚拟机堆栈时，可以独立选择每个Java虚拟机堆栈的大小。</p>
</blockquote>
<p>&emsp;&emsp;这里是JVM管理的内存里最大的一块，存放对象实例，在虚拟机启动时创建。<br>&emsp;&emsp;根据对象存活的周期不同，JVM把堆内存进行分带管理，由垃圾收集器进行对象的回收管理。</p>
<hr>
<h1 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h1><p>&emsp;&emsp;机翻：</p>
<blockquote>
<p>&emsp;&emsp;Java虚拟机具有在所有Java虚拟机线程之间共享的方法区域。该方法区域类似于传统语言编译代码的存储区域，或类似于操作系统过程中的“文本”段。<strong>它存储每个类的结构，如运行时常量池、字段和方法数据，以及方法和构造函数的代码，包括在类和实例初始化和接口初始化中使用的特殊方法（2.9）。</strong><br>&emsp;&emsp;方法区域是在虚拟机启动时创建的。虽然方法区域是<strong>在堆的逻辑部分</strong>，简单实现可以选择不垃圾收集或压缩。此版本的Java虚拟机规范<strong>不强制指定方法区域的位置</strong>或用于管理的策略编译的代码。方法区域可以具有固定的大小，或者可以根据计算的需要进行扩展，并且如果方法区域变得更大，则可以收缩没必要。方法区域的内存不需要是连续的。</p>
</blockquote>
<p>&emsp;&emsp;与堆一样是线程共享的，存储被类加载器加载的类信息，常量，静态变量等，就是编译器编译后的代码等数据。<br>&emsp;&emsp;如果方法区域中的内存无法满足分配请求，则Java虚拟机将抛出OutOfMemoryError。<br>&emsp;&emsp;方法区在jdk1.7和1.8之间，落地的物理实现有了区别。</p>
<hr>
<h1 id="运行时常量池（Run-Time-Constant-Pool）"><a href="#运行时常量池（Run-Time-Constant-Pool）" class="headerlink" title="运行时常量池（Run-Time Constant Pool）"></a>运行时常量池（Run-Time Constant Pool）</h1><p>&emsp;&emsp;机翻搞起来：</p>
<blockquote>
<p>&emsp;&emsp;运行时常量池是类文件中constant_pool表的每个类或每个接口的运行时表示形式（4.4）。它包含几种常量，从编译时已知的数字文本到在运行时必须解析的方法和字段引用。运行时常量池提供的函数类似于传统编程语言的符号表的函数，尽管它包含了比典型的符号表更广泛的数据范围。<br><strong>每个运行时常量池都从Java虚拟机的方法区域（2.5.4）进行分配。</strong>类或接口的运行时常量池将在由Java虚拟机创建（5.3）时构建。</p>
</blockquote>
<p>&emsp;&emsp;通俗来说，运行时常量池用于存放编译期生成的各种字面量和符号引用。并不是编译器才产生常量，运行期间也有可能将新的常量放入常量池。<br>&emsp;&emsp;创建类或接口时，如果构造运行时常量池需要的内存超过Java虚拟机的方法区域可以提供的内存，则Java虚拟机将抛出OutOfMemoryError。</p>
<blockquote>
<p>constant_pool表，指的是类在编译过程中生成的常量表。</p>
</blockquote>
<hr>
<h1 id="本地方法栈（Native-Method-Stacks）"><a href="#本地方法栈（Native-Method-Stacks）" class="headerlink" title="本地方法栈（Native Method Stacks）"></a>本地方法栈（Native Method Stacks）</h1><p>&emsp;&emsp;机翻再来：</p>
<blockquote>
<p>&emsp;&emsp;Java虚拟机的实现可以使用传统的堆栈，俗称“C堆栈”，来支持本地方法(用Java编程语言以外的语言编写的方法)。本地方法堆栈也可以使用解释器的实现Java虚拟机的指令集的语言如C.Java虚拟机实现不能加载本地方法，本身不依赖于传统的栈不需要提供本地方法堆栈。如果提供了这些，则通常在创建每个线程时为每个线程分配本机方法堆栈。<br>&emsp;&emsp;本规范允许本地方法堆栈具有固定的大小，或者按照计算的要求动态地扩展和收缩。如果本机方法堆栈的大小是固定，则在创建每个本机方法堆栈时，可以独立选择每个本机方法堆栈的大小。</p>
</blockquote>
<p>&emsp;&emsp;本地方法栈与虚拟机栈类似，不过本地方法栈保存本地方法。<br>&emsp;&emsp;如果线程中的计算需要比允许的更大的本机方法堆栈，则Java虚拟机将抛出StackOverFlowError。<br>&emsp;&emsp;如果可以动态扩展本机方法堆栈，并且尝试进行本机方法堆栈扩展，但可用内存不足，或者如果没有足够的内存可以为新线程创建初始本机方法堆栈，则Java虚拟机将抛出OutOfMemoryError。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;JVM规范中，逻辑上就规范了这6中内存区域，但并没有规范实际的虚拟机该如何实现，不同的虚拟机可以安照该规范有不同的实现，相同虚拟机不同版本也可能有不同的实现，按照规范即可。<br>&emsp;&emsp;规范中规定了一些内存区域是线程共享的，这种区域就随着虚拟机的创建销毁而进行分配回收，而一些线程独享的内存区域就随着线程的创建销毁而分配回收。</p>
<ol>
<li>线程共享的区域：<ol>
<li>堆</li>
<li>方法区（非堆）</li>
<li>运行时常量池</li>
</ol>
</li>
<li>线程独享的区域：<ol>
<li>java虚拟机栈</li>
<li>本地方法栈</li>
<li>程序计数器</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>memory</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm命令</title>
    <url>/hexoblog/2021/03/29/md/jvm/jvm%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="JVM命令的使用"><a href="#JVM命令的使用" class="headerlink" title="JVM命令的使用"></a>JVM命令的使用</h1><p><a href="https://blog.csdn.net/wangxiaotongfan/article/details/82560739">https://blog.csdn.net/wangxiaotongfan/article/details/82560739</a></p>
<h2 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>&emsp;&emsp;显示当前系统的java进程。</p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol>
<li>-q：只显示pid，不显示class名称，jar文件名和传递给main方法的参数。</li>
<li>-l：输出应用程序main class的完整package名或者应用程序的jar文件完整路径名。</li>
<li>-m：输出jvm启动时传递给main方法启动。</li>
<li>-v：输出JVM启动时显示指定的JVM参数。</li>
</ol>
<h2 id="JSTAT"><a href="#JSTAT" class="headerlink" title="JSTAT"></a>JSTAT</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>&emsp;&emsp;用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译(Just In Time Compiler, 即时编译器)等运行数据。</p>
<h3 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p>if [ “$DEBUG” = “true” ]; then<br>  echo -e “\033[0;31m debug is open,port=$DEBUG_PORT \033[0m”<br>  JAVA_OPTS=”$JAVA_OPTS -Xdebug -Xrunjdwp:transport=dt_socket,address=$DEBUG_PORT,server=y,suspend=y”<br>fi</p>
<p>JAVA_HEAP_DUMP_OPTS=-XX:HeapDumpPath=$LOG_HOME/dump.hprof<br>JAVA_OPTS=”$JAVA_OPTS -Dserver.port=$PORT -Dlog.home=$LOG_HOME -Duse.flume=false -Xms128m -Xmx2048m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=1024m -Dfile.encoding=utf-8 -XX:+HeapDumpOnOutOfMemoryError $JAVA_HEAP_DUMP_OPTS”<br>#JAVA_OPTS=”$JAVA_OPTS -XX:+TraceClassLoading -XX:+TraceClassUnloading”</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>jvm</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm调优</title>
    <url>/hexoblog/2021/03/04/md/jvm/jvm%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p><a href="https://baijiahao.baidu.com/s?id=1617167971312758600&wfr=spider&for=pc">jvm性能调优的6大步骤</a></p>
<span id="more"></span>

<hr>
<h1 id="调优方法与步骤"><a href="#调优方法与步骤" class="headerlink" title="调优方法与步骤"></a>调优方法与步骤</h1><ol>
<li>监控GC的状态</li>
<li>生成堆的dump文件</li>
<li>分析dump文件</li>
<li>分析结果判断是否需要优化</li>
<li>调整GC类型和内存分配</li>
<li>不断分析和调整</li>
</ol>
<hr>
<h1 id="调优参考参数"><a href="#调优参考参数" class="headerlink" title="调优参考参数"></a>调优参考参数</h1><ol>
<li>调整jvm堆内存的占用空间</li>
<li>调整新生代老年代占用堆空间的比例，</li>
<li>老年代与新生代设置多大合理<ol>
<li>大的年轻代将会导致普通GC的周期延长，但会增加GC的时间，小的老年代必定会导致频繁的full GC  </li>
<li>小的年轻代导致普通GC的频繁发生，但GC的时间短，大的老年代将会减少full GC的频率</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis连接双数据库</title>
    <url>/hexoblog/2021/03/09/md/mybatis/mybatis%E8%BF%9E%E6%8E%A5%E5%8F%8C%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h1><p>&emsp;&emsp;项目中需要从两个不同的数据库查询数据，之前实现方法是：springboot配置连接一个数据源，另一个使用jdbc代码连接。<br>&emsp;&emsp;为了改进，现在使用SpringBoot配置连接两个数据源。</p>
<span id="more"></span>

<hr>
<h1 id="实现效果："><a href="#实现效果：" class="headerlink" title="实现效果："></a>实现效果：</h1><p>&emsp;&emsp;一个SpringBoot项目，同时连接两个数据库。</p>
<p><strong>注意：</strong>连接什么数据库，要引入对应数据库的包</p>
<hr>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>&emsp;&emsp;实现多数据源均需要使用到mybatis plus。这里也引入了druid连接池。<br>&emsp;&emsp;双数据源中需要将不同数据源的mapper和对应xml文件放在不同的包中。</p>
<p>&emsp;&emsp;先准备两个数据源。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 数据源1</span></span><br><span class="line"><span class="keyword">create</span> schema mybatisdubboone;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span> auto_increment</span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    username    <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>                <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    mobile      <span class="type">varchar</span>(<span class="number">15</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>                <span class="keyword">null</span>,</span><br><span class="line">    create_time datetime    <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据源2</span></span><br><span class="line"><span class="keyword">create</span> schema mybatisdubbotwo;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> mybatisdubbotwo.order_info</span><br><span class="line">(</span><br><span class="line">    id          <span class="type">int</span> auto_increment</span><br><span class="line">        <span class="keyword">primary</span> key,</span><br><span class="line">    order_id    <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span>                <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    user_id     <span class="type">int</span>         <span class="keyword">default</span> <span class="number">0</span>                 <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    create_time datetime    <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="静态双数据源"><a href="#静态双数据源" class="headerlink" title="静态双数据源"></a>静态双数据源</h2><p>&emsp;&emsp;静态数据源需要对不同的数据源单独配置，同时需要关闭掉springboot和druid的数据源自动配置。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">staticmybatisdubbomysql</span></span><br><span class="line">  <span class="attr">datasourceone:</span></span><br><span class="line">    <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatisdubboone?serverTimezone=GMT</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1234</span></span><br><span class="line">  <span class="attr">datasourcetwo:</span></span><br><span class="line">    <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatisdubbotwo?serverTimezone=GMT</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;数据源1配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.lin.mybatisdubbomysql.dal.mapper.databaseone&quot;, sqlSessionTemplateRef = &quot;SqlSessionTemplateOne&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DatabaseOneProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseOneConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    DatabaseOneProperties databaseOneProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSourceOne&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        druidDataSource.setUrl(databaseOneProperties.getJdbcUrl());</span><br><span class="line">        druidDataSource.setUsername(databaseOneProperties.getUsername());</span><br><span class="line">        druidDataSource.setPassword(databaseOneProperties.getPassword());</span><br><span class="line">        druidDataSource.setDriverClassName(databaseOneProperties.getDriverClassName());</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;sqlSessionFactoryOne&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(<span class="meta">@Qualifier(&quot;dataSourceOne&quot;)</span> DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MybatisSqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> MybatisSqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(</span><br><span class="line">                <span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">&quot;classpath:mapper/databaseone/*.xml&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;SqlSessionTemplateOne&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;sqlSessionFactoryOne&quot;)</span>SqlSessionFactory sqlSessionFactory)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;Txone&quot;)</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">dataSourceTransactionManager</span><span class="params">(<span class="meta">@Qualifier(&quot;dataSourceOne&quot;)</span> DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;数据源2配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.lin.mybatisdubbomysql.dal.mapper.databasetwo&quot;, sqlSessionTemplateRef = &quot;SqlSessionTemplateTwo&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DatabaseTwoProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseTwoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    DatabaseTwoProperties databaseTwoProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;dataSourceTwo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        druidDataSource.setUrl(databaseTwoProperties.getJdbcUrl());</span><br><span class="line">        druidDataSource.setUsername(databaseTwoProperties.getUsername());</span><br><span class="line">        druidDataSource.setPassword(databaseTwoProperties.getPassword());</span><br><span class="line">        druidDataSource.setDriverClassName(databaseTwoProperties.getDriverClassName());</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;sqlSessionFactoryTwo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(<span class="meta">@Qualifier(&quot;dataSourceTwo&quot;)</span> DataSource dataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MybatisSqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> MybatisSqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource);</span><br><span class="line">        sqlSessionFactoryBean.setMapperLocations(</span><br><span class="line">                <span class="keyword">new</span> PathMatchingResourcePatternResolver().getResources(<span class="string">&quot;classpath:mapper/databasetwo/*.xml&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;SqlSessionTemplateTwo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(<span class="meta">@Qualifier(&quot;sqlSessionFactoryTwo&quot;)</span> SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;Txtwo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSourceTransactionManager <span class="title">dataSourceTransactionManager</span><span class="params">(<span class="meta">@Qualifier(&quot;dataSourceTwo&quot;)</span> DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;开启druid监控：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主要实现WEB监控的配置处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRegistrationBean&lt;StatViewServlet&gt; <span class="title">druidServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 现在要进行druid监控的配置处理操作</span></span><br><span class="line">        ServletRegistrationBean&lt;StatViewServlet&gt; servletRegistrationBean = <span class="keyword">new</span> ServletRegistrationBean&lt;&gt;(</span><br><span class="line">                <span class="keyword">new</span> StatViewServlet(), <span class="string">&quot;/druid/*&quot;</span>);</span><br><span class="line">        <span class="comment">// 白名单,多个用逗号分割， 如果allow没有配置或者为空，则允许所有访问</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;allow&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="comment">// 黑名单,多个用逗号分割 (共同存在时，deny优先于allow)</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;deny&quot;</span>, <span class="string">&quot;192.168.1.110&quot;</span>);</span><br><span class="line">        <span class="comment">// 控制台管理用户名</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;loginUsername&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 控制台管理密码</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;loginPassword&quot;</span>, <span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否可以重置数据源，禁用HTML页面上的“Reset All”功能</span></span><br><span class="line">        servletRegistrationBean.addInitParameter(<span class="string">&quot;resetEnable&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> servletRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterRegistrationBean&lt;WebStatFilter&gt; <span class="title">filterRegistrationBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FilterRegistrationBean&lt;WebStatFilter&gt; filterRegistrationBean = <span class="keyword">new</span> FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        filterRegistrationBean.setFilter(<span class="keyword">new</span> WebStatFilter());</span><br><span class="line">        <span class="comment">//所有请求进行监控处理</span></span><br><span class="line">        filterRegistrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">        <span class="comment">//添加不需要忽略的格式信息</span></span><br><span class="line">        filterRegistrationBean.addInitParameter(<span class="string">&quot;exclusions&quot;</span>, <span class="string">&quot;*.js,*.gif,*.jpg,*.css,/druid/*&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> filterRegistrationBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;启动类配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.lin.mybatisdubbomysql.*&quot;)</span></span><br><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class, DruidDataSourceAutoConfigure.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticMybatisDubboMysqlApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(StaticMybatisDubboMysqlApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态双数据源"><a href="#动态双数据源" class="headerlink" title="动态双数据源"></a>动态双数据源</h2><p>&emsp;&emsp;动态数据源，通过MybatisPlus提供的AbstractRoutingDataSource的路由能力，配合AOP在操作数据库前进行数据源切换。同样也需要关闭SpringBoot和druid的自动数据源配置。</p>
<p>&emsp;&emsp;数据源配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(basePackages = &quot;com.lin.mybatisdubbomysql.dal.mapper&quot;,sqlSessionFactoryRef = &quot;sqlSessionFactory&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasourceone&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasourcetwo&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DynamicDataSource <span class="title">dataSource</span><span class="params">(DataSource dataSourceOne,DataSource dataSourceTwo)</span></span>&#123;</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">8</span>);</span><br><span class="line">        targetDataSources.put(DateBaseEnum.DataBaseOne.getValue(),dataSourceOne);</span><br><span class="line">        targetDataSources.put(DateBaseEnum.DataBaseTwo.getValue(), dataSourceTwo);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DynamicDataSource(dataSourceOne, targetDataSources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DynamicDataSource dynamicDataSource)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MybatisSqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> MybatisSqlSessionFactoryBean();</span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dynamicDataSource);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;动态数据路由配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; CONTEXT_HOLDER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicDataSource</span><span class="params">(DataSource defaultTargetDataSource, Map&lt;Object, Object&gt; targetDataSources)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setDefaultTargetDataSource(defaultTargetDataSource);</span><br><span class="line">        <span class="keyword">super</span>.setTargetDataSources(targetDataSources);</span><br><span class="line">        <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(String dataSource)</span> </span>&#123;</span><br><span class="line">        CONTEXT_HOLDER.set(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CONTEXT_HOLDER.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clearDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CONTEXT_HOLDER.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;数据类型枚举：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">DateBaseEnum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库one</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DataBaseOne(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;one&quot;</span>),</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据库two</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    DataBaseTwo(<span class="string">&quot;two&quot;</span>, <span class="string">&quot;two&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过AOP在执行前切换数据源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatasourceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * com.lin.mybatisdubbomysql.dal.mapper.databasetwo..*.*(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataSourcePointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;dataSourcePointCut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        DynamicDataSource.setDataSource(DateBaseEnum.DataBaseTwo.getValue());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> point.proceed();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DynamicDataSource.clearDataSource();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mybatisplus官方动态双数据源"><a href="#mybatisplus官方动态双数据源" class="headerlink" title="mybatisplus官方动态双数据源"></a>mybatisplus官方动态双数据源</h2><p>&emsp;&emsp;官方的动态数据源配置最为简单。<br>&emsp;&emsp;yml文件的配置与其他的不同，使用mybatisplus的配置，yml文件配置后，使用自动注入的数据源即可。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">plusmybatisdubbomysql</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">dynamic:</span></span><br><span class="line">      <span class="attr">primary:</span> <span class="string">master</span> <span class="comment">#设置默认的数据源或者数据源组,默认值即为master</span></span><br><span class="line">      <span class="attr">strict:</span> <span class="literal">false</span> <span class="comment">#设置严格模式,默认false不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源.</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">master:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatisdubboone?serverTimezone=GMT</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">1234</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span> <span class="comment"># 3.2.0开始支持SPI可省略此配置</span></span><br><span class="line">        <span class="attr">slave:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatisdubbotwo?serverTimezone=GMT</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">          <span class="attr">password:</span> <span class="number">1234</span></span><br><span class="line">          <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;官方的切换方式，采用<code>@DS(&quot;&quot;)</code>注解，指定类、方法、mapper（官方不推荐）进行数据源的切换。这里注解中的值要和yml文件配置的一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@DS(&quot;master&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title">ServiceImpl</span>&lt;<span class="title">UserMapper</span>, <span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql中datetime和timestamp</title>
    <url>/hexoblog/2021/04/14/md/mysql/mysql%E4%B8%ADdatetime%E5%92%8Ctimestamp/</url>
    <content><![CDATA[<h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="date和datetime，timestamp的区别"><a href="#date和datetime，timestamp的区别" class="headerlink" title="date和datetime，timestamp的区别"></a>date和datetime，timestamp的区别</h2><ol>
<li>date保存的是天，精确到天</li>
<li>datetime，timestamp精确到秒</li>
</ol>
<span id="more"></span>
<h2 id="datetime和timastamp"><a href="#datetime和timastamp" class="headerlink" title="datetime和timastamp"></a>datetime和timastamp</h2><p>&emsp;&emsp;datetime 和timestamp两者都是时间类型字段，格式都一致。</p>
<ol>
<li><p>受时区影响不同</p>
<blockquote>
<p>timestamp会跟随设置的时区变化而变化，而datetime保存的是绝对值不会变化。</p>
</blockquote>
</li>
<li><p>占用存储空间不同</p>
<blockquote>
<p>timestamp储存占用4个字节，datetime储存占用8个字节。</p>
</blockquote>
</li>
<li><p>可以表示的时间范围不同</p>
<blockquote>
<p>timestamp可表示范围:1970-01-01 00:00:00~2038-01-09 03:14:07，datetime支持的范围更宽1000-01-01 00:00:00 ~ 9999-12-31 23:59:59。</p>
</blockquote>
</li>
<li><p>索引速度不同</p>
<blockquote>
<p>timestamp更轻量，索引相对datetime更快。</p>
</blockquote>
</li>
<li><p>默认值不同</p>
<blockquote>
<p>datetime的默认值为null，timestamp的字段默认不为空（not null），默认值为当前时间（CURRENT_TIMESTAMP），如果不做特殊处理，并且update语句中没有指定该列的更新值，则默认更新为当前时间。</p>
</blockquote>
</li>
<li><p>存储方式不同</p>
<blockquote>
<p>两者的存储方式不一样，对于timestamp，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。而对于datetime，不做任何改变，基本上是原样输入和输出。</p>
</blockquote>
</li>
</ol>
<p>&emsp;&emsp;在mysql5.6之前的版本，CURRENT_TIMESTAMP只能用于timestamp类型，5.6版本之后，CURRENT_TIMESTAMP也能用于datetime类型了。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql常用命令</title>
    <url>/hexoblog/2021/03/12/md/mysql/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="修改mysql时区"><a href="#修改mysql时区" class="headerlink" title="修改mysql时区"></a>修改mysql时区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看时区</span></span><br><span class="line">show variables like <span class="string">&quot;%time_zone%&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时区为UTC+8:00</span></span><br><span class="line"><span class="built_in">set</span> global time_zone = <span class="string">&#x27;+8:00&#x27;</span>;</span><br><span class="line"><span class="built_in">set</span> time_zone = <span class="string">&#x27;+8:00&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新立即生效</span></span><br><span class="line">flush privileges；</span><br></pre></td></tr></table></figure>

<span id="more"></span>
<h2 id="使用mysql-binlog"><a href="#使用mysql-binlog" class="headerlink" title="使用mysql binlog"></a>使用mysql binlog</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看日志是否开启</span></span><br><span class="line">show variables like <span class="string">&#x27;log_%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看binlog配置</span></span><br><span class="line">show variables like <span class="string">&#x27;binlog_%&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据库当前日志情况</span></span><br><span class="line">show master status;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有日志文件</span></span><br><span class="line">show binary logs;</span><br><span class="line">show master logs;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据事件查看文件</span></span><br><span class="line">show binlog events <span class="keyword">in</span> <span class="string">&#x27;$&#123;binlogname&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看binlog日志文件内容</span></span><br><span class="line">mysqlbinlog  <span class="variable">$&#123;binlogname&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以人类能看懂的方式查看binlog文件内容</span></span><br><span class="line">mysqlbinlog --base64-output=decode-rows -vvvvvv <span class="variable">$&#123;binlogname&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用-r命令将日志转写进sql</span></span><br><span class="line">mysqlbinlog --base64-output=decode-rows -vvvvvv <span class="variable">$&#123;binlogname&#125;</span> -r <span class="variable">$&#123;sqlname.sql&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还原数据库</span></span><br><span class="line">mysqlbinlog --start-positoin=<span class="variable">$&#123;number&#125;</span> --stop-position=<span class="variable">$&#123;number&#125;</span> <span class="variable">$&#123;binlogname&#125;</span> -d <span class="variable">$&#123;databasename&#125;</span> | mysql -u<span class="variable">$&#123;username&#125;</span> -p<span class="variable">$&#123;password&#125;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;转写进文件的日志不能直接执行，不过我们可以从其中提取有用信息。<br>&emsp;&emsp;因为binlog日志里面会将删除等操作全部保存下来，所以再还原数据库信息时一定不能全部解析，需要指定确切位置。<br>&emsp;&emsp;指定位置，数据库，时间，端口，host的命令都可以跟在mysqlbinlog后面，不只只用来恢复，转储，查看都可以。这些命令可以排列组合，放在日志名称前即可。</p>
<p>mysqlbinlog其他参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 起始位置</span></span><br><span class="line">--start-position=<span class="variable">$&#123;positiom number&#125;</span></span><br><span class="line"><span class="comment"># 结束位置</span></span><br><span class="line">--stop-position=<span class="variable">$&#123;position number&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始时间</span></span><br><span class="line">--start-datetime=<span class="variable">$&#123;starttime&#125;</span></span><br><span class="line"><span class="comment"># 结束时间</span></span><br><span class="line">--stop-datetime=<span class="variable">$&#123;stoptime&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库</span></span><br><span class="line">-d <span class="variable">$&#123;databasename&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 端口号(大写的P)</span></span><br><span class="line">-P <span class="variable">$&#123;port&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ip地址</span></span><br><span class="line">-h <span class="variable">$&#123;hosts&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># serverId</span></span><br><span class="line">--server-id=<span class="variable">$&#123;server-id&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql浮点数精度</title>
    <url>/hexoblog/2021/04/14/md/mysql/mysql%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h1><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>&emsp;&emsp;浮点型又称之为精度类型：是一种有可能丢失精度的数据类型，数据有可能不那么准确（由其是在超出范围的时候）。<br>&emsp;&emsp;浮点型之所以能够存储较大的数值（不精确），原因就是利用存储数据的位来存储指数。</p>
<span id="more"></span>
<h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p>&emsp;&emsp;单精度浮点数，采用4个字节存储，保证7个位的精度。<br>&emsp;&emsp;Float(M,D)：表示一共存储M个有效数字，其中小数部分占D位。M(1<del>255)称为精度，D(1</del>30)称为标度且不能大于M-2，是可选的。<br>&emsp;&emsp;对于小数位数超长的，会采用四舍五入进行进位。</p>
<h3 id="double"><a href="#double" class="headerlink" title="double"></a>double</h3><p>&emsp;&emsp;双精度浮点数，采用8个字节存储，表示的范围更大，精度最大15位。</p>
<h2 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h2><p>&emsp;&emsp;能够保证数据精确的小数（小数部分可能不精确，超出长度会四舍五入），整数部分一定精确。<br>&emsp;&emsp;mysql中定点数只有一种，就是Decimal(M,D)。<br>&emsp;&emsp;Decimal定点数：系统自动根据存储的数据来分配存储空间，每大概9个数就会分配四个字节来进行存储，同时小数和整数部分是分开的。采用M+2个字节存储。<br>&emsp;&emsp;Decimal(M,D)：M表示总长度，最大值不能超过65，D代表小数部分长度，最长不能超过30。（默认为10，0）是必选的。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>redis为什么这么快</title>
    <url>/hexoblog/2021/03/08/md/redis/redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB/</url>
    <content><![CDATA[<h1 id="redis为什么这么快？"><a href="#redis为什么这么快？" class="headerlink" title="redis为什么这么快？"></a>redis为什么这么快？</h1><ol>
<li>完全基于内存，绝大部分请求时纯内存操作，非常快速。数据在内存中类似于hashmap，hashmap的优势就是查找和操作的时间复杂度都是O(1)。</li>
<li>数据结构简单，对数据操作也简单，Redis的数据结构是专门进行设计的。SDS。</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或多线程切换导致的消耗cpu，不用去考虑各种锁的问题，不存在加锁释放锁的操作，没有因可能出现死锁而导致的消耗。</li>
<li>使用IO多路复用模型，非阻塞IO。</li>
<li>使用底层模型不同，他们之间底层实现方式以及客户端之间通信的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
</ol>
<span id="more"></span>

<hr>
<h1 id="多路复用IO模型。"><a href="#多路复用IO模型。" class="headerlink" title="多路复用IO模型。"></a>多路复用IO模型。</h1><ol>
<li>多路I/O复用模型就是利用select，poll，epoll可以同时监测多个流的I/O事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞中唤醒，于是程序就会轮询一遍所有流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</li>
<li>这里的多路指的是多个网络连接，复用指的是复用同一个线程。采用多路I/O复用技术，可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈。</li>
</ol>
<hr>
<h1 id="redis为什么是单线程的？"><a href="#redis为什么是单线程的？" class="headerlink" title="redis为什么是单线程的？"></a>redis为什么是单线程的？</h1><p>&emsp;&emsp;CPU并不是redis的瓶颈，瓶颈在于内存的大小或者网络，redis中，网络IO模块采用单线程。<br>&emsp;&emsp;这里的多路指的是多个网络连接，复用指的是复用同一个线程。采用多路I/O复用技术，可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>redis分布式锁</title>
    <url>/hexoblog/2021/04/14/md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>&emsp;&emsp;单机情况下，对于多线程情况下的竞态资源，我们可以在代码中使用synchronized或者ReentrantLock来加锁，防止发生并发问题。但是当我们的服务进行集群部署时，对于这两种加锁方式，就会失效，它们只能在单机加锁，所以就需要与之对应的分布式锁。</p>
<span id="more"></span>

<hr>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>&emsp;&emsp;一般采用redis的setnx原子操作来实现分布式锁。<br><a href="https://zhuanlan.zhihu.com/p/129886269">学习一下</a><br><a href="https://www.cnblogs.com/niceyoo/p/13711149.html">学习二下</a><br><a href="https://www.cnblogs.com/jojop/p/14008824.html">学习三下</a><br><a href="https://blog.csdn.net/asd051377305/article/details/108384490">学习四下</a></p>
<h2 id="setnx（获得锁）"><a href="#setnx（获得锁）" class="headerlink" title="setnx（获得锁）"></a>setnx（获得锁）</h2><p>&emsp;&emsp;setnx 是SET if Not eXists(如果不存在，则 SET)的简写。<br>&emsp;&emsp;完整语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set命令模式</span></span><br><span class="line">SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]</span><br><span class="line"></span><br><span class="line"><span class="comment"># setnx命令模式</span></span><br><span class="line">setnx key value</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>value的值尽可能使用随机数或者线程独有的，能够识别的，为了安全的释放锁。</li>
<li>使用不同的redis客户端（jedis，redisTemplate）时写法会有所不同，这里是redis黑窗口命令。</li>
</ol>
</blockquote>
<p>&emsp;&emsp;参数说明：</p>
<ol>
<li>EX：设置过期时间，时间精确到秒</li>
<li>PX：设置过期时间，时间精确到毫秒</li>
<li>NX：表示key不存在时才设置，否则返回null</li>
<li>XX：表示key存在时才设置，否则返回null</li>
</ol>
<h3 id="使用过程："><a href="#使用过程：" class="headerlink" title="使用过程："></a>使用过程：</h3><ol>
<li>执行setnx命令进行加锁，返回ok，返回nil则为加锁失败。</li>
<li>执行expire命令设置超时时间</li>
<li>执行业务逻辑</li>
<li>delete命令解锁</li>
</ol>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li>加锁与设置超时时间分步执行，若超时时间设置失败则有可能产生死锁。</li>
<li>delete命令存在误删非当前线程持有锁的可能。</li>
<li>不支持阻塞等待，不可重入。</li>
<li>单机redis锁，存在加锁后，主从切换时锁还未同步到问题，锁会丢失。</li>
</ol>
<h3 id="lua脚本（释放锁）"><a href="#lua脚本（释放锁）" class="headerlink" title="lua脚本（释放锁）"></a>lua脚本（释放锁）</h3><p>&emsp;&emsp;我们在手动解锁时，极限情况下会有删除其他线程锁的情况，因为我们的随机数比较和删除过程并不是原子操作。存在判断通过后，锁自动失效，其他线程加锁成功的情况，这是解锁会出问题。通过lua脚本原子操作，可以安全的解锁。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- lua删除锁：</span><br><span class="line">-- KEYS和ARGV分别是以集合方式传入的参数，对应上文的Test和uuid。</span><br><span class="line">-- 如果对应的value等于传入的uuid。</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[1]) == ARGV[1] </span><br><span class="line">    <span class="keyword">then</span> </span><br><span class="line"> -- 执行删除操作</span><br><span class="line">        <span class="built_in">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[1]) </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line"> -- 不成功，返回0</span><br><span class="line">        <span class="built_in">return</span> 0 </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h3 id="setex-amp-psetex"><a href="#setex-amp-psetex" class="headerlink" title="setex&amp;psetex"></a>setex&amp;psetex</h3><p>&emsp;&emsp;setex等同于set命令在可选参数使用EX的情况，都是在NX模式下，添加了过期时间，避免死锁。psetex相对于setex采用毫秒作为超时单位。</p>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p><a href="https://www.cnblogs.com/niceyoo/p/13736140.html">https://www.cnblogs.com/niceyoo/p/13736140.html</a></p>
<h2 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h2>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>分布式</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>redis安装和使用</title>
    <url>/hexoblog/2021/04/14/md/redis/redis%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>&emsp;&emsp;这里是在windows环境下的redis安装过程，两种安装方式，都比较简单。<br>&emsp;&emsp;官方提供的只有linux系统的tar.gz格式的压缩包，windows的需要在github下载。<br><a href="https://redis.io/">https://redis.io/</a><br><a href="http://www.redis.cn/">http://www.redis.cn/</a><br><a href="https://www.redis.com.cn/">https://www.redis.com.cn/</a><br><a href="https://www.redis.com.cn/redis-installation.html">https://www.redis.com.cn/redis-installation.html</a></p>
<span id="more"></span>
<h2 id="msi安装"><a href="#msi安装" class="headerlink" title="msi安装"></a>msi安装</h2><ol>
<li>下载msi安装文件<blockquote>
<p>官方提供的只有tar.gz格式压缩包下载，msi需要在github下载<br><a href="https://github.com/MicrosoftArchive/redis/releases">https://github.com/MicrosoftArchive/redis/releases</a></p>
</blockquote>
</li>
<li>双击运行</li>
<li>完成安装</li>
</ol>
<h2 id="zip安装"><a href="#zip安装" class="headerlink" title="zip安装"></a>zip安装</h2><ol>
<li>下载zip压缩包</li>
<li>将压缩包解压至你准备安装的路径</li>
<li>解压完成就是安装完成</li>
</ol>
<hr>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先进入安装目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;安装目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="comment"># 作为普通软件启动，命令行关闭则关闭</span></span><br><span class="line">redis-server.exe redis.windows.conf</span><br><span class="line"><span class="comment"># 作为服务启动，不跟随命令行</span></span><br><span class="line">redis-server.exe redis.windows-service.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端连接</span></span><br><span class="line">redis-cli.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">redis-server.exe --service-stop</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存击穿、穿透、雪崩</title>
    <url>/hexoblog/2021/03/08/md/redis/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E9%9B%AA%E5%B4%A9/</url>
    <content><![CDATA[<p><a href="https://my.oschina.net/linqiankun/blog/3191886">缓存击穿，穿透，雪崩</a></p>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>&emsp;&emsp;高并发系统中，大量的请求一般会落在缓存，但在某一时期，某一热点key过期，会导致大量的请求直接落到数据库，导致数据库崩溃。</p>
<span id="more"></span>

<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol>
<li>设置热点key不过期。</li>
<li>加上分布式锁，每次只有拿到锁的线程可以去访问数据库。第一个线程查询到后就会缓存起来，后面线程从缓存中拿。</li>
</ol>
<hr>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>&emsp;&emsp;正常情况下，需要查询的数据都存在，当查询一个缓存和数据库都不存在的数据时，每次请求都会落在数据库里，这种情况成称为缓存穿透。就是以一个不存在的数据去请求，每次都会落到数据库。</p>
<h2 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h2><ol>
<li>接口增加参数校验，不合法的直接返回。</li>
<li>缓存空值，将对应key的value设置为空值，避免暴力攻击。同时将key失效时间设置短一些，避免影响正常使用。</li>
<li>在网关阈值，限制同ip访问量。</li>
<li>高级用户布隆过滤器。bloom filter，可以对key进行判断是否在数据库存在，不存在就直接返回，存在就查询出来，并刷新缓存。</li>
</ol>
<hr>
<h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>&emsp;&emsp;某一时期发生的大规模的缓存不可用问题，过期，宕机。</p>
<h2 id="解决：-1"><a href="#解决：-1" class="headerlink" title="解决："></a>解决：</h2><ol>
<li>采用分布式集群，减少宕机风险。</li>
<li>将失效时间设为随机数，避免大量同时失效。</li>
<li>采用本地缓存加限流逻辑。</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>spring事务失效</title>
    <url>/hexoblog/2021/03/02/md/spring/spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<h1 id="事务失效的几种类型"><a href="#事务失效的几种类型" class="headerlink" title="事务失效的几种类型"></a>事务失效的几种类型</h1><ol>
<li>数据库引擎不支持事务。</li>
<li>没有被Spring管理。</li>
<li>方法不是public的。</li>
<li>自身调用问题。</li>
<li>数据源没有配置事务管理器。</li>
<li>不支持事务。</li>
<li>异常被吃了。</li>
<li>异常类型错误。</li>
</ol>
<span id="more"></span>

<hr>
<h1 id="事务失效类型："><a href="#事务失效类型：" class="headerlink" title="事务失效类型："></a>事务失效类型：</h1><h2 id="数据库引擎不支持事务"><a href="#数据库引擎不支持事务" class="headerlink" title="数据库引擎不支持事务"></a>数据库引擎不支持事务</h2><p>&emsp;&emsp;这里以 MySQL 为例，其 MyISAM 引擎是不支持事务操作的，InnoDB 才是支持事务的引擎，一般要支持事务都会使用 InnoDB。<br>&emsp;&emsp;根据 MySQL 的官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engine-setting.html">https://dev.mysql.com/doc/refman/8.0/en/storage-engine-setting.html</a></p>
<h2 id="没有被Spring管理"><a href="#没有被Spring管理" class="headerlink" title="没有被Spring管理"></a>没有被Spring管理</h2><p>&emsp;&emsp;Spring中的事务基于AOP实现，则事务类必须被Spring管理，进行代理，才能支持事务。</p>
<h3 id="方法不是public的"><a href="#方法不是public的" class="headerlink" title="方法不是public的"></a>方法不是public的</h3><p>&emsp;&emsp;@Transaction只对方法名为public的才会生效，其他的不生效。private，static，final方法不能添加事务，添加了也不会生效。</p>
<h3 id="自身调用问题"><a href="#自身调用问题" class="headerlink" title="自身调用问题"></a>自身调用问题</h3><ol>
<li> service类中调用本类自己的方法，由于没有经过spring代理，事务不会生效。</li>
<li>一个无事务的方法调用另一个有事务的方法，事务是不会起作用的。这种情况，可以内部维护一个自己注入的bean，使用这个属性来调用。或者利用AOP上下文来获取代理对象，利用代理对象调用。</li>
<li>有事务的调用有事务的被调用的不能新开启事务。被调用的开启的新事务不会生效。</li>
<li>有事务的调用无事务的会生效。</li>
<li>无事务的调用无事务的，这种情况就会没有事务。  </li>
</ol>
<p>&emsp;&emsp;事务是否生效主要看是否通过代理，没有通过代理就不会生效。</p>
<h2 id="数据源没有配置事务管理器"><a href="#数据源没有配置事务管理器" class="headerlink" title="数据源没有配置事务管理器"></a>数据源没有配置事务管理器</h2><p>&emsp;&emsp;数据源必须开启事务管理器：</p>
<ol>
<li>@EnableTransactionManagement  // 启注解事务管理，等同于xml配置方式的 &lt;tx:annotation-driven /&gt;</li>
<li>@EnableTransactionManagement 在springboot1.4以后可以不写。框架在初始化的时候已经默认给我们注入了两个事务管理器的Bean（JDBC的DataSourceTransactionManager和JPA的JpaTransactionManager ），其实这就包含了我们最常用的Mybatis和Hibeanate了。当然如果不是AutoConfig的而是自己自定义的，请使用该注解开启事务</li>
</ol>
<h2 id="不支持事务"><a href="#不支持事务" class="headerlink" title="不支持事务"></a>不支持事务</h2><p>&emsp;&emsp;Propagation设置错误，Propagation用于配置事务的传播行为。Propagation.NOT_SUPPORTED： 表示不以事务运行，当前若存在事务则挂起。</p>
<h2 id="异常被吃了"><a href="#异常被吃了" class="headerlink" title="异常被吃了"></a>异常被吃了</h2><p>&emsp;&emsp;异常被捕获了，然后不进行抛出，那么无法认为有异常，事务就不会回滚。在service中不应该进行事务的捕获，而进行抛出，在controller中进行异常捕获，这样既支持事务也捕获了异常。</p>
<h2 id="异常类型错误"><a href="#异常类型错误" class="headerlink" title="异常类型错误"></a>异常类型错误</h2><p>&emsp;&emsp;Spring的事务管理默认是针对Error异常和RuntimeException异常以及其子类进行事务回滚。对runtimeException并不需要抛出，error需要抛出异常，并进行捕获。如果想对其他异常进行支持，则需要配置：@Transactional(rollbackFor = Exception.class)</p>
<h2 id="业务和事务必须要在同一个线程中"><a href="#业务和事务必须要在同一个线程中" class="headerlink" title="业务和事务必须要在同一个线程中"></a>业务和事务必须要在同一个线程中</h2><p>&emsp;&emsp;不在同一个线程，则事务影响不到。</p>
<hr>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><h2 id="事务会引起的问题："><a href="#事务会引起的问题：" class="headerlink" title="事务会引起的问题："></a>事务会引起的问题：</h2><h3 id="脏读："><a href="#脏读：" class="headerlink" title="脏读："></a>脏读：</h3><p>&emsp;&emsp;当A事务对数据进行修改，但是这种修改还没有提交到数据库中，B事务同时在访问这个数据，由于没有隔离，B获取的数据有可能被A事务回滚，这就导致了数据不一致的问题。</p>
<h3 id="丢失修改："><a href="#丢失修改：" class="headerlink" title="丢失修改："></a>丢失修改：</h3><p>&emsp;&emsp;当A事务访问数据100，并且修改为100-1=99，同时B事务读取数据也是100，修改数据100-1=99，最终两个事务的修改结果为99，但是实际是98。事务A修改的数据被丢失了。</p>
<h3 id="不可重复读："><a href="#不可重复读：" class="headerlink" title="不可重复读："></a>不可重复读：</h3><p>&emsp;&emsp;指A事务在读取数据X=100的时候，B事务把数据X=100修改为X=200,这个时候A事务第二次读取数据X的时候，发现X=200了，导致了在整个A事务期间，两次读取数据X不一致了，这就是不可重复读。</p>
<h3 id="幻读："><a href="#幻读：" class="headerlink" title="幻读："></a>幻读：</h3><p>&emsp;&emsp;幻读和不可重复读类似。幻读表现在，当A事务读取表数据时候，只有3条数据，这个时候B事务插入了2条数据，当A事务再次读取的时候，发现有5条记录了，平白无故多了2条记录，就像幻觉一样。</p>
<p>&emsp;&emsp;不可重复读的重点是修改: 同样的条件 , 你读取过的数据 , 再次读取出来发现值不一样了，重点在更新操作。<br>&emsp;&emsp;幻读的重点在于新增或者删除：同样的条件 , 第 1 次和第 2 次读出来的记录数不一样，重点在增删操作。</p>
<h2 id="Spring定义的隔离级别："><a href="#Spring定义的隔离级别：" class="headerlink" title="Spring定义的隔离级别："></a>Spring定义的隔离级别：</h2><p><strong>TransactionDefinition.ISOLATION_DEFAULT：</strong> 数据库的默认隔离级别，MySQL默认采用的 REPEATABLE_READ隔离级别。<br><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：</strong> 最低的隔离级别，最低的隔离级别，允许读取未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><strong>TransactionDefinition.ISOLATION_READ_COMMITTED：</strong> 允许读取并发事务已经提交的数据，未提交的不可读取，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ：</strong> 对同一字段的多次重复读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。MySQL中通过MVCC解决了该隔离级别下出现幻读的可能。<br><strong>TransactionDefinition.ISOLATION_SERIALIZABLE：</strong> 串行化隔离级别，该级别可以防止脏读、不可重复读以及幻读，但是串行化会影响性能。</p>
<h3 id="Propagation，传播行为："><a href="#Propagation，传播行为：" class="headerlink" title="Propagation，传播行为："></a>Propagation，传播行为：</h3><p>指多个方法调用时，事务对多个方法之间传播的影响。</p>
<p><strong>PROPAGATION_REQUIRED：</strong> 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。<br><strong>PROPAGATION_SUPPORTS：</strong> 支持当前事务，如果当前没有事务，就以非事务方式执行。<br><strong>PROPAGATION_MANDATORY：</strong> 使用当前的事务，如果当前没有事务，就抛出异常。<br><strong>PROPAGATION_REQUIRES_NEW：</strong> 新建事务，如果当前存在事务，把当前事务挂起。<br><strong>PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。<br><strong>PROPAGATION_NEVER：</strong> 以非事务方式执行，如果当前存在事务，则抛出异常。<br><strong>PROPAGATION_NESTED：</strong> 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>acid</tag>
      </tags>
  </entry>
  <entry>
    <title>git</title>
    <url>/hexoblog/2021/03/03/md/tool/git/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="将本地文件推送至远程"><a href="#将本地文件推送至远程" class="headerlink" title="将本地文件推送至远程"></a>将本地文件推送至远程</h2><ol>
<li>首先在码云上建立一个项目</li>
<li>本地建立一个文件夹</li>
<li>进入文件夹，点击 git bash here</li>
<li>git init  #初始化本地仓库，出现一个.git文件夹</li>
<li>git remote add origin +远程仓库链接地址（https:/git:）</li>
<li>git pull origin master  #将码云上的仓库pull到本地文件夹</li>
<li>将要上传的文件，添加到刚刚创建的文件夹</li>
<li>git add .  #（.表示所有的）或者 git add + 文件名 将文件保存到缓存区</li>
<li>git commit -m ‘新添加的文件内容描述’  #添加文件描述</li>
<li>git push origin master  #将本地仓库推送到远程仓库</li>
</ol>
<span id="more"></span>

<h2 id="删除本地仓库"><a href="#删除本地仓库" class="headerlink" title="删除本地仓库"></a>删除本地仓库</h2><ol>
<li>进入文件夹，点击 git bash here</li>
<li>git branch  #显示本地所有分支</li>
<li>ls -a  #显示所有文件</li>
<li>rm -rf .git  #删除.git文件</li>
<li>删除文件夹</li>
</ol>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ol>
<li>git config  #查看配置</li>
</ol>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>swagger3</title>
    <url>/hexoblog/2021/03/03/md/tool/swagger3/</url>
    <content><![CDATA[<h1 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h1><h2 id="引包"><a href="#引包" class="headerlink" title="引包"></a>引包</h2><p>&emsp;&emsp;swagger3升级后，引入的包做相应升级，且集成进springboot启动器内，这里直接引入即可。</p>
<span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>&emsp;&emsp;这里配置与swagger2发生了些许变化：</p>
<h3 id="启动类"><a href="#启动类" class="headerlink" title="启动类"></a>启动类</h3><p>&emsp;&emsp;启动类中开启swagger的注解变为** @EnableOpenApi**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableOpenApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EbwcrmApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EbwcrmApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p>&emsp;&emsp;配置类中Docket类型需要修改为** DocumentationType.OAS_30**。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(value = &#123;&quot;ebwcrm.api.enable-swagger&quot;&#125;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">createRestApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.OAS_30).apiInfo(apiInfo()).select()</span><br><span class="line">                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)).paths(PathSelectors.any()).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建 api文档的详细信息函数,注意这里的注解引用的是哪个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                <span class="comment">// 页面标题</span></span><br><span class="line">                .title(<span class="string">&quot;集盈客Api接口文档&quot;</span>)</span><br><span class="line">                <span class="comment">// 创建人</span></span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">&quot;linqiankun&quot;</span>, <span class="string">&quot;http://localhost:8008/ebwcrm/swagger-ui/index.html&quot;</span>, <span class="string">&quot;linqiankun_51309@QQ.com&quot;</span>))</span><br><span class="line">                <span class="comment">// 版本号</span></span><br><span class="line">                .version(<span class="string">&quot;1.0&quot;</span>)</span><br><span class="line">                <span class="comment">// 描述</span></span><br><span class="line">                .description(<span class="string">&quot;根据服务端接口规范设计:http://doc.fed.weidai.work/docs/web/api&quot;</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;拦截器中需要对swagger的静态资源进行放行，以免启动后无法访问到swagger。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; pathPattern = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    pathPattern.add(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    List&lt;String&gt; excludePattern = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    excludePattern.add(<span class="string">&quot;/swagger-ui/**&quot;</span>);</span><br><span class="line">    excludePattern.add(<span class="string">&quot;/swagger-resources/**&quot;</span>);</span><br><span class="line">    excludePattern.add(<span class="string">&quot;/v3/api-docs&quot;</span>);</span><br><span class="line">    registry.addInterceptor(loginInterceptor)</span><br><span class="line">            .addPathPatterns(pathPattern)</span><br><span class="line">            .excludePathPatterns(excludePattern);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>&emsp;&emsp;接口使用的注解，与swagger2基本相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/miUser&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;Controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiUserController</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;updatePassword&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;updatePassword&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EBwcrmResult <span class="title">updatePassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;swagger3相对于swagger2的文档路径发生了改变。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">http://&lt;ip&gt;:&lt;port&gt;/&lt;applicattion&gt;/swagger-ui/index.html</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>tool</tag>
        <tag>swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo使用</title>
    <url>/hexoblog/2021/03/04/md/tool/hexo%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[toc]</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h2><p>&emsp;&emsp;hexo使用npm运行，所以首先需要安装node.js，安装node.js的同时会安装npm模块。</p>
<ol>
<li>在官网下载。<a href="http://nodejs.cn/">node.js</a></li>
<li>点击下载的文件进行安装（一路next）。</li>
</ol>
<span id="more"></span>

<p>&emsp;&emsp;安装成功后在命令行工具查看是或否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;出现下图的版本号即为安装成功。</p>
<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/node_npm_version.png" alt="安装成功"></p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>&emsp;&emsp;安装完node后就可以安装hexo了。这里全局安装hexok。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;安装完成后在命令行查看版本后确认是否安装成功。</p>
<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/hexo_version.png" alt="安装成功"></p>
<p>&emsp;&emsp;接下来就可以快乐的使用了。</p>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;在使用前还是先看下介绍吧，这样入手必较方便。</p>
<h2 id="看看目录结构"><a href="#看看目录结构" class="headerlink" title="看看目录结构"></a>看看目录结构</h2><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/hexo%E6%9E%B6%E6%9E%84.jpg" alt="hexo结构"></p>
<p>&emsp;&emsp;我们对重要的文佳夹分析下：</p>
<h3 id="node-modeules："><a href="#node-modeules：" class="headerlink" title="node_modeules："></a>node_modeules：</h3><p>&emsp;&emsp;因为运行在node环境下，这里就是安装的所有npm包。</p>
<h3 id="public"><a href="#public" class="headerlink" title="public:"></a>public:</h3><p>&emsp;&emsp;这里存放时hexo运行生成的所有hexo静态文件，将来托管在git上，可以使用gitee pages服务托管为静态网站作为博客网站。本地的启动看到的页面也是由这里产生。</p>
<h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds:"></a>scaffolds:</h3><p>&emsp;&emsp;这里存放我们的模板文件，包括创建草稿，博客，自定义页面的模板文件，当然都是markdown文件，我们也可以对其修改以满足我们的需求。</p>
<h3 id="sources"><a href="#sources" class="headerlink" title="sources:"></a>sources:</h3><p>&emsp;&emsp;这里都是我们的内容，post存放我们写的博客，文档等等，其他的呢，就是自定义的页面了，包括分类，标签，归档，我们也可以继续扩展，一般只需要关注post就可以了。</p>
<h3 id="theme"><a href="#theme" class="headerlink" title="theme:"></a>theme:</h3><p>&emsp;&emsp;这里存放生成博客网站的主题文件了，毕竟原有的主题实在不怎么好看。可以下载多个主题，随时切换使用。</p>
<h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>&emsp;&emsp;这个可不是目录，是实打实的文件了，我们的配置都在这里面了，这里做一些自定义的配置。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>常用命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文章</span></span><br><span class="line">hexo new post title</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建草稿</span></span><br><span class="line">hexo new draft title</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将草稿发布为文章</span></span><br><span class="line">hexo p title</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理本地生成的静态资源</span></span><br><span class="line">hexo clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译生成本地的静态资源</span></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地运行预览（附加草稿）</span></span><br><span class="line">hexo s (--draft)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地静态资源发送到gitee（需要自己配置）</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper</title>
    <url>/hexoblog/2021/03/03/md/zookeeper/zookeeper/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><span id="more"></span>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="查看dubbo服务"><a href="#查看dubbo服务" class="headerlink" title="查看dubbo服务"></a>查看dubbo服务</h2><ol>
<li><p>使用zk客户端连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./zkcli.sh</span><br><span class="line">./zkcli.bat</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务的提供者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /dubbo/****.***.Service/Providers</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务的消费者</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls /dubbo/****.****.Service/Consumers</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>tool</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper使用场景</title>
    <url>/hexoblog/2021/03/08/md/zookeeper/zookeeper%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;zookeeper是一个典型的发布/订阅模式的分布式数据管理与协调框架。</p>
<h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><ol>
<li>高性能使得ZooKeeper能够应用于对系统吞吐有明确要求的大型分布式系统。</li>
<li>高可用可以解决分布式的单点问题。</li>
<li>具有严格的顺序访问控制能力，主要是针对写操作的严格顺序性，使得客户端可以基于ZooKeeper来实现一些复杂的同步原语。</li>
</ol>
<span id="more"></span>

<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>&emsp;&emsp;ZooKeepr提供基于类似于文件系统的目录节点树方式的数据存储，这是一个共享的内存中的树型结构。<br>有几个概念需要关注一下:</p>
<ol>
<li>Session会话，客户端启动会与服务端建立一个TCP长连接，通过这个连接可以发送请求并接受响应，以及接受服务端的Watcher事件通知。</li>
<li>Znode数据节点，/xxxx就是一个Znode，会保存自己的数据内容和属性信息，分为持久和临时节点，节点有SEQUENTIAL属性。</li>
<li>Version版本，Stat数据结构包含version，cversion，aversion。</li>
<li>Watcher事件监听器，客户端可以在Znode上注册Watcher，服务端将事件通知已注册的客户端。</li>
</ol>
<hr>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h1><p>利用zookeeper可以非常构建一系列分布式应用中都会涉及到的核心功能:</p>
<ol>
<li><p>数据发布/订阅</p>
</li>
<li><p>负载均衡</p>
</li>
<li><p>命名服务</p>
</li>
<li><p>分布式协调/通知</p>
</li>
<li><p>集群管理</p>
</li>
<li><p>Master选举</p>
</li>
<li><p>分布式锁</p>
</li>
<li><p>分布式队列</p>
<p>多个开源项目中都用到了，如dubbo,kafka等。</p>
</li>
</ol>
<h2 id="数据发布与订阅"><a href="#数据发布与订阅" class="headerlink" title="数据发布与订阅"></a>数据发布与订阅</h2><p>&emsp;&emsp;数据发布订阅等一个常见场景是配置中心，发布者将数据发布到zookeeper的一个或一系列节点上，供订阅者进行数据订阅，达到动态获取数据的目的。</p>
<p>配置信息一般有几个特点:</p>
<ol>
<li>数据量小的KV</li>
<li>数据内容在运行时会发生动态变化</li>
<li>集权机器共享，配置一致</li>
</ol>
<p>zookeeper采用的是推拉结合的方式：</p>
<ol>
<li>推：服务器会推给注册了监控节点的客户端Watcher时间通知。</li>
<li>拉：客户端获得了通知后，然后主动到服务端拉取最新的数据。</li>
</ol>
<p>实现的思路如下：</p>
<ol>
<li>把配置信息写到一个znode上</li>
<li>客户端启动初始化阶段读取服务端节点的数据，并注册一个数据变更的Watcher</li>
<li>配置变更只需要对Znode数据进行set操作，数据变更的通知会发送到客户端，客户端重新获取数据，完成配置动态修改。</li>
</ol>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>&emsp;&emsp;负载均衡是一种手段，用来把对某种资源的访问分摊给不同的设备，从而减轻单点的压力。</p>
<p>实现的思路：</p>
<ol>
<li>首先建立servers节点，并建立监听器监视servers子节点的状态（用于在服务器增添时及时同步当前集群中服务器列表）</li>
<li>在每个服务器启动时，在Servers节点下面建立临时子节点Worker Server，并在对应的子节点下面存入服务器的相关信息，包括服务器的地址，ip，端口等。</li>
<li>可以自定义一个负载均衡算法，在每个请求过来时从zookeeper服务器中获取当前集群服务器列表，根据算法选出其中一个服务器来处理请求。</li>
</ol>
<h2 id="命名服务"><a href="#命名服务" class="headerlink" title="命名服务"></a>命名服务</h2><p>&emsp;&emsp;命名服务就是提供名城的服务，zookeeper的命名服务主要有两个应用方面。</p>
<ol>
<li><p>提供类JNDI功能，可以把系统中各种服务的名称、地址以及目录信息存放在zookeeper,需要的时候从zookeeper中读取。</p>
</li>
<li><p>制作分布式的序列号生成器。</p>
<p>&emsp;&emsp;利用zookeeper顺序节点的特性，制作分布式的序列号生成器，或叫做ID生成器，分布式环境下使用作为数据库ID，另一种是UUID（缺点没有规律），zookeeper可以生成有顺序的容易理解的同时支持分布式环境的编号。</p>
</li>
</ol>
<p>&emsp;&emsp;在创建节点时，如果设置节点有序的，则zookeeper会自动在你的节点名后面加上序号。</p>
<h2 id="分布式协调-通知"><a href="#分布式协调-通知" class="headerlink" title="分布式协调/通知"></a>分布式协调/通知</h2><p>&emsp;&emsp;一种典型的分布式系统机器间的通信方式是心跳。</p>
<p>&emsp;&emsp;心跳检测是指分布式环境中，不同机器之间需要检测彼此之间是否正常运行。传统的方法时通过主机之间相互ping来实现，又或者时建立TCP长连接，通过TCP连接中固有的心跳检测机制来实现上层机器间的心跳检测。</p>
<p>&emsp;&emsp;如果使用zookeeper，可以基于其临时节点的特性，不同机器在zookeeper的一个指定节点下创建临时子节点，不同机器之间可以根据这个临时节点来判断客户端机器是否存活。</p>
<p>&emsp;&emsp;好处就是检测系统和被检系统不需要直接关联，而是通过zookeeper节点来关联，大大减少系统的耦合。</p>
<h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><p>&emsp;&emsp;集群管理主要指集群监控和集群控制两个方面，前者侧重于集群运行时的状态的收集，后者则是进行集群的操作与控制。开发和运维中，面对集群，经常有如下需求：</p>
<ol>
<li>希望知道集群中究竟有多少机器在工作。</li>
<li>对集群中的每台机器的运行时状态进行数据收集。</li>
<li>对集群中的机器进行上下线的操作。</li>
</ol>
<p>&emsp;&emsp;分布式集群管理体系中，有一种传统的基于Agent的方式，就是在集群每台机器部署Agent来收集机器的CPU、内存等指标。但是如果需要深入到业务状态进行监控，比如一个分布式消息中间件中，希望监控每个消费者对消息的消费状态，或在一个分布式任务调度系统中，需要对每个机器中的任务执行情况进行监控。对这些业务紧密耦合的监控需求，统一的Agent是不太合适的。</p>
<p><strong>利用zookeeper实现集群管理监控组件的思路是：</strong></p>
<p>&emsp;&emsp;在管理机器上线/下线的场景中，为了实现自动化的线上运维，我们必须对机器的上下线情况有一个全局的监控。通常在新增机器的时候，需要首先将指定的Agent部署到这些机器上去。Agent部署启动之后，会首先向zookeeper的指定节点进行注册，具体的做法就是机器列表节点下面创建一个临时子节点。当Agent建立完这个临时子节点后，监控中心就会收到“子节点变更”的事件通知，即上线通知，于是就可以对这个新加入的机器开启相应的后台管理逻辑。另一方面，监控中心同样可以获取到机器的下线通知，这样便实现了对机器上下线的检测，同时能够很容易获取到在线的机器列表，对于大规模的扩容合容量评估都有很大帮助。</p>
<h2 id="Master选举"><a href="#Master选举" class="headerlink" title="Master选举"></a>Master选举</h2><p>&emsp;&emsp;分布式系统中Master是用来协调集群中其他系统单元，具有对分布式系统状态更改的决定权。比如一些读写分离的应用场景，客户端写请求往往是Master来实现的。</p>
<p>&emsp;&emsp;利用常见关系型数据库中的主键特性来实现也是可以的，集群中所有机器都向数据库中插入一条相同主键ID的记录，数据库会帮助我们自动进行主键冲突检查，可以保证只有一台机器能够成功。</p>
<p>&emsp;&emsp;但是有一个问题，如果插入成功的和护短机器成为Master后挂了的话，如何通知集群重新选举Master？</p>
<p>&emsp;&emsp;利用ZooKeeper创建节点API接口，提供了强一致性，能够很好保证在分布式高并发情况下节点的创建一定是全局唯一性。</p>
<p>&emsp;&emsp;集群机器都尝试创建节点，创建成功的客户端机器就会成为Master，失败的客户端机器就在该节点上注册一个Watcher用于监控当前Master机器是否存活，一旦发现Master挂了，其余客户端就可以进行选举了。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>&emsp;&emsp;分布式锁是控制分布式系统之间同步访问共享资源的一种方式。如果不同系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，一般需要通过一些互斥的手段来防止彼此之间的干扰，以保证一致性。</p>
<h3 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h3><p>&emsp;&emsp;如果事务T1对数据对象O1加上了排他锁，那么加锁期间，只允许事务T1对O1进行读取和更新操作。核心是保证当前有且仅有一个事务获得锁，并且锁释放后，所有正在等待获取锁的事务都能够被通知到。</p>
<p>通过ZooKeeper上的Znode可以表示一个锁，/x_lock/lock。</p>
<ol>
<li>获取锁，所有客户端都会通过调用create()接口尝试在/x_lock，创建临时子节点/x_lock/lock。最终只有一个客户端创建成功，那么该客户端就获取了锁。同时没有获取到锁的其他客户端，注册一个子节点变更的 Watcher 监听。</li>
<li>释放锁，获取锁的客户端发生宕机或者正常完成业务逻辑后，就会把临时节点删除。临时子节点删除后，其他客户端又开始新的一轮获取锁的过程。</li>
</ol>
<h3 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h3><p>&emsp;&emsp;如果事务T1对数据对象O1加上了共享锁，那么当前事务T1只能对O1 进行读取操作，其他事务也只能对这个数据对象加共享锁，直到数据对象上的所有共享锁都被释放。</p>
<p>通过ZooKeeper上的Znode表示一个锁，/s_lock/[HOSTNAME]-请求类型-序号。</p>
<ol>
<li>获取锁，需要获得共享锁的客户端都会在s_lock这个节点下面创建一个临时顺序节点，如果当前是读请求，就创建类型为R的临时节点，如果是写请求，就创建类型为W的临时节点。</li>
<li>判断读写顺序，共享锁下不同事务可以同时对同一个数据对象进行读取操作，而更新操作必须在当前没有任何事务进行读写操作的情况下进行。<ol>
<li>创建完节点后，获取s_lock的所有子节点，并对该节点注册子节点变更的Watcher监听。</li>
<li>然后确定自己的节点序号在所有的子节点中的顺序。</li>
<li>对于读请求，如果没有比自己小的子节点，那么表名自己已经成功获取到了共享锁，同时开始执行读取逻辑，如果有比自己序号小的写请求，那么就需要进行等待。</li>
<li>接收到Watcher通知后重复2.1。</li>
</ol>
</li>
<li>释放锁 获取锁的客户端发生宕机或者正常完成业务逻辑后，就会把临时节点删除。临时子节点删除后，其他客户端又开始新的一轮获取锁的过程。</li>
</ol>
<h3 id="羊群效应"><a href="#羊群效应" class="headerlink" title="羊群效应"></a>羊群效应</h3><p>&emsp;&emsp;在2介绍的共享锁中，在判断读写顺序的时候会出现一个问题，假如host4在移除自己的节点的时候，后面host5-7都需要接收Watcher事件通知，但是实际上，只有host5接收到事件就可以了。因此以上的实现方式会产生大量的Watcher通知。这样会对ZooKeeper服务器造成了巨大的性能影响和网络冲击，这就是羊群效应。</p>
<p>&emsp;&emsp;改进的一步在于，调用getChildren接口的时候获取到所有已经创建的子节点列表，但是这个时候不要注册任何的Watcher。当无法获取共享锁的时候，调用exist()来对比自己小的那个节点注册Wathcer。而对于读写请求，会有不同的定义:</p>
<p>&emsp;&emsp;读请求：在比自己序号小的最后一个写请求节点注册Watcher。 写请求：向比自己序号小的最后一个节点注册Watcher。</p>
<h2 id="分布式队列"><a href="#分布式队列" class="headerlink" title="分布式队列"></a>分布式队列</h2><h3 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h3><p>&emsp;&emsp;使用ZooKeeper实现FIFO队列，入队操作就是在queue_fifo 下创建自增序的子节点，并把数据（队列大小）放入节点内。出队操作就是先找到queue_fifo下序号最下的那个节点，取出数据，然后删除此节点。</p>
<p>创建完节点后，根据以下步骤确定执行顺序：</p>
<ol>
<li>通过get_chldren()接口获取/queue_fifo节点下所有子节点。</li>
<li>判断自己的节点顺序，在所有子节点中的顺序。</li>
<li>如果不是最小的子节点，那么进入等待，同时向比自己序号小的最后一个子节点注册Watcher监听。</li>
<li>接受到Watchert通知后重复1。</li>
</ol>
<h3 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h3><p>&emsp;&emsp;Barrier就是栅栏或者屏障，适用于这样的业务场景：当有些操作需要并行执行，但后续操作又需要串行执行，此时必须等待所有并行执行的线程全部结束，才开始串行，于是就需要一个屏障，来控制所有线程同时开始，并等待所有线程全部结束。</p>
<h4 id="如何控制所有线程同时开始？"><a href="#如何控制所有线程同时开始？" class="headerlink" title="如何控制所有线程同时开始？"></a>如何控制所有线程同时开始？</h4><p>&emsp;&emsp;所有的线程启动时在ZooKeeper节点/queue_barrier下插入顺序临时节点，然后检查/queue/barrier下所有children 节点的数量是否为所有的线程数，如果不是，则等待，如果是，则开始执行。具体的步骤如下：</p>
<ol>
<li>getData()获取/queue_barrier节点的数据内容。</li>
<li>getChildren()获取/queue_barrier节点下的所有子节点，同时注册对子节点列表变更的Watcher监听。</li>
<li>统计子节点的个数。</li>
<li>如果子节点个数不足10，那么进入等待。</li>
<li>接收Watcher通知后，重复2。</li>
</ol>
<h4 id="如何等待所有线程结束？"><a href="#如何等待所有线程结束？" class="headerlink" title="如何等待所有线程结束？"></a>如何等待所有线程结束？</h4><p>&emsp;&emsp;所有线程在执行完毕后，都检查/queue/barrier下所有children节点数量是否为0，若不为0，则继续等待。</p>
<h4 id="用什么类型的节点？"><a href="#用什么类型的节点？" class="headerlink" title="用什么类型的节点？"></a>用什么类型的节点？</h4><p>&emsp;&emsp;根节点使用持久节点，子节点使用临时节点，根节点为什么要用持久节点？首先因为临时节点不能有子节点，所以根节点要用持久节点，并且在程序中要判断根节点是否存在。子节点为什么要用临时节点？临时节点随着连接的断开而消失，在程序中，虽然会删除临时节点，但可能会出现程序在节点被删除之前就crash了，如果是持久节点，节点不会被删除。</p>
<hr>
<h1 id="分布式系统中的应用"><a href="#分布式系统中的应用" class="headerlink" title="分布式系统中的应用"></a>分布式系统中的应用</h1><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><p>Kafka中大部分组件都应用了zookeeper。</p>
<ol>
<li>Broker注册`/broker/ids/[0…N]记录了Broker服务器列表记录，这个临时节点的节点数据是ip端口之类的信息。</li>
<li>Topic注册/broker/topcs记录了Topic的分区信息和Broker的对应关系。</li>
<li>生产者负载均衡，生产者需要将消息发送到对应的Broker上，生产者通过Broker和Topic注册的信息，以及Broker和Topic的对应关系和变化注册事件Watcher。监听，从而实现一种动态的负载均衡机制。</li>
<li>消息消费进度Offset记录消费者对指定消息分区进行消息消费的过程中，需要定时将分区消息的消费进度Offset记录到ZooKeeper上，以便消费者进行重启或者其他消费者重新阶段该消息分区的消息消费后，能够从之前的进度开始继续系消费。</li>
</ol>
<h2 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h2><p>&emsp;&emsp;Dubbo基于ZooKeeper实现了服务注册中心。哪一个服务由哪一个机器来提供必需让调用者知道，简单来说就是ip地址和服务名称的对应关系。ZooKeeper通过心跳机制可以检测挂掉的机器并将挂掉机器的ip和服务对应关系从列表中删除。</p>
<p>&emsp;&emsp;至于支持高并发，简单来说就是横向扩展，在不更改代码的情况通过添加机器来提高运算能力。通过添加新的机器向ZooKeeper注册服务，服务的提供者多了能服务的客户就多了。</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>一致性hash</title>
    <url>/hexoblog/2021/03/26/md/%E5%88%86%E5%B8%83%E5%BC%8F/%E4%B8%80%E8%87%B4%E6%80%A7hash/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;在分布式系统中，通常不同的机器存储着不同的数据，例如redis集群中存储的数据。<br>&emsp;&emsp;这些数据通常采用hash算法来计算出应该存储在那台机器上。但是，当集群中的节点增加或者减少时，通过原有的hash算法计算出来的位置将会完全错误。<br>&emsp;&emsp;一致性hash就是为了解决这种问题诞生的。</p>
<span id="more"></span>

<hr>
<h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>&emsp;&emsp;在redis集群中，我们通常采用一致性hash算法计算数据具体分布在那一台机器上。<br>&emsp;&emsp;普通的hash算法通常采用取模的方式计算出hash结果，而当机器的数量发生变化，也就是除数发生变化时，取到的模也会发生变化，这时根据模数来定位数据存储的位置就会发生错误。<br>&emsp;&emsp;一致性hash算法也是采用取模的原理，来计算数据存储的位置。但与普通hash算法不同的是，一直性hash算法计算出来的并不是直接的位置，而是需要根据hash环查询地址。<br>&emsp;与普通hash算法不同的是，普通hash算法是对机器的数量取模，而一致性hash是对2^32取模。</p>
<h2 id="hash环"><a href="#hash环" class="headerlink" title="hash环"></a>hash环</h2><p>&emsp;&emsp;在一致性hash中，构造出一个hash环（周长数量为2^32）来标记数据位置。<br>&emsp;&emsp;由于一致性hash算法采用2^32取模，所有的取模结果都将落在构造出来的hash环上。<br>&emsp;&emsp;将所有机器分布在hash环上，机器左边的数据将存储在该机器中，而右边的数据将存储在下一台机器上。因为是环状结构，这样所有的数据都保证了有机器存储。而且，因为是环，所以当环上增加机器节点时，只有该机器节点左边的一小部分数据会发生重新分配机器。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2>]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/hexoblog/2021/03/02/md/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="分布式事务类型："><a href="#分布式事务类型：" class="headerlink" title="分布式事务类型："></a>分布式事务类型：</h1><p>分布式事务处理机制共有四种：</p>
<ol>
<li>两阶段提交</li>
<li>TCC事务（事务补偿）</li>
<li>本地消息表（异步确保），</li>
<li>MQ事务消息。</li>
</ol>
<span id="more"></span>

<h2 id="两阶段提交："><a href="#两阶段提交：" class="headerlink" title="两阶段提交："></a>两阶段提交：</h2><p>&emsp;&emsp;与数据库XA事务一样，两阶段提交使用XA协议。<br>&emsp;&emsp;两阶段提交这种方案属于牺牲了一部分可用性来换取的一致性。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>&emsp;&emsp;尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>&emsp;&emsp;实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景，如分布式系统跨接口调用。</p>
<h2 id="TCC事务："><a href="#TCC事务：" class="headerlink" title="TCC事务："></a>TCC事务：</h2><p>&emsp;&emsp;TCC其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿操作。分为三个阶段：</p>
<ol>
<li> Try阶段主要是对业务系统做检测和资源预留。</li>
<li> Confirm阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行Confirm阶段时，默认Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li>
<li> Cancel阶段主要是在业务执行错误，需要回滚的状态下，执行的业务取消，预留资源释放。</li>
</ol>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>&emsp;&emsp;跟2阶段提交比起来，实现及流程相对简单了些，但数据的一致性也要比2阶段提交要差一些。</p>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>&emsp;&emsp;在2，3步中都可能失败。TCC是一种应用层的补偿方式，需要程序员在实现时写很多补偿的代码，一些场景中，一些业务流程用TCC不太好定义及处理。</p>
<h2 id="本地消息表："><a href="#本地消息表：" class="headerlink" title="本地消息表："></a>本地消息表：</h2><p>&emsp;&emsp;使用最多的，核心思想是将分布式事务拆分成本地事务进行处理，来源于ebay。</p>
<p>基本思路就是：</p>
<p>&emsp;&emsp;消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后会经由MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。<br>&emsp;&emsp;消息消费方，需要处理这个消息，并完成这个的业务逻辑。如果此时本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。<br>&emsp;&emsp;生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息在发送一遍。<br>&emsp;&emsp;这种方案遵循最终一致性。</p>
<h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><p>&emsp;&emsp;一种非常经典的实现， 避免的分布式事务，实现了最终一致性。</p>
<h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><p>&emsp;&emsp;消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。</p>
<h2 id="MQ事务消息："><a href="#MQ事务消息：" class="headerlink" title="MQ事务消息："></a>MQ事务消息：</h2><p>&emsp;&emsp;有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但一些主流的MQ都是不支持事务消息的，如RabbitMQ和Kafka都不支持。</p>
<p>以阿里的RocketMQ为例：</p>
<p>&emsp;&emsp;第一阶段Prepared消息，会拿到消息的地址。<br>&emsp;&emsp;第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。<br>&emsp;&emsp;也就是说在业务方法内部要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了，RocketMQ会定期扫描消息集群中的事务消息，这是发现了Prepared消息，它会像消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<h3 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h3><p>&emsp;&emsp;实现了最终一致性，不需要依赖本地数据库事务。</p>
<h3 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h3><p>&emsp;&emsp;实现难度大，主流MQ不支持，RocketMQ事务消息部分代码未开源。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>acid</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/hexoblog/2021/03/02/md/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ol>
<li>解决业务层幂等性</li>
<li>解决 MQ 消费端多次接受同一消息</li>
<li>确保串行|隔离级别</li>
<li>多台机器同时执行定时任务</li>
</ol>
<h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><ol>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了，即不能误解锁。</li>
<li>具有容错性。只要大多数Redis节点正常运行，客户端就能够获取和释放锁。</li>
</ol>
<span id="more"></span>

<hr>
<h1 id="基于数据库实现分布式锁："><a href="#基于数据库实现分布式锁：" class="headerlink" title="基于数据库实现分布式锁："></a>基于数据库实现分布式锁：</h1><h2 id="基于数据库表："><a href="#基于数据库表：" class="headerlink" title="基于数据库表："></a>基于数据库表：</h2><p>&emsp;&emsp;要实现分布式锁，最简单的方法可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。<br>&emsp;&emsp;当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。</p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ol>
<li> 这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li> 这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得锁。</li>
<li> 这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li> 这把锁是非重入的，同一个线程在没有获得锁之前无法再次获得该锁。因为数据库中数据已经存在了。</li>
</ol>
<h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><ol>
<li> 数据库是单点：两个数据库，数据之间双向同步，一旦挂掉快速切换到备库。</li>
<li> 没有失效时间：定时任务，每隔一定时间清理数据库中的超时数据。</li>
<li> 非阻塞的：while循环，直到insert成功在返回。</li>
<li> 非重入的：在数据库表中加个字段，记录当前获得锁的主机信息和线程信息，下次在获取锁时先查询数据库，如果当前机器的主机信息和线程信息在数据库中可以查到的话，直接把锁分配给它就可以。</li>
</ol>
<h2 id="基于数据库排他锁："><a href="#基于数据库排他锁：" class="headerlink" title="基于数据库排他锁："></a>基于数据库排他锁：</h2><p>&emsp;&emsp;可以借助数据中自带的锁来实现分布式锁。<br>通过数据库的排他锁，基于InnoDB引擎。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>&emsp;&emsp;使用数据库来实现分布式锁，这两种方式都是依赖数据库的一张表，一种是通过表中记录的存在情况确定当前是否有锁存在，另一种是通过数据库的排他锁来实现分布式锁。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>&emsp;&emsp;直接借助数据库，容易理解。</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>&emsp;&emsp;会有各种各样的问题，在解决问题的过程中，会使整个方案变得越来越复杂。操作数据库会有一定的开销，性能问题需要考虑。使用数据库的行级锁并不一定靠谱，尤其是当我们的锁表并不大的时候。</p>
<hr>
<h1 id="基于缓存实现分布式锁："><a href="#基于缓存实现分布式锁：" class="headerlink" title="基于缓存实现分布式锁："></a>基于缓存实现分布式锁：</h1><p>&emsp;&emsp;相对于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。而且很多缓存是可以集群部署的，可以解决单点问题。<br>&emsp;&emsp;目前有很多成熟的缓存产品，Redis，memcached。</p>
<h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h3><ol>
<li> 这把锁没有失效时间，一旦解锁失败，就会导致锁记录一直在缓存中，其他线程无法再次获得锁。</li>
<li> 这把锁只能是非阻塞的，无论成功还是失败都直接返回。</li>
<li> 这把锁是非重入的，一个线程获得锁之后，在释放锁之前，无法再次获得该锁，因为key已经存在，无法进行put操作。</li>
</ol>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决:"></a>解决:</h3><ol>
<li> 没有失效时间：设置固定时间，到期后自动删除。失效时间比较难以确定，时间太短，方法没执行完释放锁，就会产生并发问题；时间太长，其他线程就要浪费很多时间。</li>
<li> 非阻塞：while重复执行。</li>
<li> 非可重入：在一个线程获取到锁之后，把当前主机信息和线程信息保存起来，下次再获取前先检查自己是不是当前锁的拥有者。</li>
</ol>
<h2 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h2><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>&emsp;&emsp;性能好，实现起来较为方便。</p>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>&emsp;&emsp;通过超时来控制锁的失效时间并不是十分的靠谱。</p>
<hr>
<h1 id="基于Zookeeper实现分布式锁："><a href="#基于Zookeeper实现分布式锁：" class="headerlink" title="基于Zookeeper实现分布式锁："></a>基于Zookeeper实现分布式锁：</h1><p>&emsp;&emsp;基于zookeeper临时有序节点可实现的分布式锁。<br>&emsp;&emsp;大致思想为：每个客户端对每个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生死锁的问题。</p>
<h2 id="如何解决前面的问题："><a href="#如何解决前面的问题：" class="headerlink" title="如何解决前面的问题："></a>如何解决前面的问题：</h2><h3 id="锁无法释放："><a href="#锁无法释放：" class="headerlink" title="锁无法释放："></a>锁无法释放：</h3><p>&emsp;&emsp;使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建的时候，客户端会在zk中创建一个临时节点，一旦客户端获取到锁之后突然挂掉，那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</p>
<h3 id="非阻塞锁："><a href="#非阻塞锁：" class="headerlink" title="非阻塞锁："></a>非阻塞锁：</h3><p>&emsp;&emsp;使用zookeeper可以实现阻塞的锁，客户端可通过在zk中创建顺序节点，并在节点上绑定监听器，一旦节点有变化，zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑。</p>
<h3 id="不可重入："><a href="#不可重入：" class="headerlink" title="不可重入："></a>不可重入：</h3><p>&emsp;&emsp;使用zookeeper可以有效解决不可重入的问题，客户端在创建节点时，把当前客户端的主机信息和线程信息直接写入节点中，下次想要获取锁的时候和当前最小节点中的数据对比一下就可以。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就在创建一个临时的顺序节点，参与排队。</p>
<h3 id="单点问题："><a href="#单点问题：" class="headerlink" title="单点问题："></a>单点问题：</h3><p>&emsp;&emsp;使用zookeeper可以有效解决单点问题，zk是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</p>
<p>&emsp;&emsp;使用zk实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务器那么高。因为在每次创建锁和释放锁的过程中，都要动态创建，销毁瞬时节点来实现锁功能。zk中创建和删除节点只能通过leader服务器来执行，然后将数据同步到所有follower机器上。<br>&emsp;&emsp;使用了zk也有可能带来并发问题，只是不常见。由于网络抖动，客户端集群的session连接断了，那么zk以为客户端挂了，就会删除临时节点，这是其他客户端就可以获取到分布式锁了。就可能产生并发问题。这个问题不常见是因为zk有重试机制，一旦zk集群检测不到客户端的心跳，就会重试，多次重试还不行的话就会删除临时节点。</p>
<h2 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h2><h3 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h3><p>&emsp;&emsp;有效的解决单点问题，不可重入问题，非阻塞问题，以及锁无法释放的问题。实现起来较为简单。</p>
<h3 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h3><p>&emsp;&emsp;性能上不如缓存实现分布式锁。需要最zk的原理有所了解。</p>
<hr>
<h1 id="比较："><a href="#比较：" class="headerlink" title="比较："></a>比较：</h1><h3 id="理解程度："><a href="#理解程度：" class="headerlink" title="理解程度："></a>理解程度：</h3><p>数据库&gt;缓存&gt;Zookeeper</p>
<h3 id="实现的复杂性角度："><a href="#实现的复杂性角度：" class="headerlink" title="实现的复杂性角度："></a>实现的复杂性角度：</h3><p>Zookeeper&gt;=缓存&gt;数据库</p>
<h3 id="性能角度："><a href="#性能角度：" class="headerlink" title="性能角度："></a>性能角度：</h3><p>缓存&gt;Zookeeper&gt;=数据库</p>
<h3 id="可靠性角度："><a href="#可靠性角度：" class="headerlink" title="可靠性角度："></a>可靠性角度：</h3><p>Zookeeper&gt;缓存&gt;数据库</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo服务启动暴露过程</title>
    <url>/hexoblog/2021/04/21/md/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%9A%B4%E9%9C%B2%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="服务启动暴露过程"><a href="#服务启动暴露过程" class="headerlink" title="服务启动暴露过程"></a>服务启动暴露过程</h1><p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%9A%B4%E9%9C%B2%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B">服务提供者暴露一个服务的详细过程</a></p>
<span id="more"></span>

<h2 id="服务暴露时序图"><a href="#服务暴露时序图" class="headerlink" title="服务暴露时序图"></a>服务暴露时序图</h2><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/dubbo-export.jpg" alt="暴露时序图"></p>
<h2 id="自定义标签的解析"><a href="#自定义标签的解析" class="headerlink" title="自定义标签的解析"></a>自定义标签的解析</h2><p>&emsp;&emsp;通常在项目启动的过程中，我们会将dubbo的配置文件写入spring的配置文件中。</p>
<p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1">解析服务</a></p>
<blockquote>
<p>&emsp;&emsp;基于 dubbo.jar 内的 META-INF/spring.handlers 配置，Spring 在遇到 dubbo 名称空间时，会回调 DubboNamespaceHandler。<br>&emsp;&emsp;所有 dubbo 的标签，都统一用 DubboBeanDefinitionParser 进行解析，基于一对一属性映射，将 XML 标签解析为 Bean 对象。  </p>
</blockquote>
<p>&emsp;&emsp;根据官方文档，在spring启动过程中，碰到dubbo开头的标签，会由<code>DubboNamespaceHandler</code>处理。这里也是基于spring自定义标签，的扩展机制。</p>
<p>&emsp;&emsp;META-INF/spring.schemas文件。定义dubbo.xml文件格式，约束。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http\:<span class="regexp">//</span>dubbo.apache.org<span class="regexp">/schema/</span>dubbo<span class="regexp">/dubbo.xsd=META-INF/</span>dubbo.xsd</span><br><span class="line">http\:<span class="regexp">//</span>code.alibabatech.com<span class="regexp">/schema/</span>dubbo<span class="regexp">/dubbo.xsd=META-INF/</span>compat/dubbo.xsd</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;META-INF/spring.handlers文件，定义了xml文件的命名空间处理器，负责解析dubbo.xml。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">http\:<span class="regexp">//</span>dubbo.apache.org<span class="regexp">/schema/</span>dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler</span><br><span class="line">http\:<span class="regexp">//</span>code.alibabatech.com<span class="regexp">/schema/</span>dubbo=org.apache.dubbo.config.spring.schema.DubboNamespaceHandler</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;命名空间处理器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;application&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;module&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ModuleConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;registry&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(RegistryConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;config-center&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConfigCenterBean.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;metadata-report&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MetadataReportConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;monitor&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(MonitorConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;provider&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProviderConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;consumer&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;protocol&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;service&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ServiceBean.class, <span class="keyword">true</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;reference&quot;</span>, <span class="keyword">new</span> DubboBeanDefinitionParser(ReferenceBean.class, <span class="keyword">false</span>));</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;annotation&quot;</span>, <span class="keyword">new</span> AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;遇到不同的标签会交由不同的处理器（Parser）进行处理。</p>
<h2 id="服务注册与暴露"><a href="#服务注册与暴露" class="headerlink" title="服务注册与暴露"></a>服务注册与暴露</h2><p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1">暴露服务</a></p>
<blockquote>
<p>&emsp;&emsp;在 ServiceConfig.export() 或 ReferenceConfig.get() 初始化时，将 Bean 对象转换 URL 格式，所有 Bean 属性转成 URL 的参数。<br>&emsp;&emsp;然后将 URL 传给 协议扩展点，基于扩展点的 扩展点自适应机制，根据 URL 的协议头，进行不同协议的服务暴露或引用。</p>
</blockquote>
<p>&emsp;&emsp;基于上面解析的结果，会在spring容器中生成对应的ServiceBean实例，这个bean实现了很多方法，初始化，销毁等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;而在spring初始化完成bean的组装后会调用InitializingBean的afterPropertiesSet方法。<br>&emsp;&emsp;在spring容器完成加载，会接收到ContextRefreshedEvent事件，调用ApplicationListener的onApplicationEvent方法。<br>&emsp;&emsp;这两个方法中会调用export方法，间接调用ServiceConfig中的export方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;deprecation&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="comment">// 省略一堆流程</span></span><br><span class="line">    <span class="keyword">if</span> (!supportedApplicationListener) &#123;</span><br><span class="line">        export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;The service ready on spring started. service: &quot;</span> + getInterface());</span><br><span class="line">        &#125;</span><br><span class="line">        export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;ServiceConfig的export方法中。调用了本地的doExport方法。在这里如果发现有延迟属性（delay），则延迟时间暴露服务，如果没有就直接暴露服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!shouldExport()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldDelay()) &#123;</span><br><span class="line">        delayExportExecutor.schedule(<span class="keyword">this</span>::doExport, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doExport();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;ServiceConfig的doExport方法中。调用了本地的doExportUrls方法，紧接着就调用了doExportUrlsFor1Protocol方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doExport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unexported) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; has already unexported!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (exported) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exported = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(path)) &#123;</span><br><span class="line">        path = interfaceName;</span><br><span class="line">    &#125;</span><br><span class="line">    doExportUrls();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;URL&gt; registryURLs = loadRegistries(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">for</span> (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">        String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), group, version);</span><br><span class="line">        ProviderModel providerModel = <span class="keyword">new</span> ProviderModel(pathKey, ref, interfaceClass);</span><br><span class="line">        ApplicationModel.initProviderModel(pathKey, providerModel);</span><br><span class="line">        doExportUrlsFor1Protocol(protocolConfig, registryURLs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在doExportUrls中，按照不同的Protocol暴露服务，在不同的zookeeper上集群上注册自己的服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> </span>&#123;</span><br><span class="line">    String name = protocolConfig.getName();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        name = Constants.DUBBO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">    appendRuntimeParameters(map);</span><br><span class="line">    appendParameters(map, application);</span><br><span class="line">    appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">    appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">    appendParameters(map, protocolConfig);</span><br><span class="line">    appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methods)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MethodConfig method : methods) &#123;</span><br><span class="line">            appendParameters(map, method, method.getName());</span><br><span class="line">            String retryKey = method.getName() + <span class="string">&quot;.retry&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">                String retryValue = map.remove(retryKey);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;false&quot;</span>.equals(retryValue)) &#123;</span><br><span class="line">                    map.put(method.getName() + <span class="string">&quot;.retries&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ArgumentConfig&gt; arguments = method.getArguments();</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(arguments)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">                    <span class="comment">// convert argument type</span></span><br><span class="line">                    <span class="keyword">if</span> (argument.getType() != <span class="keyword">null</span> &amp;&amp; argument.getType().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Method[] methods = interfaceClass.getMethods();</span><br><span class="line">                        <span class="comment">// visit all methods</span></span><br><span class="line">                        <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                String methodName = methods[i].getName();</span><br><span class="line">                                <span class="comment">// target the method, and get its signature</span></span><br><span class="line">                                <span class="keyword">if</span> (methodName.equals(method.getName())) &#123;</span><br><span class="line">                                    Class&lt;?&gt;[] argtypes = methods[i].getParameterTypes();</span><br><span class="line">                                    <span class="comment">// one callback in the method</span></span><br><span class="line">                                    <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                                        <span class="keyword">if</span> (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                            appendParameters(map, argument, method.getName() + <span class="string">&quot;.&quot;</span> + argument.getIndex());</span><br><span class="line">                                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Argument config error : the index attribute and type attribute not match :index :&quot;</span> + argument.getIndex() + <span class="string">&quot;, type:&quot;</span> + argument.getType());</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        <span class="comment">// multiple callbacks in the method</span></span><br><span class="line">                                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                            Class&lt;?&gt; argclazz = argtypes[j];</span><br><span class="line">                                            <span class="keyword">if</span> (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                appendParameters(map, argument, method.getName() + <span class="string">&quot;.&quot;</span> + j);</span><br><span class="line">                                                <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span> &amp;&amp; argument.getIndex() != j) &#123;</span><br><span class="line">                                                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Argument config error : the index attribute and type attribute not match :index :&quot;</span> + argument.getIndex() + <span class="string">&quot;, type:&quot;</span> + argument.getType());</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argument.getIndex() != -<span class="number">1</span>) &#123;</span><br><span class="line">                        appendParameters(map, argument, method.getName() + <span class="string">&quot;.&quot;</span> + argument.getIndex());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Argument config must set index or type attribute.eg: &lt;dubbo:argument index=&#x27;0&#x27; .../&gt; or &lt;dubbo:argument type=xxx .../&gt;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end of methods for</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">        map.put(Constants.GENERIC_KEY, generic);</span><br><span class="line">        map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">        <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            map.put(<span class="string">&quot;revision&quot;</span>, revision);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">        <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;No method found in service interface &quot;</span> + interfaceClass.getName());</span><br><span class="line">            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(Constants.METHODS_KEY, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">&quot;,&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(Constants.TOKEN_KEY, token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// export service</span></span><br><span class="line">    String host = <span class="keyword">this</span>.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">    Integer port = <span class="keyword">this</span>.findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">            .hasExtension(url.getProtocol())) &#123;</span><br><span class="line">        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)</span><br><span class="line">                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String scope = url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">    <span class="comment">// don&#x27;t export when none is configured</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// export to local if the config is not remote (export to remote only when config is remote)</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            exportLocal(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// export to remote if the config is not local (export to local only when config is local)</span></span><br><span class="line">        <span class="keyword">if</span> (!Constants.SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line">                    URL monitorUrl = loadMonitor(registryURL);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(<span class="string">&quot;Register dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; url &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + registryURL);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                    String proxy = url.getParameter(Constants.PROXY_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</span><br><span class="line">                    DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                DelegateProviderMetaDataInvoker wrapperInvoker = <span class="keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                exporters.add(exporter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">                * ServiceData Store</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            MetadataReportService metadataReportService = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                metadataReportService.publishProvider(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里采用一个map保存下来所有的url参数和value值，然后调用代理工厂根据ref（实际服务提供对象）获取invoker对象（接口的代理对象），在使用protocol转为exporter，将服务暴露出去。<br>&emsp;&emsp;代理工厂采用SPI机制来搞，可以选择代理方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">stub=org<span class="selector-class">.apache</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.proxy</span><span class="selector-class">.wrapper</span>.StubProxyFactoryWrapper</span><br><span class="line">jdk=org<span class="selector-class">.apache</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.proxy</span><span class="selector-class">.jdk</span>.JdkProxyFactory</span><br><span class="line">javassist=org<span class="selector-class">.apache</span><span class="selector-class">.dubbo</span><span class="selector-class">.rpc</span><span class="selector-class">.proxy</span><span class="selector-class">.javassist</span>.JavassistProxyFactory</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里使用了SPI机制去确定使用那个协议对应的protocol。这里采用了很多的SPI机制，自适应，自动包装。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure>

<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">filter</span>=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class="line"><span class="attribute">listener</span>=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br><span class="line"></span><br><span class="line"><span class="attribute">mock</span>=org.apache.dubbo.rpc.support.MockProtocol</span><br><span class="line"><span class="attribute">dubbo</span>=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol</span><br><span class="line"><span class="attribute">injvm</span>=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocol</span><br><span class="line"><span class="attribute">rmi</span>=org.apache.dubbo.rpc.protocol.rmi.RmiProtocol</span><br><span class="line"><span class="attribute">hessian</span>=org.apache.dubbo.rpc.protocol.hessian.HessianProtocol</span><br><span class="line"><span class="attribute">http</span>=org.apache.dubbo.rpc.protocol.http.HttpProtocol</span><br><span class="line"></span><br><span class="line">org.apache.dubbo.rpc.protocol.webservice.WebServiceProtocol</span><br><span class="line"><span class="attribute">thrift</span>=org.apache.dubbo.rpc.protocol.thrift.ThriftProtocol</span><br><span class="line"><span class="attribute">memcached</span>=org.apache.dubbo.rpc.protocol.memcached.MemcachedProtocol</span><br><span class="line"><span class="attribute">redis</span>=org.apache.dubbo.rpc.protocol.redis.RedisProtocol</span><br><span class="line"><span class="attribute">rest</span>=org.apache.dubbo.rpc.protocol.rest.RestProtocol</span><br><span class="line"><span class="attribute">registry</span>=org.apache.dubbo.registry.integration.RegistryProtocol</span><br><span class="line"></span><br><span class="line"><span class="attribute">qos</span>=org.apache.dubbo.qos.protocol.QosProtocolWrapper</span><br></pre></td></tr></table></figure>

<h3 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h3><p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#1-%E5%8F%AA%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%A3">只暴露服务端口</a></p>
<p>&emsp;&emsp;当在本地暴露服务时，默认会进入DubboProtocol，也可以配置其他协议。在DubboProtocol中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL url = invoker.getUrl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// export service.</span></span><br><span class="line">    String key = serviceKey(url);</span><br><span class="line">    DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">    exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//export an stub service for dispatching event</span></span><br><span class="line">    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);</span><br><span class="line">    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;</span><br><span class="line">        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">        <span class="keyword">if</span> (stubServiceMethods == <span class="keyword">null</span> || stubServiceMethods.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;consumer [&quot;</span> + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                        <span class="string">&quot;], has set stubproxy support event ,but no stub methods founded.&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    openServer(url);</span><br><span class="line">    optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exporter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;export方法调用openServer方法开启服务，如果服务不存在就创建一个服务。这里默认是netty服务，也可以通过SPI使用其他的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// find server.</span></span><br><span class="line">    String key = url.getAddress();</span><br><span class="line">    <span class="comment">//client can export a service which&#x27;s only for server to invoke</span></span><br><span class="line">    <span class="keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">        ExchangeServer server = serverMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                server = serverMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    serverMap.put(key, createServer(url));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// server supports reset, use together with override</span></span><br><span class="line">            server.reset(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ExchangeServer <span class="title">createServer</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    url = URLBuilder.from(url)</span><br><span class="line">            <span class="comment">// send readonly event when server closes, it&#x27;s enabled by default</span></span><br><span class="line">            .addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())</span><br><span class="line">            <span class="comment">// enable heartbeat by default</span></span><br><span class="line">            .addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT))</span><br><span class="line">            .addParameter(Constants.CODEC_KEY, DubboCodec.NAME)</span><br><span class="line">            .build();</span><br><span class="line">    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Unsupported server type: &quot;</span> + str + <span class="string">&quot;, url: &quot;</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ExchangeServer server;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        server = Exchangers.bind(url, requestHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Fail to start server(url: &quot;</span> + url + <span class="string">&quot;) &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str = url.getParameter(Constants.CLIENT_KEY);</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">        <span class="keyword">if</span> (!supportedTypes.contains(str)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Unsupported client type: &quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;而在headerExchanger的bind中，调用了Transporters.bind()，一直调用到NettyServer,绑定了端口和链接。而消费的时候则是一直调用connect方法建立连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;handler == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">&quot;exchange&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取Exchanger，这里有SPI（基本使用）但是只有HeaderExchanger一个实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class="line">    <span class="keyword">return</span> getExchanger(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(HeaderExchanger.NAME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Exchanger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * bind.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message server</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.EXCHANGER_KEY&#125;)</span></span><br><span class="line">    <span class="function">ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * connect.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> message channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.EXCHANGER_KEY&#125;)</span></span><br><span class="line">    <span class="function">ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Exchanger只有HeaderExchanger一个实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchanger</span> <span class="keyword">implements</span> <span class="title">Exchanger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;header&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeClient <span class="title">connect</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeClient(Transporters.connect(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))), <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;HeaderExchanger中调用了Transporters的bind方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Transporters</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;url == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;handlers == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelHandler handler;</span><br><span class="line">    <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        handler = handlers[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transporter <span class="title">getTransporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里也采用SPI机制（扩展点自适应）选择使用的底层框架。默认是netty创建服务。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">netty3=org.apache.dubbo.remoting.transport.netty.NettyTransporter</span><br><span class="line">netty4=org.apache.dubbo.remoting.transport.netty4.NettyTransporter</span><br><span class="line">netty=org.apache.dubbo.remoting.transport.netty4.NettyTransporter</span><br><span class="line">mina=org.apache.dubbo.remoting.transport.mina.MinaTransporter</span><br><span class="line">grizzly=org.apache.dubbo.remoting.transport.grizzly.GrizzlyTransporter</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SPI(&quot;netty&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bind a server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     server url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> server</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.apache.dubbo.remoting.Transporters#bind(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span></span><br><span class="line">    <span class="function">Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Connect to a server.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url     server url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> handler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> client</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RemotingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.apache.dubbo.remoting.Transporters#connect(URL, ChannelHandler...)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span></span><br><span class="line">    <span class="function">Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyTransporter</span> <span class="keyword">implements</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String NAME = <span class="string">&quot;netty3&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyServer(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler listener)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NettyClient(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="远程暴露"><a href="#远程暴露" class="headerlink" title="远程暴露"></a>远程暴露</h3><p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#2-%E5%90%91%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1">向注册中心暴露服务</a></p>
<p>&emsp;&emsp;这里有了在本地暴露的流程，远程暴露的流程呢？<br>&emsp;&emsp;在上面根据扩展点自动选择协议时，有扩展点自动包装的扩展类，ProtocolFilterWrapper，ProtocolListenerWrapper，QosProtocolWrapper。<br>&emsp;&emsp;在ProtocolFilterWrapper和ProtocolListenerWrapper中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProtocolFilterWrapper</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProtocolListenerWrapper</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;</span><br><span class="line">        <span class="keyword">return</span> protocol.export(invoker);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListenerExporterWrapper&lt;T&gt;(protocol.export(invoker),</span><br><span class="line">            Collections.unmodifiableList(ExtensionLoader.getExtensionLoader(ExporterListener.class)</span><br><span class="line">                    .getActivateExtension(invoker.getUrl(), Constants.EXPORTER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里如果是远程暴露是时，将会直接进入REGISTRY_PROTOCOL中，进行远程注册。在RegistryProtocol中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    URL registryUrl = getRegistryUrl(originInvoker);</span><br><span class="line">    <span class="comment">// url to export locally</span></span><br><span class="line">    URL providerUrl = getProviderUrl(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Subscribe the override data</span></span><br><span class="line">    <span class="comment">// FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call</span></span><br><span class="line">    <span class="comment">//  the same service. Because the subscribed is cached key with the name of the service, it causes the</span></span><br><span class="line">    <span class="comment">//  subscription information to cover.</span></span><br><span class="line">    <span class="comment">// 订阅override数据</span></span><br><span class="line">    <span class="comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，</span></span><br><span class="line">    <span class="comment">// 因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span></span><br><span class="line">    <span class="keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);</span><br><span class="line">    <span class="keyword">final</span> OverrideListener overrideSubscribeListener = <span class="keyword">new</span> OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">    providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//export invoker</span></span><br><span class="line">    <span class="comment">// 在本地暴露服务</span></span><br><span class="line">    <span class="keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// url to registry</span></span><br><span class="line">    <span class="comment">// 拿到zookeeper的注册信息</span></span><br><span class="line">    <span class="keyword">final</span> Registry registry = getRegistry(originInvoker);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取需要暴露provider的url对象，dubbo的注册订阅通信都是以url作为参数传递的</span></span><br><span class="line">    <span class="keyword">final</span> URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl);</span><br><span class="line">    ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker,</span><br><span class="line">            registryUrl, registeredProviderUrl);</span><br><span class="line">    <span class="comment">//to judge if we need to delay publish</span></span><br><span class="line">    <span class="keyword">boolean</span> register = registeredProviderUrl.getParameter(<span class="string">&quot;register&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (register) &#123;</span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        register(registryUrl, registeredProviderUrl);</span><br><span class="line">        providerInvokerWrapper.setReg(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deprecated! Subscribe to override rules in 2.6.x or before.</span></span><br><span class="line">    <span class="comment">// 暴露的同时订阅服务，另外会在zk上创建configurators节点信息</span></span><br><span class="line">    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line"></span><br><span class="line">    exporter.setRegisterUrl(registeredProviderUrl);</span><br><span class="line">    exporter.setSubscribeUrl(overrideSubscribeUrl);</span><br><span class="line">    <span class="comment">//Ensure that a new exporter instance is returned every time export</span></span><br><span class="line">    <span class="comment">// 保证每次export都返回一个新的exporter实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DestroyableExporter&lt;&gt;(exporter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registeredProviderUrl)</span> </span>&#123;</span><br><span class="line">    Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">    registry.register(registeredProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里经过AbstractRegistry，FailbackRegistry，到了ZookeeperRegistry，调用了doRegister方法，在zk上注册节点，注册完成。这里也可以不选择zk，也可以有其他的注册位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Failed to register &quot;</span> + url + <span class="string">&quot; to zookeeper &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo服务引入流程</title>
    <url>/hexoblog/2021/04/22/md/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="服务引入流程"><a href="#服务引入流程" class="headerlink" title="服务引入流程"></a>服务引入流程</h1><p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#%E6%9C%8D%E5%8A%A1%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B">服务消费者消费一个服务的详细过程 </a></p>
<span id="more"></span>

<h2 id="服务引入时序图"><a href="#服务引入时序图" class="headerlink" title="服务引入时序图"></a>服务引入时序图</h2><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/dubbo-refer.jpg" alt="服务引入时序图"></p>
<h2 id="服务发现与引入"><a href="#服务发现与引入" class="headerlink" title="服务发现与引入"></a>服务发现与引入</h2><p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1">引用服务</a></p>
<p>&emsp;&emsp;服务发现与引入的流程与暴露流程相似，只是经过标签初始化后，采用的是ReferenceBean对象，而服务暴露采用的是ServiceBean对象。<br>&emsp;&emsp;与暴露过程中相同，spring初始化完成bean的组装后会调用InitializingBean的afterPropertiesSet方法。<br>&emsp;&emsp;这个方法中会调用getObject方法，继续调用get方法，进入ReferenceConfig对象的init方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReferenceBean</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="comment">// 省略一堆流程</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (shouldInit()) &#123;</span><br><span class="line">          getObject();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     checkAndUpdateSubConfigs();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;The invoker of ReferenceConfig(&quot;</span> + url + <span class="string">&quot;) has already destroyed!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (ref == <span class="keyword">null</span>) &#123;</span><br><span class="line">          init();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ref;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在ReferenceConfig的init方法中对参数进行组装，紧接者就会调用createProxy方法创建代理对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReferenceConfig</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initialized) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     initialized = <span class="keyword">true</span>;</span><br><span class="line">     checkStubAndLocal(interfaceClass);</span><br><span class="line">     checkMock(interfaceClass);</span><br><span class="line">     Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">     map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);</span><br><span class="line">     appendRuntimeParameters(map);</span><br><span class="line">     <span class="keyword">if</span> (!isGeneric()) &#123;</span><br><span class="line">          String revision = Version.getVersion(interfaceClass, version);</span><br><span class="line">          <span class="keyword">if</span> (revision != <span class="keyword">null</span> &amp;&amp; revision.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               map.put(<span class="string">&quot;revision&quot;</span>, revision);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">          <span class="keyword">if</span> (methods.length == <span class="number">0</span>) &#123;</span><br><span class="line">               logger.warn(<span class="string">&quot;No method found in service interface &quot;</span> + interfaceClass.getName());</span><br><span class="line">               map.put(<span class="string">&quot;methods&quot;</span>, Constants.ANY_VALUE);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               map.put(<span class="string">&quot;methods&quot;</span>, StringUtils.join(<span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(methods)), <span class="string">&quot;,&quot;</span>));</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     map.put(Constants.INTERFACE_KEY, interfaceName);</span><br><span class="line">     appendParameters(map, application);</span><br><span class="line">     appendParameters(map, <span class="keyword">module</span>);</span><br><span class="line">     appendParameters(map, consumer, Constants.DEFAULT_KEY);</span><br><span class="line">     appendParameters(map, <span class="keyword">this</span>);</span><br><span class="line">     Map&lt;String, Object&gt; attributes = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> (CollectionUtils.isNotEmpty(methods)) &#123;</span><br><span class="line">          attributes = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">          <span class="keyword">for</span> (MethodConfig methodConfig : methods) &#123;</span><br><span class="line">               appendParameters(map, methodConfig, methodConfig.getName());</span><br><span class="line">               String retryKey = methodConfig.getName() + <span class="string">&quot;.retry&quot;</span>;</span><br><span class="line">               <span class="keyword">if</span> (map.containsKey(retryKey)) &#123;</span><br><span class="line">               String retryValue = map.remove(retryKey);</span><br><span class="line">               <span class="keyword">if</span> (<span class="string">&quot;false&quot;</span>.equals(retryValue)) &#123;</span><br><span class="line">                    map.put(methodConfig.getName() + <span class="string">&quot;.retries&quot;</span>, <span class="string">&quot;0&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               attributes.put(methodConfig.getName(), convertMethodConfig2AyncInfo(methodConfig));</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);</span><br><span class="line">     <span class="keyword">if</span> (StringUtils.isEmpty(hostToRegistry)) &#123;</span><br><span class="line">          hostToRegistry = NetUtils.getLocalHost();</span><br><span class="line">     &#125;</span><br><span class="line">     map.put(Constants.REGISTER_IP_KEY, hostToRegistry);</span><br><span class="line"></span><br><span class="line">     ref = createProxy(map);</span><br><span class="line"></span><br><span class="line">     String serviceKey = URL.buildKey(interfaceName, group, version);</span><br><span class="line">     ApplicationModel.initConsumerModel(serviceKey, buildConsumerModel(serviceKey, attributes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;createProxy方法中，会进行根据SPI机制选择不同的Protocol进行服务的发现与引入，获得invoker对象，然后对获取到的invoker对象创建代理并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (shouldJvmRefer(map)) &#123;</span><br><span class="line">          URL url = <span class="keyword">new</span> URL(Constants.LOCAL_PROTOCOL, Constants.LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">          invoker = refprotocol.refer(interfaceClass, url);</span><br><span class="line">          <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">&quot;Using injvm service &quot;</span> + interfaceClass.getName());</span><br><span class="line">          &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (url != <span class="keyword">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; <span class="comment">// user specified URL, could be peer-to-peer address, or register center&#x27;s address.</span></span><br><span class="line">               String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">               <span class="keyword">if</span> (us != <span class="keyword">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                    URL url = URL.valueOf(u);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                         url = url.setPath(interfaceName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                         urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                         urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">// assemble URL from register center&#x27;s configuration</span></span><br><span class="line">               checkRegistry();</span><br><span class="line">               List&lt;URL&gt; us = loadRegistries(<span class="keyword">false</span>);</span><br><span class="line">               <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">               <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                    URL monitorUrl = loadMonitor(u);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (urls.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No such any registry to reference &quot;</span> + interfaceName + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion() + <span class="string">&quot;, please config &lt;dubbo:registry address=\&quot;...\&quot; /&gt; to your spring config.&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">               invoker = refprotocol.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">               URL registryURL = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">               invokers.add(refprotocol.refer(interfaceClass, url));</span><br><span class="line">               <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                    registryURL = url; <span class="comment">// use last registry url</span></span><br><span class="line">               &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (registryURL != <span class="keyword">null</span>) &#123; <span class="comment">// registry url is available</span></span><br><span class="line">               <span class="comment">// use RegistryAwareCluster only when register&#x27;s cluster is available</span></span><br><span class="line">               URL u = registryURL.addParameter(Constants.CLUSTER_KEY, RegistryAwareCluster.NAME);</span><br><span class="line">               <span class="comment">// The invoker wrap relation would be: RegistryAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, will execute route) -&gt; Invoker</span></span><br><span class="line">               invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(u, invokers));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123; <span class="comment">// not a registry url, must be direct invoke.</span></span><br><span class="line">               invoker = cluster.join(<span class="keyword">new</span> StaticDirectory(invokers));</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (shouldCheck() &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">          <span class="comment">// make it possible for consumer to retry later if provider is temporarily unavailable</span></span><br><span class="line">          initialized = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Failed to check the status of the service &quot;</span> + interfaceName + <span class="string">&quot;. No provider available for the service &quot;</span> + (group == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : group + <span class="string">&quot;/&quot;</span>) + interfaceName + (version == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;:&quot;</span> + version) + <span class="string">&quot; from the url &quot;</span> + invoker.getUrl() + <span class="string">&quot; to the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(<span class="string">&quot;Refer dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; from url &quot;</span> + invoker.getUrl());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">     * ServiceData Store</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     MetadataReportService metadataReportService = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">if</span> ((metadataReportService = getMetadataReportService()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">          URL consumerURL = <span class="keyword">new</span> URL(Constants.CONSUMER_PROTOCOL, map.remove(Constants.REGISTER_IP_KEY), <span class="number">0</span>, map.get(Constants.INTERFACE_KEY), map);</span><br><span class="line">          metadataReportService.publishConsumer(consumerURL);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// create service proxy</span></span><br><span class="line">     <span class="keyword">return</span> (T) proxyFactory.getProxy(invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在Protocol层中，也根据SPI机制选择对应的Protocol实现服务调用。</p>
<h3 id="直连引用服务"><a href="#直连引用服务" class="headerlink" title="直连引用服务"></a>直连引用服务</h3><p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#1-%E7%9B%B4%E8%BF%9E%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1">直连引用服务</a></p>
<p>&emsp;&emsp;当在本地直连引用服务时，默认会进入DubboProtocol，也可以配置其他协议。暴露时进入的入口为export方法，引入的入口就是refer。这里会直接返回提供者的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">     optimizeSerialization(url);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// create rpc invoker.</span></span><br><span class="line">     DubboInvoker&lt;T&gt; invoker = <span class="keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);</span><br><span class="line">     invokers.add(invoker);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里会调用getClients方法，进而调用initClient方法建立连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ExchangeClient[] getClients(URL url) &#123;</span><br><span class="line">     <span class="comment">// whether to share connection</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> useShareConnect = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span> connections = url.getParameter(Constants.CONNECTIONS_KEY, <span class="number">0</span>);</span><br><span class="line">     List&lt;ReferenceCountExchangeClient&gt; shareClients = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// if not configured, connection is shared, otherwise, one connection for one service</span></span><br><span class="line">     <span class="keyword">if</span> (connections == <span class="number">0</span>) &#123;</span><br><span class="line">          useShareConnect = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * The xml configuration should have a higher priority than properties.</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">          String shareConnectionsStr = url.getParameter(Constants.SHARE_CONNECTIONS_KEY, (String) <span class="keyword">null</span>);</span><br><span class="line">          connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(Constants.SHARE_CONNECTIONS_KEY,</span><br><span class="line">               Constants.DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr);</span><br><span class="line">          shareClients = getSharedClient(url, connections);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ExchangeClient[] clients = <span class="keyword">new</span> ExchangeClient[connections];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clients.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (useShareConnect) &#123;</span><br><span class="line">               clients[i] = shareClients.get(i);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               clients[i] = initClient(url);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> clients;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ExchangeClient <span class="title">initClient</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// client type setting.</span></span><br><span class="line">     String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));</span><br><span class="line"></span><br><span class="line">     url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);</span><br><span class="line">     <span class="comment">// enable heartbeat by default</span></span><br><span class="line">     url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// BIO is not allowed since it has severe performance issue.</span></span><br><span class="line">     <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span> &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Unsupported client type: &quot;</span> + str + <span class="string">&quot;,&quot;</span> +</span><br><span class="line">               <span class="string">&quot; supported client type is &quot;</span> + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), <span class="string">&quot; &quot;</span>));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ExchangeClient client;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// connection should be lazy</span></span><br><span class="line">          <span class="keyword">if</span> (url.getParameter(Constants.LAZY_CONNECT_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">               client = <span class="keyword">new</span> LazyConnectExchangeClient(url, requestHandler);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               client = Exchangers.connect(url, requestHandler);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Fail to create remoting client for service(&quot;</span> + url + <span class="string">&quot;): &quot;</span> + e.getMessage(), e);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接下来的流程与服务暴露相似，不同在于，暴露是一层一层通过bind方法暴露出去，而消费方是一层层通过connect方法建立netty连接。</p>
<h3 id="从注册中心发现引用服务"><a href="#从注册中心发现引用服务" class="headerlink" title="从注册中心发现引用服务"></a>从注册中心发现引用服务</h3><p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#2-%E4%BB%8E%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8F%91%E7%8E%B0%E5%BC%95%E7%94%A8%E6%9C%8D%E5%8A%A1">从注册中心发现引用服务</a></p>
<p>&emsp;&emsp;与暴露过程中相似，在调用Protocol获取invoker(提供者的引用)时，也会使用到SPI机制，ProtocolFilterWrapper和ProtocolListenerWrapper中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProtocolFilterWrapper</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">          <span class="keyword">return</span> protocol.refer(type, url);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> buildInvokerChain(protocol.refer(type, url), Constants.REFERENCE_FILTER_KEY, Constants.CONSUMER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ProtocolListenerWrapper</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">          <span class="keyword">return</span> protocol.refer(type, url);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ListenerInvokerWrapper&lt;T&gt;(protocol.refer(type, url),</span><br><span class="line">               Collections.unmodifiableList(</span><br><span class="line">                    ExtensionLoader.getExtensionLoader(InvokerListener.class)</span><br><span class="line">                              .getActivateExtension(url, Constants.INVOKER_LISTENER_KEY)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;与暴露过程相同，这里如果发现是需要去注册中心获取服务，会直接进入RegistryProtocol中获取服务引用，在RegistryProtocol中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">     url = URLBuilder.from(url)</span><br><span class="line">               .setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY))</span><br><span class="line">               .removeParameter(REGISTRY_KEY)</span><br><span class="line">               .build();</span><br><span class="line">     Registry registry = registryFactory.getRegistry(url);</span><br><span class="line">     <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">          <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// group=&quot;a,b&quot; or group=&quot;*&quot;</span></span><br><span class="line">     Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">     String group = qs.get(Constants.GROUP_KEY);</span><br><span class="line">     <span class="keyword">if</span> (group != <span class="keyword">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">&quot;*&quot;</span>.equals(group)) &#123;</span><br><span class="line">               <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;</span><br><span class="line">     RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);</span><br><span class="line">     directory.setRegistry(registry);</span><br><span class="line">     directory.setProtocol(protocol);</span><br><span class="line">     <span class="comment">// all attributes of REFER_KEY</span></span><br><span class="line">     Map&lt;String, String&gt; parameters = <span class="keyword">new</span> HashMap&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">     URL subscribeUrl = <span class="keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">     <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="keyword">true</span>)) &#123;</span><br><span class="line">          directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">          registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">     &#125;</span><br><span class="line">     directory.buildRouterChain(subscribeUrl);</span><br><span class="line">     directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">               PROVIDERS_CATEGORY + <span class="string">&quot;,&quot;</span> + CONFIGURATORS_CATEGORY + <span class="string">&quot;,&quot;</span> + ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">     Invoker invoker = cluster.join(directory);</span><br><span class="line">     ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);</span><br><span class="line">     <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里最终调用到了doRefer方法，在这里在注册中心，注册节点，并且订阅通知，最终返回invoker对象。这里的invoker都是服务消费invoker。<br>&emsp;&emsp;注册消费者节点后，注册目录会订阅通知。<br>&emsp;&emsp;在注册中心注册节点的过程与暴露过程一样，只不过这里注册的是消费者节点，暴露注册的是提供者节点。<br>&emsp;&emsp;在这个过程中，cluster的作用是，通过Cluster扩展点将多个多个提供者应用伪装组合成单个提供者引用。</p>
]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>dubbo服务调用过程</title>
    <url>/hexoblog/2021/04/15/md/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82">服务调用过程</a><br><a href="https://www.jianshu.com/p/01bf8ded203c">推荐</a></p>
<span id="more"></span>
<h2 id="调用的时序图"><a href="#调用的时序图" class="headerlink" title="调用的时序图"></a>调用的时序图</h2><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/export-refer.jpg" alt="调用时序图"></p>
<h2 id="暴露过程"><a href="#暴露过程" class="headerlink" title="暴露过程"></a>暴露过程</h2><p>&emsp;&emsp;首先provider启动，通过Proxy组件根据具体的协议，将需要暴露的接口封装成invoker，invoker是dubbo一个很核心的组件，代表一个可执行体。<br>&emsp;&emsp;然后再通过Exporter包装一下，这是为了在注册中心暴露自己套的一层。然后将Exporter通过Registry注册到注册中心。 这就是整体服务暴露过程。<br>&emsp;&emsp;暴露会生成Exporter和服务提供invoker，会将Exporter保存在ExporterMap中，在调用请求到来时，会在这个map中找到对应的Exporter然后逐步还原出原来的invoker。</p>
<h2 id="引入过程"><a href="#引入过程" class="headerlink" title="引入过程"></a>引入过程</h2><p>&emsp;&emsp;首先消费者启动会向注册中心拉取服务提供者的元信息，然后调用流程也是从 Proxy 开始，毕竟都需要代理才能无感知。<br>&emsp;&emsp;Proxy持有一个invoker对象，调用invoke之后需要通过Cluster先从Directory获取所有可调用的远程服务的Invoker列表，如果配置了某些路由规则，比如某个接口只能调用某个节点的那就再过滤一遍Invoker列表。<br>&emsp;&emsp;剩下的Invoker再通过LoadBalance做负载均衡选取一个。然后再经过Filter做一些统计什么的，再通过Client做数据传输，比如用Netty来传输。<br>&emsp;&emsp;传输需要通过Codec做协议构造，再序化，最终发往对应的服务提供者。<br>&emsp;&emsp;服务提供者接收到之后也会进行Codec协议处理，然后反序列化后将请求扔到线程池处理。某个线程会根据请求找到对应的Exporter，找到Exporter就是找到了invoker，经过一层层过滤链之后最终实现调用，最后原路返回。</p>
<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p><a href="https://dubbo.apache.org/zh/docs/v2.7/dev/implementation/#%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%BB%86%E8%8A%82">远程调用细节</a></p>
<p>&emsp;&emsp;服务暴露时，provider启动，Proxy组件会将ref对象（需要暴露的接口）封装成invoker对象（服务提供invoker，AbstractProxyInvoker），就是实际提供服务的对象的代理。<br>&emsp;&emsp;通过Protocol将invoker对象包装成为Exporter对象保存在ExporterMap中，再在注册中心创建节点，订阅通知，将自己注册到注册中心。<br>&emsp;&emsp;在调用前，服务引入时，会在注册中心注册消费者节点，订阅通知，获取所有的服务提供者消息（服务提供方export对象信息，内含invoker对象信息）。<br>&emsp;&emsp;会使用到消费方的Proxy对象（这个对象在消费者初始化完成的时候生成，会注入到容器中），它持有一个消费invoker对象（dubboinvoker等），通过Cluster从Directory获取所有可调用的远程服务Invoker列表。<br>&emsp;&emsp;在消费方获取到提供方invoker列表信息后，会根据负载均衡等策略确定需要调用的具体提供invoker对象。<br>&emsp;&emsp;我们在项目发起调用后，消费代理对象，即Proxy组件会执行持有invoker对象（这里是消费invoker）的invoke方法，doinvoke方法。<br>&emsp;&emsp;doinvoke方法底层，会经过协议构造，序列化后，经过netty客户端，发往服务提供方。<br>&emsp;&emsp;提供方收到netty请求信息后，也会进行协议构造，反序列化后，将调用请求放入dubbo线程池（貌似默认是200）。<br>&emsp;&emsp;线程池的请求开始执行，会根据请求的信息，在ExporterMap中找到对应的exporter对象，也就是拿到了对应的服务提供invoker对象，就是实际服务提供的代理，然后执行我们提供的方法，完成调用。</p>
<hr>
<h1 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h1><p>&emsp;&emsp;服务暴露过程，与服务引入过程在单独的笔记，这里只有实际调用过程。</p>
<h2 id="消费端发起请求"><a href="#消费端发起请求" class="headerlink" title="消费端发起请求"></a>消费端发起请求</h2><p>&emsp;&emsp;在消费者初始化的时候，会生成一个消费者代理注册到容器中，消费调用接口时会把服务接口的method对象和参数放到RpcInvocation对象中，传入MockClusterInvoker.invoke，这个主要是看是否配置mock，一般情况下不走mock，会调用FailOverClusterInvoker.invoke。在服务接口消费者初始化时，接口方法和提供者Invoker对应关系保存在RegistryDirectory的methodInvokerMap中，通过调用的方法名称（或方法名称+第一个参数）获得对应的提供者invoker列表，如注册中心设置了路由规则，对这些invoker根据路由规则进行过滤。</p>
<p>&emsp;&emsp;这里先从Directory中拿到了invoker列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractDirectory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (destroyed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">&quot;Directory already destroyed .url: &quot;</span> + getUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> doList(invocation);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RegistryDirectory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; doList(Invocation invocation) &#123;</span><br><span class="line">    <span class="keyword">if</span> (forbidden) &#123;</span><br><span class="line">        <span class="comment">// 1. No service provider 2. Service providers are disabled</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.FORBIDDEN_EXCEPTION, <span class="string">&quot;No provider available from registry &quot;</span> +</span><br><span class="line">                getUrl().getAddress() + <span class="string">&quot; for service &quot;</span> + getConsumerUrl().getServiceKey() + <span class="string">&quot; on consumer &quot;</span> +</span><br><span class="line">                NetUtils.getLocalHost() + <span class="string">&quot; use dubbo version &quot;</span> + Version.getVersion() +</span><br><span class="line">                <span class="string">&quot;, please check status of providers(disabled, not registered or in blacklist).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (multiGroup) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.invokers == <span class="keyword">null</span> ? Collections.emptyList() : <span class="keyword">this</span>.invokers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invokers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Get invokers from cache, only runtime routers will be executed.</span></span><br><span class="line">        invokers = routerChain.route(getConsumerUrl(), invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failed to execute router: &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// FIXME Is there any need of failing back to Constants.ANY_VALUE or the first available method invokers when invokers is null?</span></span><br><span class="line">    <span class="comment">/*Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap = this.methodInvokerMap; // local reference</span></span><br><span class="line"><span class="comment">    if (localMethodInvokerMap != null &amp;&amp; localMethodInvokerMap.size() &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">        String methodName = RpcUtils.getMethodName(invocation);</span></span><br><span class="line"><span class="comment">        invokers = localMethodInvokerMap.get(methodName);</span></span><br><span class="line"><span class="comment">        if (invokers == null) &#123;</span></span><br><span class="line"><span class="comment">            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (invokers == null) &#123;</span></span><br><span class="line"><span class="comment">            Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator = localMethodInvokerMap.values().iterator();</span></span><br><span class="line"><span class="comment">            if (iterator.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">                invokers = iterator.next();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">return</span> invokers == <span class="keyword">null</span> ? Collections.emptyList() : invokers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在读取到所有的invoke列表后，会根据负载均衡算法选择一个进行调用。<br>&emsp;&emsp;这里也是用了SPI机制，支持多种负载均衡算法：随机，RR循环，最不活跃，一致性hash，默认随机。</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">random=org.apache.dubbo.rpc.cluster.loadbalance.RandomLoadBalance</span><br><span class="line">roundrobin=org.apache.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance</span><br><span class="line">leastactive=org.apache.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance</span><br><span class="line">consistenthash=org.apache.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;确定调用对象后，就会调用对应的doinvoke方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">doInvoke</span><span class="params">(Invocation invocation, <span class="keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;</span><br><span class="line">    checkInvokers(copyInvokers, invocation);</span><br><span class="line">    String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    <span class="keyword">int</span> len = getUrl().getMethodParameter(methodName, Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// retry loop.</span></span><br><span class="line">    RpcException le = <span class="keyword">null</span>; <span class="comment">// last exception.</span></span><br><span class="line">    List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="comment">// invoked invokers.</span></span><br><span class="line">    Set&lt;String&gt; providers = <span class="keyword">new</span> HashSet&lt;String&gt;(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">//Reselect before retry to avoid a change of candidate `invokers`.</span></span><br><span class="line">        <span class="comment">//<span class="doctag">NOTE:</span> if `invokers` changed, then `invoked` also lose accuracy.</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            checkWhetherDestroyed();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取所有的服务提供invoker列表</span></span><br><span class="line">            copyInvokers = list(invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// check again</span></span><br><span class="line">            checkInvokers(copyInvokers, invocation);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过负载均衡选择实际调用的目标</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);</span><br><span class="line"></span><br><span class="line">        invoked.add(invoker);</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (le != <span class="keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Although retry the method &quot;</span> + methodName</span><br><span class="line">                        + <span class="string">&quot; in the service &quot;</span> + getInterface().getName()</span><br><span class="line">                        + <span class="string">&quot; was successful by the provider &quot;</span> + invoker.getUrl().getAddress()</span><br><span class="line">                        + <span class="string">&quot;, but there have been failed providers &quot;</span> + providers</span><br><span class="line">                        + <span class="string">&quot; (&quot;</span> + providers.size() + <span class="string">&quot;/&quot;</span> + copyInvokers.size()</span><br><span class="line">                        + <span class="string">&quot;) from the registry &quot;</span> + directory.getUrl().getAddress()</span><br><span class="line">                        + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost()</span><br><span class="line">                        + <span class="string">&quot; using the dubbo version &quot;</span> + Version.getVersion() + <span class="string">&quot;. Last error is: &quot;</span></span><br><span class="line">                        + le.getMessage(), le);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.isBiz()) &#123; <span class="comment">// biz exception.</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            le = e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            le = <span class="keyword">new</span> RpcException(e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            providers.add(invoker.getUrl().getAddress());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(le.getCode(), <span class="string">&quot;Failed to invoke the method &quot;</span></span><br><span class="line">            + methodName + <span class="string">&quot; in the service &quot;</span> + getInterface().getName()</span><br><span class="line">            + <span class="string">&quot;. Tried &quot;</span> + len + <span class="string">&quot; times of the providers &quot;</span> + providers</span><br><span class="line">            + <span class="string">&quot; (&quot;</span> + providers.size() + <span class="string">&quot;/&quot;</span> + copyInvokers.size()</span><br><span class="line">            + <span class="string">&quot;) from the registry &quot;</span> + directory.getUrl().getAddress()</span><br><span class="line">            + <span class="string">&quot; on the consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; using the dubbo version &quot;</span></span><br><span class="line">            + Version.getVersion() + <span class="string">&quot;. Last error is: &quot;</span></span><br><span class="line">            + le.getMessage(), le.getCause() != <span class="keyword">null</span> ? le.getCause() : le);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;methodInvokerMap保存的是持有DubboInvoker（dubbo协议）实例的InvokerDelegete对象，是Invoker-Filter链的头部，先激活Filter连然后最终调到DubboInvoker.invoke(RpcInvocation)。<br>&emsp;&emsp;从FailoverClusterInvoker的doinvoke方法会进入AbstractInvoker的invoke方法，最终根据协议头进入具体的invoker中，执行doinvoke方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// FailoverClusterInvoker</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">    <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class="line">    inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">    ExchangeClient currentClient;</span><br><span class="line">    <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">        currentClient = clients[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">        <span class="keyword">boolean</span> isAsyncFuture = RpcUtils.isReturnTypeFuture(inv);</span><br><span class="line">        <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">        <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">            currentClient.send(inv, isSent);</span><br><span class="line">            RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">            ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">            <span class="comment">// For compatibility</span></span><br><span class="line">            FutureAdapter&lt;Object&gt; futureAdapter = <span class="keyword">new</span> FutureAdapter&lt;&gt;(future);</span><br><span class="line">            RpcContext.getContext().setFuture(futureAdapter);</span><br><span class="line"></span><br><span class="line">            Result result;</span><br><span class="line">            <span class="keyword">if</span> (isAsyncFuture) &#123;</span><br><span class="line">                <span class="comment">// register resultCallback, sometimes we need the async result being processed by the filter chain.</span></span><br><span class="line">                result = <span class="keyword">new</span> AsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="keyword">new</span> SimpleAsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">&quot;Invoke remote method timeout. method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, provider: &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">&quot;Failed to invoke remote method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, provider: &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractInvoker</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation inv)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="comment">// if invoker is destroyed due to address refresh from registry, let&#x27;s allow the current invoke to proceed</span></span><br><span class="line">    <span class="keyword">if</span> (destroyed.get()) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Invoker for service &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; on consumer &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot; is destroyed, &quot;</span></span><br><span class="line">                + <span class="string">&quot;, dubbo version is &quot;</span> + Version.getVersion() + <span class="string">&quot;, this invoker should not be used any longer&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RpcInvocation invocation = (RpcInvocation) inv;</span><br><span class="line">    invocation.setInvoker(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(attachment)) &#123;</span><br><span class="line">        invocation.addAttachmentsIfAbsent(attachment);</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments();</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmptyMap(contextAttachments)) &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * invocation.addAttachmentsIfAbsent(context)&#123;<span class="doctag">@link</span> RpcInvocation#addAttachmentsIfAbsent(Map)&#125;should not be used here,</span></span><br><span class="line"><span class="comment">            * because the &#123;<span class="doctag">@link</span> RpcContext#setAttachment(String, String)&#125; is passed in the Filter when the call is triggered</span></span><br><span class="line"><span class="comment">            * by the built-in retry mechanism of the Dubbo. The attachment to update RpcContext will no longer work, which is</span></span><br><span class="line"><span class="comment">            * a mistake in most cases (for example, through Filter to RpcContext output traceId and spanId and other information).</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        invocation.addAttachments(contextAttachments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doInvoke(invocation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123; <span class="comment">// biz exception</span></span><br><span class="line">        Throwable te = e.getTargetException();</span><br><span class="line">        <span class="keyword">if</span> (te == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (te <span class="keyword">instanceof</span> RpcException) &#123;</span><br><span class="line">                ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(te);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.isBiz()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RpcResult(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DubboInvoker</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    RpcInvocation inv = (RpcInvocation) invocation;</span><br><span class="line">    <span class="keyword">final</span> String methodName = RpcUtils.getMethodName(invocation);</span><br><span class="line">    inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());</span><br><span class="line">    inv.setAttachment(Constants.VERSION_KEY, version);</span><br><span class="line"></span><br><span class="line">    ExchangeClient currentClient;</span><br><span class="line">    <span class="keyword">if</span> (clients.length == <span class="number">1</span>) &#123;</span><br><span class="line">        currentClient = clients[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentClient = clients[index.getAndIncrement() % clients.length];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> isAsync = RpcUtils.isAsync(getUrl(), invocation);</span><br><span class="line">        <span class="keyword">boolean</span> isAsyncFuture = RpcUtils.isReturnTypeFuture(inv);</span><br><span class="line">        <span class="keyword">boolean</span> isOneway = RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">        <span class="keyword">int</span> timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">        <span class="keyword">if</span> (isOneway) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, <span class="keyword">false</span>);</span><br><span class="line">            currentClient.send(inv, isSent);</span><br><span class="line">            RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> RpcResult();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync) &#123;</span><br><span class="line">            ResponseFuture future = currentClient.request(inv, timeout);</span><br><span class="line">            <span class="comment">// For compatibility</span></span><br><span class="line">            FutureAdapter&lt;Object&gt; futureAdapter = <span class="keyword">new</span> FutureAdapter&lt;&gt;(future);</span><br><span class="line">            RpcContext.getContext().setFuture(futureAdapter);</span><br><span class="line"></span><br><span class="line">            Result result;</span><br><span class="line">            <span class="keyword">if</span> (isAsyncFuture) &#123;</span><br><span class="line">                <span class="comment">// register resultCallback, sometimes we need the async result being processed by the filter chain.</span></span><br><span class="line">                result = <span class="keyword">new</span> AsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="keyword">new</span> SimpleAsyncRpcResult(futureAdapter, futureAdapter.getResultFuture(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            RpcContext.getContext().setFuture(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.TIMEOUT_EXCEPTION, <span class="string">&quot;Invoke remote method timeout. method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, provider: &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcException.NETWORK_EXCEPTION, <span class="string">&quot;Failed to invoke remote method: &quot;</span> + invocation.getMethodName() + <span class="string">&quot;, provider: &quot;</span> + getUrl() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这里面会调用到HeaderExchangeClient的request方法，这里底层就是和netty打交道的地方了。从request方法中就会继续调用HeaderExchangeChannel的request方法，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HeaderExchangeClient</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> channel.request(request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HeaderExchangeChannel</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">&quot;Failed to send request &quot;</span> + request + <span class="string">&quot;, cause: The channel &quot;</span> + <span class="keyword">this</span> + <span class="string">&quot; is closed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create request.</span></span><br><span class="line">    Request req = <span class="keyword">new</span> Request();</span><br><span class="line">    req.setVersion(Version.getProtocolVersion());</span><br><span class="line">    req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">    req.setData(request);</span><br><span class="line">    DefaultFuture future = DefaultFuture.newFuture(channel, req, timeout);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.send(req);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">        future.cancel();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里最终会经过AbstractChannel调用NettyChannel发送请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// NettyChanne</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.send(message, sent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ChannelFuture future = channel.write(message);</span><br><span class="line">        <span class="keyword">if</span> (sent) &#123;</span><br><span class="line">            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">            success = future.await(timeout);</span><br><span class="line">        &#125;</span><br><span class="line">        Throwable cause = future.getCause();</span><br><span class="line">        <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">&quot;Failed to send message &quot;</span> + message + <span class="string">&quot; to &quot;</span> + getRemoteAddress() + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>, <span class="string">&quot;Failed to send message &quot;</span> + message + <span class="string">&quot; to &quot;</span> + getRemoteAddress()</span><br><span class="line">                + <span class="string">&quot;in timeout(&quot;</span> + timeout + <span class="string">&quot;ms) limit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM—GC</title>
    <url>/hexoblog/2021/04/26/md/jvm/JVM%E2%80%94GC/</url>
    <content><![CDATA[<h1 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h1><p>&emsp;&emsp;GC就是垃圾收集，java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收的目的。<br>&emsp;&emsp;对于GC来说，当对象被创建的时候，GC就开始监控这个对象的地址、大小及使用情况。  </p>
<span id="more"></span>

<hr>
<h1 id="对象确定"><a href="#对象确定" class="headerlink" title="对象确定"></a>对象确定</h1><p>&emsp;&emsp;垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是存活的，是不可以被回收的；哪些对象已经死亡了，需要被回收。<br>&emsp;&emsp;一般通过两种算法确定那些对象需要被回收：</p>
<h2 id="引用计数器法"><a href="#引用计数器法" class="headerlink" title="引用计数器法"></a>引用计数器法</h2><p>&emsp;&emsp;为每个对象创建一个引用计数（被引用，即由引用指向这个对象），有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。但是他有一个缺点是不能解决循环引用的问题。<br>&emsp;&emsp;当一个对象被当作垃圾收集时，它引用的任何对象的计数器的值都减一。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>&emsp;&emsp;引用计数法实现起来比较简单，对程序不被长时间打断的实时环境比较有利。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>&emsp;&emsp;需要额外的空间来存储计数器，难以检测出对象之间的循环引用。</p>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>&emsp;&emsp;可达性分析法也被称之为根搜索法。<br>&emsp;&emsp;可达性是指，如果一个对象会被至少一个在程序中的变量通过直接或间接的方式被其他可达的对象引用，则称该对象就是可达的。这两种情况被称为可达的：</p>
<ol>
<li><p>对象属于根集中的对象。</p>
<blockquote>
<p>根集指的是正在执行的java程序可以访问的引用变量的集合，程序可以使用引用变量访问对象的属性和调用对象的方法。根集中的对象也就是GC Roots。</p>
</blockquote>
</li>
<li><p>对象被一个可达的对象引用。</p>
<p>&emsp;&emsp;也就是说，从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是可以被回收的。<br>&emsp;&emsp;在java中，可以被当做GC Roots的对象有：</p>
</li>
<li><p>虚拟机栈（栈帧中的本地变量表）中引用的对象。</p>
</li>
<li><p>方法区中的常量引用的对象。</p>
</li>
<li><p>方法区中的类静态属性引用的对象。</p>
</li>
<li><p>本地方法栈中 JNI（Native 方法）的引用对象。</p>
</li>
<li><p>活跃线程（已启动且未停止的 Java 线程）。</p>
</li>
</ol>
<p>&emsp;&emsp;当一个对象到根对象没有任何引用链相连，则成为这个对象是不可达的，也称为不可达对象，是可以被回收的。</p>
<h3 id="二次标记"><a href="#二次标记" class="headerlink" title="二次标记"></a>二次标记</h3><p>&emsp;&emsp;在可达性分析算法中，对象有两种状态，要么是可达的要么是不可达的，在判断一个对象可达性的时候就需要对对象进行标记。  </p>
<ul>
<li>开始进行标记前，需要先暂停线程，否则对象图如果一直在变化的话是无法真正去遍历它的。</li>
<li>暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。</li>
<li>在可达性分析算法中，要真正宣告一个对象死亡，至少要经过两次标记过程：<ul>
<li>&emsp;&emsp;如果对象在进行根搜索后发现没有与根对象相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行<code>finalize()</code>。当对象没有覆盖<code>finaliza()</code>方法，或<code>finalize()</code>方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。</li>
<li>&emsp;&emsp;如果该对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会被放置在一个名为<strong>F-Quene</strong>的队列中，并在稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行<code>finalize()</code>方法。这个方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Quene中的对象进行第二次小规模的标记， 如果要在<code>finalize()</code>方法中成功拯救自己，只要在<code>finalize()</code>中让该对象与引用链上的任何一个对象重新建立关联即可。而如果对象这时还没有关联到引用链上的任何一个对象，那么他就会被回收。</li>
</ul>
</li>
<li>GC 判断对象是否可达看的是强引用。</li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>&emsp;&emsp;可以解决循环引用的问题，不需要占用额外的空间。</p>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>&emsp;&emsp;多线程场景下，其他线程可能会更新已经访问过的对象的引用。</p>
<hr>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><p>&emsp;&emsp;在确定那些对象需要被回收后，接下来就需要垃圾收集器通过垃圾收集算法进行垃圾回收了。</p>
<h2 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h2><p>&emsp;&emsp;先标记Java堆中可回收的对象，然后直接进行回收操作。<br>&emsp;&emsp;分为标记和清除两个阶段。<br>&emsp;&emsp;首先标记出所需回收的对象，在标记完成后统一回收掉所有被标记的对象，它的标记过程其实就是前面的可达性分析法中判定垃圾对象的标记过程。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>&emsp;&emsp;不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效。 </p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>&emsp;&emsp;标记和清除过程的效率都不高，这种方法需要使用一个空闲列表来记录所有的空闲区域以及大小，对空闲列表的管理会增加分配对象时的工作量；标记清除后会产生大量不连续的内存碎片，虽然空闲区域的大小是足够的，但却可能没有一个单一区域能够满足这次分配所需的大小，因此本次分配还是会失败，不得不触发另一次垃圾收集动作。</p>
<h2 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h2><p>&emsp;&emsp;与“标记-清除算法”的唯一区别就是在回收操作完成后，会将零散的空间碎片进行整理。<br>&emsp;&emsp;整理算法的清除过程与清出算法的稍有不同，它不是直接对可回收对象进行清理，而是让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。在基于“标记-整理”算法的收集器的实现中，一般增加句柄和句柄表。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>&emsp;&emsp;经过整理之后，新对象的分配只需要通过指针碰撞便能完成，比较简单；使用这种方法，空闲区域的位置是始终可知的，也不会再有碎片的问题了。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>&emsp;&emsp;GC暂停的时间会增长，因为你需要将所有的对象都拷贝到一个新的地方，还得更新它们的引用地址。</p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>&emsp;&emsp;常见的是将Java堆划分为一个Eden空间和两个Survivor空间，默认比例为8:1:1，每次使用一个Eden空间和一个Survivor空间。<br>&emsp;&emsp;复制算法是为了解决句柄的开销和堆碎片的回收。<br>&emsp;&emsp;它将内存按容量分为大小相等的两块，每次只使用其中的一块（对象面），当这一块的内存用完了，就将还存活着的对象复制到另外一块内存上面（空闲面），然后再把已使用过的内存空间一次清理掉。<br>&emsp;&emsp;复制算法比较适合于新生代（短生存期的对象），在老年代（长生存期的对象）中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选用其他算法，如“标记-整理”算法。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>&emsp;&emsp;标记阶段和复制阶段可以同时进行；每次只对一块内存进行回收，运行高效；只需移动栈顶指针，按顺序分配内存即可，实现简单；内存回收时不用考虑内存碎片的出现。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>&emsp;&emsp;需要一块能容纳下所有存活对象的额外的内存空间。因此，可一次性分配的最大内存缩小了一半。即内存使用率不高，只有原来的一半。</p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>&emsp;&emsp;将Java堆分为新生代和老年代，一般来说新生代采用“复制算法”，而老年代则采用“标记-清除算法”或者“标记-整理算法”，具体则要根据JVM实际实现，不同的虚拟机实现可能不同。<br>&emsp;&emsp;在jdk1.7前还有永久代，永久代的GC是绑定在老年代一起的。<br>&emsp;&emsp;新生代又被进一步划分为Eden和Survivor区，其中Survivor由FromSpace（Survivor0）和ToSpace（Survivor1）组成。<br>&emsp;&emsp;创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。<br>&emsp;&emsp;当前主流虚拟机都采用分代收集。</p>
<hr>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>&emsp;&emsp;其中用于回收新生代的收集器包括Serial、PraNew、Parallel Scavenge。<br>&emsp;&emsp;回收老年代的收集器包括Serial Old、Parallel Old、CMS。<br>&emsp;&emsp;有用于回收整个Java堆的G1收集器。<br>&emsp;&emsp;垃圾回收线程相对于工作线程是独立的，当需要执行垃圾回收时，会先停止工作线程，然后通知垃圾回收线程执行。</p>
<h2 id="新生代垃圾收集器"><a href="#新生代垃圾收集器" class="headerlink" title="新生代垃圾收集器"></a>新生代垃圾收集器</h2><h3 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h3><p>&emsp;&emsp;串行垃圾回收器，采用<strong>单线程</strong>的方式进行收集，采用的是<strong>复制算法</strong>，在GC线程执行时，系统不允许工作线程打扰。这个过程中应用程序会进入暂停状态，即Stop-the-world。<br>&emsp;&emsp;STW这个过程对用户不可见，用户仅感知到系统卡顿了一会。STW时间的长短是衡量性能的指标。<br>&emsp;&emsp;单核的系统下，不存在线程之间的交互，这种可以提高效率。</p>
<h3 id="PraNew"><a href="#PraNew" class="headerlink" title="PraNew"></a>PraNew</h3><p>&emsp;&emsp;并行垃圾回收器，采用的是<strong>多线程</strong>的方式，使用了多个GC线程，也采用<strong>复制算法</strong>，可以看做是Serial的多线程版本。<br>&emsp;&emsp;单核情况下，系统无法发挥多线程的优势，效率会比Serial差。</p>
<h3 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h3><p>&emsp;&emsp;新生代并行收集器，相对PreNew，追求高吞吐亮，同样采用<strong>复制算法</strong>，又称为吞吐亮优先收集器。<br>&emsp;&emsp;Serial与PargNew比较关注STW时间，而Parallel Scavenge更关注吞吐量。  </p>
<blockquote>
<p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。<code>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）</code>。</p>
</blockquote>
<h4 id="侧重点"><a href="#侧重点" class="headerlink" title="侧重点"></a>侧重点</h4><h5 id="高吞吐量"><a href="#高吞吐量" class="headerlink" title="高吞吐量"></a>高吞吐量</h5><p>&emsp;GC 的总时间越短，系统的吞吐量则越高。换句话说，高吞吐量则意味着，STW 的时间可能会比正常的时间多一点，也就更加适合那种不存在太多交互的后台的系统，因为对实时性的要求不是很高，就可以高效率的完成任务。</p>
<h5 id="短STW"><a href="#短STW" class="headerlink" title="短STW"></a>短STW</h5><p>&emsp;&emsp;STW 的时间短，则说明对系统的响应速度要求很高，因为要跟用户频繁的交互。因为低响应时间会带来较高的用户体验。</p>
<h2 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h2><h3 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h3><p>&emsp;&emsp;Serial Old是Serial的老年代版本，使用的<strong>标记-整理算法</strong>。<br>&emsp;&emsp;Serial Old是给client模式下的JVM使用。</p>
<h3 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h3><p>&emsp;&emsp;是Parallel Scavenge的老年代版本，同样是多线程的，采用<strong>标记整理</strong>算法。<br>&emsp;&emsp;特性与Parallel Scavenge相似，同样是吞吐量优先。</p>
<h3 id="CMS（Concurrent-Mark-Swee）"><a href="#CMS（Concurrent-Mark-Swee）" class="headerlink" title="CMS（Concurrent Mark Swee）"></a>CMS（Concurrent Mark Swee）</h3><p>&emsp;&emsp;采用<strong>标记清除算法</strong>，重点关注于最短的STW时间。<br>&emsp;&emsp;它的过程分为4步：</p>
<ol>
<li><strong>初始标记</strong>：标记从GCRoots出发能够关联到的所有对象，此时需要STW，但是不需要很多时间。</li>
<li><strong>并发标记</strong>：多线程对所有对象通过GC Roots Tracing进行可达性分析，这个过程较为耗时。这个阶段程序仍在执行。</li>
<li><strong>重新标记</strong>：重新标记是为了修正在并发标记阶段，发生错误的一些数据。并发标记过程中，程序仍在运行，有些对象的状态可能会发生变化，所以需要重新标记，这个过程需要STW。</li>
<li><strong>并发清除</strong>：标记完成后进行清除。</li>
</ol>
<h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><p>&emsp;&emsp;并发收集，低STW。<br>&emsp;&emsp;将标记阶段，以流水线的方式拆分为3端，将耗时最长的阶段，与程序并发执行，仅需要两个很少的停顿阶段，降低STW时间，达到近似并发的目的。<br>&emsp;&emsp;初始标记&lt;重复标记&lt;并发标记</p>
<h4 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h4><p>&emsp;&emsp;缺点也很明显：</p>
<ul>
<li><p>对CPU资源很敏感，CPU资源很少时，系统占用很多，GC就占用很少，吞吐量就很低。</p>
</li>
<li><p>无法处理浮动垃圾。</p>
<blockquote>
<p>浮动垃圾就是在并发标记的时候产生的垃圾，这些垃圾只能在下一次GC时清除，如果预留的内存空间不足保存浮动垃圾，就会产生Full GC。</p>
</blockquote>
</li>
<li><p>基于标记清除算法，一堆问题。</p>
<h2 id="堆垃圾收集器"><a href="#堆垃圾收集器" class="headerlink" title="堆垃圾收集器"></a>堆垃圾收集器</h2></li>
</ul>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>&emsp;&emsp;G1全称Garbage First。G1收集器基于<strong>标记整理算法</strong>实现，相对于前面的垃圾回收器，G1收集器在实现高吞吐的同时尽可能减少STW时间。<br>&emsp;&emsp;G1收集器特点：</p>
<ol>
<li><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短STW停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过并发的方式让Java程序继续运行。</li>
<li><strong>分代收集</strong>：打破了原有的分代模型，将堆划分为一个个区域。</li>
<li><strong>空间整合</strong>：与CMS的“标记-清除”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。但无论如何，这两种算法都意味着G1运作期间<strong>不会产生内存空间碎片</strong>，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li>
<li><strong>可预测的停顿</strong>：这是G1相对于CMS的一个优势，降低停顿时间是G1和CMS共同的关注点。</li>
</ol>
<p>&emsp;&emsp;G1收集器打破了以往将收集范围固定在新生代，老年代的模式，G1将堆划分为一个个小的Region块（区域大小相同的内存单元）。<br>&emsp;&emsp;每个Region被标记了E、S、O 和 H，这些区域在逻辑上被映射为Eden，Survivor、老年代和大对象区。存活的对象从一个区域转移（即复制或移动）到另一个区域，区域被设计为并行收集垃圾，可能会暂停所有应用线程。<br>&emsp;&emsp;Humongous区域（标记H区）是为了那些存储超过50%标准Region大小的对象而设计的，它用来专门存放巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动 Full GC。<br>&emsp;&emsp;G1 收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1会通过一个合理的计算模型，计算出每个Region的收集成本并量化，这样一来，收集器在给定了“停顿”时间限制的情况下，总是能选择一组恰当的Region作为收集目标，让其收集开销满足这个限制条件，以此达到实时收集的目的。  </p>
<p>&emsp;&emsp;G1收集器工作过程：</p>
<ol>
<li><strong>初始标记</strong>：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li>
<li><strong>并发标记</strong>：是从GC Roots开始堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</li>
<li><strong>最终标记</strong>：是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。类似于CMS的重复标记，但是这里可以并发执行。</li>
<li><strong>筛选回收</strong>：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这个阶段也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。</li>
</ol>
<p>&emsp;&emsp;G1的回收模式可以分为两种：</p>
<ol>
<li><strong>Young GC</strong>：在分配一般对象（非巨型对象）时，当所有Eden区域使用达到最大阀值并且无法申请足够内存时，会触发一次YoungGC。每次Young GC会回收所有Eden以及Survivor区，并且将存活对象复制到Old区以及另一部分的Survivor区。</li>
<li><strong>Mixed GC</strong>：当越来越多的对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个新生代，还会回收一部分的老年代，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些Old区域进行收集，从而可以对垃圾回收的耗时时间进行控制。G1没有Full GC概念，需要Full GC时，调用Serial Old GC进行全堆扫描。</li>
</ol>
<hr>
<h1 id="用一张图总结下"><a href="#用一张图总结下" class="headerlink" title="用一张图总结下"></a>用一张图总结下</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86.png" alt="垃圾收集"></p>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>memory</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>网络ISO模型</title>
    <url>/hexoblog/2021/05/06/md/internet/%E7%BD%91%E7%BB%9CISO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><p>在计算机网络中有著名的OSI七层协议体系结构，概念清楚，理论完整，但是它既复杂又不实用。TCP/IP体系结构则不同，得到的广泛的应用。最终结合OSI和TCP/IP的优点，采用了一种只有五层协议的体系结构。</p>
<span id="more"></span>

<p><a href="https://blog.csdn.net/HuoqilinHeiqiji/article/details/89703358">五层结构</a><br><a href="https://www.jianshu.com/p/bb363a41afcf">网络结构</a></p>
<table border="1">
    <tr>
        <th>OSI体系结构</th>
        <th>TCP/IP体系结构</th>
        <th>五层体系结构</th>
    </tr>
    <tr>
        <td>应用层</td>
        <td rowspan="3">应用层</td>
        <td rowspan="3">应用层</td>
    </tr>
    <tr>
        <td>表示层</td>
    </tr>
    <tr>
        <td>会话层</td>
    </tr>
    <tr>
        <td>传输层</td>
        <td>传输层</td>
        <td>传输层</td>
     </tr>
     <tr>
        <td>网络层</td>
        <td>网络层</td>
        <td>网络层</td>
     </tr>
     <tr>
        <td>数据链路层</td>
        <td rowspan="2">数据链路层</td>
        <td>数据链路层</td>
     </tr>
     <tr>
        <td>物理层</td>
        <td>物理层</td>
     </tr>
</table>

<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>&emsp;&emsp;应用层的任务是通过应用进程间的交互来完成特定的网络应用。<br>&emsp;&emsp;应用层协议定义的是应用进程间通信和交互的规则。<br>&emsp;&emsp;应用层是app访问网络、向用户显示接收到的信息的窗口。</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>&emsp;&emsp;表示层也称为转换层，在表示层提取应用层的数据，并根据需要转换格式，以便通过网络传输。<br>&emsp;&emsp;这一层可以做一些数据格式转换，加密解密，压缩等操作。</p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>&emsp;&emsp;会话层负责建立连接，维护会话、认证，并确保安全。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>&emsp;&emsp;为两个主机进程间的通信提供通用的数据传输服务。<br>&emsp;&emsp;传输层从网络层获取服务，向应用层提供服务。<br>&emsp;&emsp;只有主机的协议栈才有传输层，网络传输中的一些设备没有传输层，比如路由器。<br>&emsp;&emsp;传输层提供应用进程间的逻辑通信，通信的真正端点是应用进程。<br>&emsp;&emsp;传输层会将源端口号和目的端口号写入header中。</p>
<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E4%BC%A0%E8%BE%93%E5%B1%82%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.jpg" alt="数据传输"></p>
<p>&emsp;&emsp;上面客户端与服务端之间的每一次的数据传输（这里指信息传递，包括三次握手与四次挥手）都要完整的走一遍下面的流程。</p>
<p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%AE%9E%E9%99%85%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="数据传输"></p>
<p>&emsp;&emsp;传输层主要使用两种协议：</p>
<ol>
<li>TCP：传输控制协议，提供面向连接的，可靠的数据传输服务。</li>
<li>UDP：用户数据报协议，提供面向无连接的，尽最大努力交付。</li>
</ol>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>&emsp;&emsp;网络层为分组交换网上不同主机提供通信服务，网络层将传输层的报文封装成包和分组发送。<br>&emsp;&emsp;将数据从一台主机传输到位于不同网络中的另一台主机。还负责分组路由，即从多条路线中选取路径最短的。<br>&emsp;&emsp;网络层会将发送者，接收者的ip地址放入header中。  </p>
<h4 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h4><ol>
<li>路由</li>
<li>逻辑寻址</li>
</ol>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>&emsp;&emsp;两台主机间的数据传输，总是一段一段在数据链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点间的链路上传送帧，每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。<br>&emsp;&emsp;数据链路层负责的是节点到节点的数据传输，负责确保在物理层上从一个节点到一个节点正确的传输数据。  </p>
<h4 id="基本功能："><a href="#基本功能：" class="headerlink" title="基本功能："></a>基本功能：</h4><ol>
<li><p>封装成帧</p>
</li>
<li><p>物理寻址</p>
</li>
<li><p>错误控制</p>
</li>
<li><p>流控制</p>
</li>
<li><p>访问控制</p>
<p>&emsp;&emsp;三个基本问题：封装成帧，透明传输，差错控制。<br>&emsp;&emsp;通过ARP协议，可以获取拥有指定ip地址目标主机的mac地址。</p>
</li>
</ol>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>&emsp;&emsp;在物理层以比特流传输数据，其实就是二进制流，物理实现可能不同。<br>&emsp;&emsp;OSI 参考模型最底层是物理层，物理层负责在设备和物理传输介质之间传输、接收非结构化数据。  </p>
<h4 id="基本功能：-1"><a href="#基本功能：-1" class="headerlink" title="基本功能："></a>基本功能：</h4><ol>
<li>比特同步</li>
<li>比特率控制</li>
<li>物理拓补</li>
<li>传输模式<ol>
<li>单工</li>
<li>半双工</li>
<li>全双工</li>
</ol>
</li>
</ol>
<hr>
<h1 id="数据流转"><a href="#数据流转" class="headerlink" title="数据流转"></a>数据流转</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93.jpg" alt="数据流转"></p>
<p>&emsp;&emsp;我们在网络中发送传输数据的时候，数据总是从一台主机的应用层传输到了，另一条台主机的应用层，这其中会包含有很多过程。<br>&emsp;&emsp;再分层结构中，数据总是在应用层产生（也有可能其他地方），在物理介质上传输。<br>&emsp;&emsp;数据在层与层之间传递的时候总是会添加上特有的首部，比如传输层会将端口号写入TCP首部，网络层会将IP地址写入IP首部。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
</search>
