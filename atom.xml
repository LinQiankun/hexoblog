<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Study</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="http://linqiankun.gitee.io/hexoblog/atom.xml" rel="self"/>
  
  <link href="http://linqiankun.gitee.io/hexoblog/"/>
  <updated>2021-06-16T05:50:34.833Z</updated>
  <id>http://linqiankun.gitee.io/hexoblog/</id>
  
  <author>
    <name>linqiankun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TODO</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2022/12/31/TODO/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2022/12/31/TODO/</id>
    <published>2022-12-31T15:59:59.000Z</published>
    <updated>2021-06-16T05:50:34.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><span id="more"></span><h2 id="QUEST-TODO"><a href="#QUEST-TODO" class="headerlink" title="QUEST_TODO"></a>QUEST_TODO</h2><ul><li><input disabled="" type="checkbox"> zk同时接收到创建节点请求</li><li><input disabled="" type="checkbox"> mysql分库分表</li><li><input disabled="" type="checkbox"> countdownlanch</li></ul><h2 id="POSTS-TODO"><a href="#POSTS-TODO" class="headerlink" title="POSTS_TODO"></a>POSTS_TODO</h2><ul><li><input disabled="" type="checkbox"> rocketmq负载均衡代码</li><li><input disabled="" type="checkbox"> rocketmq消息可靠性消费重试代码</li><li><input disabled="" type="checkbox"> jekins安装和使用<ul><li><input disabled="" type="checkbox"> jekins安装过程</li><li><input disabled="" type="checkbox"> jekins基本使用</li></ul></li></ul><hr><h2 id="DRAFTS-TODO"><a href="#DRAFTS-TODO" class="headerlink" title="DRAFTS_TODO"></a>DRAFTS_TODO</h2><ul><li><input checked="" disabled="" type="checkbox"> IO</li><li><input disabled="" type="checkbox"> kafka简介</li><li><input disabled="" type="checkbox"> rocketmq-Broker启动流程</li><li><input checked="" disabled="" type="checkbox"> rocketmq-NameServer启动流程</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h1&gt;</summary>
    
    
    
    <category term="todo" scheme="http://linqiankun.gitee.io/hexoblog/categories/todo/"/>
    
    
    <category term="todo" scheme="http://linqiankun.gitee.io/hexoblog/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>juc之AQS源码二</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/06/18/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E4%BA%8C/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/06/18/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E4%BA%8C/</id>
    <published>2021-06-18T06:13:27.000Z</published>
    <updated>2021-06-21T03:41:27.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式"></a>共享方式</h1><p>&emsp;&emsp;juc之AQS源码一中讲了独占方式的源码，这里分析共享方式的源码。</p><span id="more"></span><h2 id="acquireShared共享方式获取资源"><a href="#acquireShared共享方式获取资源" class="headerlink" title="acquireShared共享方式获取资源"></a>acquireShared共享方式获取资源</h2><h3 id="acquireShared方法"><a href="#acquireShared方法" class="headerlink" title="acquireShared方法"></a>acquireShared方法</h3><p>&emsp;&emsp;acquireShared方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。<br>&emsp;&emsp;所以函数流程如下：</p><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回。</li><li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li></ol><h3 id="doAcquireShared方法"><a href="#doAcquireShared方法" class="headerlink" title="doAcquireShared方法"></a>doAcquireShared方法</h3><p>&emsp;&emsp;此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 加入队列尾部</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 是否成功的标志</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 是否有外部中断的标志</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 拿到前驱节点</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 尝试获取资源</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 如果有剩余资源唤醒后面的线程，这里就是和独占式的区别</span>                    <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>                    <span class="token comment">// 如果有外部中断，补充中断</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span>                        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这个方法和acquireQueued方法很相似，只不过这里将补充中断的位置搬进来了。</p><h3 id="setHeadAndPropagate方法"><a href="#setHeadAndPropagate方法" class="headerlink" title="setHeadAndPropagate方法"></a>setHeadAndPropagate方法</h3><p>&emsp;&emsp;这个方法在自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> propagate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// Record old head for check below</span>    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>propagate <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> h <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        <span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 这里调用了唤醒线程的方法，唤醒后面的线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;基本流程：</p><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回。</li><li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li></ol><p>&emsp;&emsp;跟acquire的流程相似，多了个自己拿到资源后，还回去唤醒后面的线程。</p><h2 id="releaseShared共享方式释放资源"><a href="#releaseShared共享方式释放资源" class="headerlink" title="releaseShared共享方式释放资源"></a>releaseShared共享方式释放资源</h2><h3 id="releaseShared方法"><a href="#releaseShared方法" class="headerlink" title="releaseShared方法"></a>releaseShared方法</h3><p>&emsp;&emsp;此方法是共享模式下线程释放共享资源的顶层入口。<br>&emsp;&emsp;它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 尝试释放资源</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 唤醒后面的线程</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;释放掉资源后，唤醒后继。<br>&emsp;&emsp;跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求（只要有释放，就回去唤醒），共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。</p><h3 id="doReleaseShared方法"><a href="#doReleaseShared方法" class="headerlink" title="doReleaseShared方法"></a>doReleaseShared方法</h3><p>&emsp;&emsp;这个方法用于唤醒后继节点。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>            <span class="token comment">// 该状态表示后继节点需要唤醒</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">// loop to recheck cases</span>                <span class="token comment">// 唤醒后继节点</span>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                     <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>PROPAGATE<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment">// loop on failed CAS</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span>                   <span class="token comment">// loop if head changed</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;共享方式&quot;&gt;&lt;a href=&quot;#共享方式&quot; class=&quot;headerlink&quot; title=&quot;共享方式&quot;&gt;&lt;/a&gt;共享方式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;juc之AQS源码一中讲了独占方式的源码，这里分析共享方式的源码。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/"/>
    
    <category term="juc" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/juc/"/>
    
    <category term="AQS" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/juc/AQS/"/>
    
    <category term="Java" scheme="http://linqiankun.gitee.io/hexoblog/categories/Java/"/>
    
    <category term="多线程" scheme="http://linqiankun.gitee.io/hexoblog/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/tags/java/"/>
    
    <category term="juc" scheme="http://linqiankun.gitee.io/hexoblog/tags/juc/"/>
    
    <category term="AQS" scheme="http://linqiankun.gitee.io/hexoblog/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>juc之AQS源码</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/06/17/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS%E6%BA%90%E7%A0%81/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/06/17/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS%E6%BA%90%E7%A0%81/</id>
    <published>2021-06-17T09:31:48.000Z</published>
    <updated>2021-06-18T08:36:59.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两种资源共享方式"><a href="#两种资源共享方式" class="headerlink" title="两种资源共享方式"></a>两种资源共享方式</h1><p>&emsp;&emsp;AQS定义了两种资源共享方式：</p><ol><li>Exclusive：独占方式，只有一个线程能执行，如ReentrantLock。</li><li>Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier。</li></ol><span id="more"></span><p>&emsp;&emsp;对应的，在不同的资源共享模式下，就有了不同的源码。<br>&emsp;&emsp;值得注意的是，acquire()和acquireShared()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，acquireInterruptibly()/acquireSharedInterruptibly()即是。</p><hr><h1 id="独占方式"><a href="#独占方式" class="headerlink" title="独占方式"></a>独占方式</h1><p>&emsp;独占方式下，获取资源与释放资源的一组为<code>acquire()</code>和<code>release()</code>方法。</p><h2 id="Acquire独占模式获取资源"><a href="#Acquire独占模式获取资源" class="headerlink" title="Acquire独占模式获取资源"></a>Acquire独占模式获取资源</h2><h3 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h3><p>&emsp;&emsp;acquire方法时独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响，获取到资源后线程就可以执行其临界区代码了。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;函数流程如下：</p><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）。</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式。</li><li>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><h3 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3><p>&emsp;&emsp;此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这个方法在AQS中定义了空方法体，需要各个自定义同步器自己去重写这个方法，如CountDownLatch的Sync。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里就是模板方法模式的典型应用。<br>&emsp;&emsp;这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p><h3 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h3><p>&emsp;&emsp;用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。这里会将每一个线程封装成一个Node，Node中有一个Tread属性用来保存当前线程。等待队列可以看作是一个双向链表，一个CLH对列，一个虚拟的双向队列。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Try the fast path of enq; backup to full enq on failure</span>    <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;enq方法将节点加入队尾。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Must initialize</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="acquireQueued方法"><a href="#acquireQueued方法" class="headerlink" title="acquireQueued方法"></a>acquireQueued方法</h3><p>&emsp;&emsp;通过<code>tryAcquire()</code>和<code>addWaiter()</code>，该线程获取资源失败，已经被放入等待队列尾部了。<br>&emsp;&emsp;<code>acquireQueued()</code>用于<strong>在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。</strong><br>&emsp;&emsp;进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 标记是否成功拿到资源，没有拿到资源</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 标记等待过程中是否被中断过</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 拿到前驱节点</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果前驱是head，即该结点已是第二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 拿到资源后，将自己设置为head，所以head指向的节点就是拿到资源的节点</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 将head的前驱断开连接，就是为了放弃以前的有助于GC</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>                <span class="token comment">// 成功拿到资源</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// 返回等待过程中是否被中断，如果被中断了，就是获取失败了</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// 表示被中断了</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="shouldParkAfterFailedAcquire方法"><a href="#shouldParkAfterFailedAcquire方法" class="headerlink" title="shouldParkAfterFailedAcquire方法"></a>shouldParkAfterFailedAcquire方法</h4><p>&emsp;&emsp;这个方法主要用于检查状态，这里主要就是前驱节点的状态。<br>&emsp;&emsp;整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> pred<span class="token punctuation">,</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 拿到前驱的状态</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>        <span class="token comment">// 如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//  如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span>        <span class="token comment">//  注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span>        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="parkAndCheckInterrupt方法"><a href="#parkAndCheckInterrupt方法" class="headerlink" title="parkAndCheckInterrupt方法"></a>parkAndCheckInterrupt方法</h4><p>&emsp;&emsp;这个方法用于将前驱节点的状态设置好后，真正进入等待状态。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 使线程进入waiting状态</span>    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 清除中断状态</span>    <span class="token comment">//如果被唤醒，查看自己是不是被中断的。</span>    <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;acquireQueued方法的流程就是：</p><ol><li>结点进入队尾后，检查状态，找到安全休息点。</li><li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己。</li><li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过。如果没拿到，继续流程1。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;整个流程就是：</p><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回。</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式。</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。<ol><li>这里检测自己是否能拿到资源，拿到就会返回</li><li>这里面会判断是否有被中断过</li><li>如果有被中断，这里面会清除中断过程，不响应中断，外面会将中断补上</li><li>如果没有被中断，这里面会返回false，表示没有中断，外面就不会补</li></ol></li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/AQSACquire.png" alt="acquire流程"></p><h2 id="Release独占模式释放资源"><a href="#Release独占模式释放资源" class="headerlink" title="Release独占模式释放资源"></a>Release独占模式释放资源</h2><h3 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h3><p>&emsp;&emsp;此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。<br>&emsp;&emsp;它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="tryRelease方法"><a href="#tryRelease方法" class="headerlink" title="tryRelease方法"></a>tryRelease方法</h3><p>&emsp;&emsp;跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。<br>&emsp;&emsp;正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。<br>&emsp;&emsp;但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="unparkSuccessor方法"><a href="#unparkSuccessor方法" class="headerlink" title="unparkSuccessor方法"></a>unparkSuccessor方法</h3><p>&emsp;&emsp;此方法用于唤醒等待队列中下一个线程。原理就是<strong>用unpark()唤醒等待队列中最前边的那个未放弃线程。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 这里，node一边为当前线程所在节点</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">//置零当前线程所在的结点状态，允许失败。</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 找到下一个需要唤醒的节点</span>    <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment">// 如果为空或已取消</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 从后向前找</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>            <span class="token comment">// 从这里可以看出，&lt;=0 的结点，都是还有效的结点，这里找到最前面的待唤醒的节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                s <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token comment">// 唤醒</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。<br>&emsp;&emsp;<strong>如果获取锁的线程在release时异常了，没有unpark队列中的其他结点，这时队列中的其他结点会怎么办？这时队列中的其他节点就没法被唤醒了。</strong> 产生异常的可能如下：</p><blockquote><ol><li>线程突然死掉了？可以通过thread.stop来停止线程的执行，但该函数的执行条件要严苛的多，而且函数注明是非线程安全的，已经标明Deprecated；</li><li>线程被interupt了？线程在运行态是不响应中断的，所以也不会抛出异常；</li><li>release代码有bug，抛出异常了？目前来看，Doug Lea的release方法还是比较健壮的，没有看出能引发异常的情形（如果有，恐怕早被用户吐槽了）。除非自己写的tryRelease()有bug，那就没啥说的，自己写的bug只能自己含着泪去承受了。</li></ol></blockquote><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;两种资源共享方式&quot;&gt;&lt;a href=&quot;#两种资源共享方式&quot; class=&quot;headerlink&quot; title=&quot;两种资源共享方式&quot;&gt;&lt;/a&gt;两种资源共享方式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;AQS定义了两种资源共享方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Exclusive：独占方式，只有一个线程能执行，如ReentrantLock。&lt;/li&gt;
&lt;li&gt;Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/"/>
    
    <category term="juc" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/juc/"/>
    
    <category term="AQS" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/juc/AQS/"/>
    
    <category term="Java" scheme="http://linqiankun.gitee.io/hexoblog/categories/Java/"/>
    
    <category term="多线程" scheme="http://linqiankun.gitee.io/hexoblog/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/tags/java/"/>
    
    <category term="juc" scheme="http://linqiankun.gitee.io/hexoblog/tags/juc/"/>
    
    <category term="AQS" scheme="http://linqiankun.gitee.io/hexoblog/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>juc之AQS</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/06/17/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/06/17/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS/</id>
    <published>2021-06-17T07:08:59.000Z</published>
    <updated>2021-06-17T09:25:56.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。<br>&emsp;&emsp;AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。</p><span id="more"></span><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;AQS的核心思想，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，弱国请求的资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。<br>&emsp;&emsp;CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）</strong>，来实现锁的分配。<br>&emsp;&emsp;Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。  </p><p>&emsp;&emsp;<em>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</em></p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/AQS-CLH.png" alt="AQS原理"></p><p>&emsp;&emsp;实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏（Latch）都是AQS的衍生物。</p><hr><h1 id="两种资源共享方式"><a href="#两种资源共享方式" class="headerlink" title="两种资源共享方式"></a>两种资源共享方式</h1><p>&emsp;&emsp;AQS定义了两种资源共享方式：</p><ol><li>Exclusive：独占方式，只有一个线程能执行，如ReentrantLock。</li><li>Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier。</li></ol><p>&emsp;&emsp;AQS底层使用了模板方法模式，如果需要自定义同步器一般的方式是这样：</p><ol><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。如CountDownLatch中的Sync，在CountDownLatch中使用共有的Sync即可。</li></ol><p>&emsp;&emsp;自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了（AbstractQueuedSynchronizer中已经实现了）。自定义同步器实现的时候主要实现下面几种方法：</p><ul><li><strong>isHeldExclusively()：</strong> 该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><strong>tryAcquire(int)：</strong> 独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><strong>tryRelease(int)：</strong> 独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><strong>tryAcquireShared(int)：</strong> 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><strong>tryReleaseShared(int)：</strong> 共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>&emsp;&emsp;一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><hr><h1 id="NODE节点"><a href="#NODE节点" class="headerlink" title="NODE节点"></a>NODE节点</h1><p>&emsp;&emsp;Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值<strong>CANCELLED、SIGNAL、CONDITION、PROPAGATE、0</strong>。  </p><ul><li><strong>CANCELLED(1)：</strong> 表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li><li><strong>SIGNAL(-1)：</strong> 表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li><li><strong>CONDITION(-2)：</strong> 表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li><strong>PROPAGATE(-3)：</strong> 共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li><strong>0：</strong> 新结点入队时的默认状态。</li></ul><p>&emsp;&emsp;负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常。</p><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></li><li><a href="https://blog.csdn.net/mulinsen77/article/details/84583716">AQS详解（面试）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。&lt;br&gt;&amp;emsp;&amp;emsp;AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/"/>
    
    <category term="juc" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/juc/"/>
    
    <category term="AQS" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/juc/AQS/"/>
    
    <category term="Java" scheme="http://linqiankun.gitee.io/hexoblog/categories/Java/"/>
    
    <category term="多线程" scheme="http://linqiankun.gitee.io/hexoblog/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/tags/java/"/>
    
    <category term="juc" scheme="http://linqiankun.gitee.io/hexoblog/tags/juc/"/>
    
    <category term="AQS" scheme="http://linqiankun.gitee.io/hexoblog/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>多线程基础概念</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/06/16/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/06/16/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2021-06-16T08:59:16.000Z</published>
    <updated>2021-06-17T09:24:47.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><p><strong>进程：</strong> 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是<strong>系统进行资源分配和调度的基本单位</strong>，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p><strong>线程：</strong> 线程（thread）是操作系统能够<strong>进行运算<a href="https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6">调度</a>的最小单位</strong>。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位。线程分为用户线程和内核线程。</p><span id="more"></span><p><strong>多线程：</strong> 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p><p><strong>并行：</strong> 多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时运行。</p><p><strong>并发：</strong> 使用CPU调度算法，使用户看起来在同时运行，其实并不是在同时运行。并发一般发生在对系统中的公用资源操作时。</p><p><strong>线程安全：</strong> 指的是希望多线程的执行顺序对执行结果没有影响，用户只需要关心CPU及其他资源是否够用即可。反之，如果不同的执行顺序导致不同的执行结果，那么就说是线程不安全的。</p><p><strong>同步：</strong> 指通过人为干预的情况下达到线程安全的程度。</p><h2 id="进程VS线程："><a href="#进程VS线程：" class="headerlink" title="进程VS线程："></a>进程VS线程：</h2><ol><li> 地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li><li> 通信：通信方式不同，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</li><li> 调度和切换：线程上下文切换比进程上下文切换要快得多。</li><li> 在多线程OS中，进程不是一个可执行的实体。</li></ol><hr><h1 id="线程的状态："><a href="#线程的状态：" class="headerlink" title="线程的状态："></a>线程的状态：</h1><p>Java 给多线程编程提供了内置的支持。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg" alt="线程状态切换"></p><p><strong>新建状态</strong>：一个新产生的线程从新状态开始了它的生命周期。它保持这个状态直到程序start这个线程。此过程线程并未执行。</p><p><strong>就绪状态</strong>：表明线程可以运行，但不是真的在运行，此状态下需要获取cpu才能运行。调用线程的star方法、获取到对象的锁，阻塞状态解除、cpu时间片用完，调用yield()方法、jvm中断此线程。</p><p><strong>运行状态</strong>：线程在阻塞状态获取到cpu使用权，开始实际执行。此状态线程进入run()方法执行方法体。</p><p><strong>阻塞状态</strong>：线程放弃了cpu，调用wait()，sleep()，或同步锁，同步代码块时，失去了所占用的资源，由运行态进入阻塞态，线程将会进入阻塞队列。执行了wait()方法后使线程进入到等待阻塞状态、在进入synchronized代码块，获取同步锁失败时进入同步阻塞、当调用sleep()，join()，或io时进入其它阻塞队列，等待sleep()结束，join()等待其它线程结束，io结束时继续进入就绪状态。</p><p><strong>死亡状态</strong>：线程结束运行后就进入死亡状态。死亡后不会再进入新生态，调用start()方法会报错。通常run()方法运行结束时死亡，或一个未捕获的异常导致猝死。</p><p><strong>超时等待</strong>：处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p><hr><h1 id="队列："><a href="#队列：" class="headerlink" title="队列："></a>队列：</h1><p>等待队列：线程wait()后进入等待队列，等待被其它线程使用notify()或notifyAll()唤醒。</p><p>同步队列：线程被唤醒后，进入同步同步队列，在此队列中，互相竞争对象的锁，当获取到对象的锁之后就进入了就绪状态等待获取cpu时间片运行。</p><hr><h1 id="线程优先级："><a href="#线程优先级：" class="headerlink" title="线程优先级："></a>线程优先级：</h1><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p><p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p><p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><hr><h1 id="参考资料-amp-鸣谢"><a href="#参考资料-amp-鸣谢" class="headerlink" title="参考资料 &amp; 鸣谢"></a>参考资料 &amp; 鸣谢</h1><ul><li><a href="https://my.oschina.net/linqiankun/blog/3193359">多线程之基础概念</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;概念：&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;进程：&lt;/strong&gt; 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是&lt;strong&gt;系统进行资源分配和调度的基本单位&lt;/strong&gt;，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程：&lt;/strong&gt; 线程（thread）是操作系统能够&lt;strong&gt;进行运算&lt;a href=&quot;https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6&quot;&gt;调度&lt;/a&gt;的最小单位&lt;/strong&gt;。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位。线程分为用户线程和内核线程。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/"/>
    
    <category term="多线程" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/tags/java/"/>
    
    <category term="多线程" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>juc之CountDownLatch</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/06/16/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BCountDownLatch/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/06/16/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BCountDownLatch/</id>
    <published>2021-06-16T08:51:34.000Z</published>
    <updated>2021-06-17T06:45:11.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;根据文档：<strong>允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。</strong><br>&emsp;&emsp;一般被称为计数器，可以用做流程控制之类的作用。通常用来让一个线程等待其他的完成过后再继续执行。<br>&emsp;&emsp;通过一个计数器实现，计数器的初始值可以是线程的数量，每当一个线程执行完，计数器的值减一，当计数器的值为0时，表示所有线程都执行完毕，等待的线程就可以继续执行了。</p><span id="more"></span><hr><h1 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h1><p>&emsp;&emsp;一般来说有两种使用模式：</p><ol><li>作为启动信号，让多个线程等待</li><li>作为结束信号，让单个线程等待</li></ol><h2 id="作为启动信号，让多个线程等待"><a href="#作为启动信号，让多个线程等待" class="headerlink" title="作为启动信号，让多个线程等待"></a>作为启动信号，让多个线程等待</h2><p>&emsp;&emsp;实现多个线程开始执行任务的最大并行性，强调的是多个线程在某一时刻同时开始执行。<br>&emsp;&emsp;做法是初始化一个共享的CountDownLatch(1)，将其计算器初始化为1，多个线程在开始执行任务前首先countdownlatch.await()，当主线程调用countDown()时，计数器变为0，多个线程同时被唤醒。<br>&emsp;&emsp;将CountDownLatch的计数器初始化为new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减1 countdownLatch.countDown()，当计数器的值变为0时，在CountDownLatch上await()的线程就会被唤醒。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//准备完毕……运动员都阻塞在这，等待号令</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> parter <span class="token operator">=</span> <span class="token string">"【"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，时间："</span><span class="token operator">+</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>parter <span class="token operator">+</span> <span class="token string">"开始执行……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发令开始....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;运行结果：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">发令开始.....【Thread-0，时间：1623897582895】开始执行……【Thread-4，时间：1623897582895】开始执行……【Thread-3，时间：1623897582895】开始执行……【Thread-2，时间：1623897582895】开始执行……【Thread-1，时间：1623897582895】开始执行……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="作为结束信号，让一个线程等待"><a href="#作为结束信号，让一个线程等待" class="headerlink" title="作为结束信号，让一个线程等待"></a>作为结束信号，让一个线程等待</h2><p>&emsp;&emsp;某个线程在开始运行前等待n个线程执行完毕。例如，启动一个服务时，主线程需要等待多个组件加载完毕，之后继续执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testtwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">+</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finish，"</span> <span class="token operator">+</span> index <span class="token operator">+</span> <span class="token string">"，"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 主线程在阻塞，当计数器==0，就唤醒主线程往下执行</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"主线程:在所有任务运行完成后，进行结果汇总"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;运行结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">finish，4，Thread-4finish，2，Thread-2finish，3，Thread-3finish，0，Thread-0finish，1，Thread-1主线程:在所有任务运行完成后，进行结果汇总<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="官方demo，可以参考"><a href="#官方demo，可以参考" class="headerlink" title="官方demo，可以参考"></a>官方demo，可以参考</h2><p>&emsp;&emsp;demo1，这是一个将启动信号和结束信号结合起来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">&#123;</span> <span class="token comment">// ...</span>    <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CountDownLatch</span> startSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">CountDownLatch</span> doneSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment">// create and start threads</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>startSignal<span class="token punctuation">,</span> doneSignal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// don't let run yet</span>        startSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// let all threads proceed</span>        <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        doneSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// wait for all to finish</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> startSignal<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> doneSignal<span class="token punctuation">;</span>    <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> startSignal<span class="token punctuation">,</span> <span class="token class-name">CountDownLatch</span> doneSignal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>startSignal <span class="token operator">=</span> startSignal<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>doneSignal <span class="token operator">=</span> doneSignal<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            startSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            doneSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// return;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;典型的主线程等待子线程完成的例子。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Driver2</span> <span class="token punctuation">&#123;</span> <span class="token comment">// ...</span>    <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CountDownLatch</span> doneSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Executor</span> e <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment">// create and start threads</span>            e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WorkerRunnable</span><span class="token punctuation">(</span>doneSignal<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        doneSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// wait for all to finish</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">WorkerRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> doneSignal<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token class-name">WorkerRunnable</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> doneSignal<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>doneSignal <span class="token operator">=</span> doneSignal<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token function">doWork</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            doneSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// return;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;简单来说，是通过一个计数器来实现的，计数器的初始值为线程的数量或者指定的值，调用<code>await()</code>方法的线程会被阻塞，直到计数器减到0时才能继续往下执行。<br>&emsp;&emsp;CountDownLatch底层基于AQS实现，构造函数中指定的count直接赋阻值给AQS的state，每次countDown都是release(1)减一，最后减到0时unpark阻塞线程。而调用await()方法时，当前线程就会判断state属性是否为0，如果为0，则继续往下执行，如果不为0，则使当前线程进入等待状态，直到某个线程将state属性置为0，其就会唤醒在await()方法中等待的线程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">4982264981922014374L</span><span class="token punctuation">;</span>    <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Decrement count; signal when transition to zero</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 这里表示如果资源已经释放，就不能在释放一次</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment">// 本次计数剩余量</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 设置剩余量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// 等于0表示，本次计数完成后，释放资源了，await方法就不再阻塞</span>                <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"count &lt; 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span>        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里调用tryAcquireShared方法尝试获取资源，返回负数表示失败，返回整数则表示成功，失败了就加入同步队列。<br>&emsp;&emsp;tryAcquireShared方法中则根据计数来判断是否成功，如果计数为0，则计数完毕，返回成功。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果资源释放了，唤醒同步队列中的线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// unpark</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里面会尝试进行资源释放，如果资源释放了就唤醒同步队列中的线程。</p><h2 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h2><ol><li>创建一个CountDownLatch，并赋予一个数值，这个值表示需要计数的次数，每次countdown算一次。</li><li>在主线程调用await方法，表示计数器完成前都不能动，await方法的内部实现依赖于内部的AQS，调用await方法的时候会尝试去获取资源，成功条件是state=0，也就是说除非countdown了count次之后，才能成功，失败的话当前线程进行休眠。</li><li>在子线程调用countDown方法，每次调用都会使内部的state-1，state为0时资源释放，await方法不在阻塞。</li></ol><hr><h1 id="参考资料-amp-鸣谢"><a href="#参考资料-amp-鸣谢" class="headerlink" title="参考资料 &amp; 鸣谢"></a>参考资料 &amp; 鸣谢</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/148231820">CountDownLatch的两种常用场景</a></li><li><a href="https://www.cnblogs.com/Lee_xy_z/p/10470181.html">CountDownLatch的理解和使用</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;根据文档：&lt;strong&gt;允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;一般被称为计数器，可以用做流程控制之类的作用。通常用来让一个线程等待其他的完成过后再继续执行。&lt;br&gt;&amp;emsp;&amp;emsp;通过一个计数器实现，计数器的初始值可以是线程的数量，每当一个线程执行完，计数器的值减一，当计数器的值为0时，表示所有线程都执行完毕，等待的线程就可以继续执行了。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/"/>
    
    <category term="juc" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/juc/"/>
    
    <category term="Java" scheme="http://linqiankun.gitee.io/hexoblog/categories/Java/"/>
    
    <category term="多线程" scheme="http://linqiankun.gitee.io/hexoblog/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/tags/java/"/>
    
    <category term="juc" scheme="http://linqiankun.gitee.io/hexoblog/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/06/08/md/java/IO/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/06/08/md/java/IO/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2021-06-08T09:55:46.000Z</published>
    <updated>2021-06-09T06:13:38.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;IO多路复用是一个IO模型，指的是复用同一个线程监控多路网络连接。<br>&emsp;&emsp;现在大多的IO多路复用都是同步模型，Reactor模式。  </p><span id="more"></span><h2 id="Reactor和Proactor"><a href="#Reactor和Proactor" class="headerlink" title="Reactor和Proactor"></a>Reactor和Proactor</h2><p>&emsp;&emsp;两种多路复用IO方案。<br>&emsp;&emsp;在进行IO编程中，通常用到两种模式：Reactor和Proactor。<br>&emsp;&emsp;Reactor模式是基于同步IO的，而Proactor模式是和异步IO相关的。<br>&emsp;&emsp;Java的NIO就是Reactor，当有事件触发时，服务器端得到通知，进行相应的处理。AIO引入的是Proactor模式。  </p><hr><h1 id="多路复用解决的问题"><a href="#多路复用解决的问题" class="headerlink" title="多路复用解决的问题"></a>多路复用解决的问题</h1><p>&emsp;&emsp;IO实现主要有BIO和NIO两种机制，AIO用的比较少。<br>&emsp;&emsp;他们都会有多多少少的问题。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><ol><li>每个请求都需要创建独立的线程，与对应的客户端进行数据处理。</li><li>当并发数大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则当前线程会一直阻塞在 Read 操作上，造成线程资源浪费。</li></ol><hr><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>&emsp;&emsp;IO多路复用在底层实现上主要有三种实现方式：select、poll、epoll。<br>&emsp;&emsp;这些方法是操作系统提供给应用的接口，毕竟所有的IO最终都是落实在操作系统的IO上。<br>&emsp;&emsp;一个个人理解，java中的NIO包，在使用Selector的情况下就是使用了IO多路复用，windows下底层用的是poll方法。</p><p><a href="https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA">一举拿下 I/O 多路复用！</a></p><p>&emsp;&emsp;在linux中一切皆是文件传输，网络的Socket通信也是，所以会为每一个Socket建立一个文件描述符，保存在操作系统内核空间中，select，poll，epoll采用不同的机构来存储这些文件描述符。<br>&emsp;&emsp;这里的文件描述符也可以认为就是Socket。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>&emsp;&emsp;select 实现多路复用的方式是，将已连接的Socket都放到一个文件描述符集合，然后调用select函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此Socket标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的Socket，然后再对其处理。这个过程中需要用户态到内核态，内核态到用户态两次拷贝。<br>&emsp;&emsp;select使用固定长度的BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在Linux系统中，由内核中的FD_SETSIZE限制， 默认最大值为1024，只能监听0~1023的文件描述符。<br>&emsp;&emsp;对于select这种方式，需要进行2次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生2次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>&emsp;&emsp;poll与select相比没有什么变化，相对于select，poll不在使用BitsMap存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了select的文件描述符个数限制，当然还会受到系统文件描述符限制。<br>&emsp;&emsp;都是使用「线性结构」存储进程关注的Socket集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>&emsp;&emsp;epoll在内核中采用红黑树存储所有的文件描述符，将需要监控的Socket通过epoll_ctl()函数加入内核的红黑树里，这样就不需要像select/poll每次操作时都传入整个socket集合，只需要传入一个待检测的socket，减少了内核和用户空间大量的数据拷贝和内存分配。<br>&emsp;&emsp;epoll采用事件驱动机制，内部维护了一个链表来记录就绪事件，当某个socket有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用epoll_wait()函数时，只会返回有事件发生的文件描述符的个数，不需要像select/poll那样轮询扫描整个socket集合，大大提高了检测的效率。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/epoll%E5%8E%9F%E7%90%86.jpg" alt="epoll原理"></p><h3 id="事件触发模式"><a href="#事件触发模式" class="headerlink" title="事件触发模式"></a>事件触发模式</h3><p>&emsp;&emsp;epoll支持两种事件触发模式，分别是边缘触发（ET）和水平触发（LT）。epoll默认采用水平触发模式，select/poll只有水平触发模式。  </p><ul><li><strong>边缘触发：</strong> 使用边缘触发模式时，当被监控的Socket描述符上有可读事件发生时，服务器端只会从epoll_wait中苏醒一次，即使进程没有调用read函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完。<strong>边缘触发模式一般和非阻塞IO一起搭配使用</strong>，因为边缘模式下一般会循环的从文件描述符（Socket）读取数据，如果是阻塞的，阻塞IO就会阻塞，程序无法继续执行。</li><li><strong>水平触发：</strong> 使用水平触发模式时，当被监控的Socket上有可读事件发生时，服务器端不断地从epoll_wait中苏醒，直到内核缓冲区数据被read函数读完才结束，目的是告诉我们有数据需要读取。</li></ul><p>&emsp;&emsp;一般而言边缘触发的效率高于水平触发。<br>&emsp;&emsp;水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。np</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>&emsp;&emsp;一切因文件描述符而起。</p><table><thead><tr><th>—</th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>数据结构</td><td>bitmap</td><td>动态数组</td><td>红黑树</td></tr><tr><td>最大连接数</td><td>1024</td><td>无上线</td><td>无上限</td></tr><tr><td>fd拷贝</td><td>每次调用select拷贝</td><td>每次调用poll拷贝</td><td>fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝</td></tr><tr><td>工作效率</td><td>轮询：O(n)</td><td>轮询：O(n)</td><td>回调：O(1)</td></tr></tbody></table><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;网路通信中的IO模型，从最基础的阻塞IO模型，到多进程，多线程模型，在发展到多路复用IO模型。<br>&emsp;&emsp;传统的多线程、多进程模型，多个进程、线程的调度，和资源的消耗，上下文切换都会称为它们的瓶颈。<br>&emsp;&emsp;多路复用IO解决了上面的问题，linux下提供了三种API：select，poll，epoll。<br>&emsp;&emsp;select和poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的Socket集合。它们的缺陷在于，当客户端越多，Socket集合越大时，它的遍历和拷贝会带来很大的开销。</p><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？</a></li><li><a href="https://segmentfault.com/a/1190000037714804">理解什么是BIO/AIO/NIO</a></li><li><a href="https://juejin.cn/post/6844904200141438984">彻底理解IO多路复用</a></li><li><a href="https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA">一举拿下 I/O 多路复用！</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;IO多路复用是一个IO模型，指的是复用同一个线程监控多路网络连接。&lt;br&gt;&amp;emsp;&amp;emsp;现在大多的IO多路复用都是同步模型，Reactor模式。  &lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/"/>
    
    <category term="io" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/io/"/>
    
    
    <category term="io" scheme="http://linqiankun.gitee.io/hexoblog/tags/io/"/>
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/tags/java/"/>
    
    <category term="NIO" scheme="http://linqiankun.gitee.io/hexoblog/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>NIO</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/06/08/md/java/IO/NIO/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/06/08/md/java/IO/NIO/</id>
    <published>2021-06-08T02:25:34.000Z</published>
    <updated>2021-06-08T08:20:55.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;NIO是当下非常火热的一种IO工作方式，它能够解决传统BIO的痛点：阻塞。<br>&emsp;&emsp;NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。<br>&emsp;&emsp;同步非阻塞式IO以块的方式处理数据，面向缓存区的，采用多路复，Reactor模式，基于事件驱动。Netty是实现了NIO的一个流行框架，JBoss的。</p><span id="more"></span><ul><li>BIO如果遇到IO阻塞时，线程将会被挂起，直到IO完成后才唤醒线程，线程切换带来了额外的开销。</li><li>BIO中每个IO都需要有对应的一个线程去专门处理该次IO请求，会让服务器的压力迅速提高。</li></ul><hr><h1 id="NIO与BIO的区别"><a href="#NIO与BIO的区别" class="headerlink" title="NIO与BIO的区别"></a>NIO与BIO的区别</h1><p>&emsp;&emsp;BIO是面向流的IO，它建立的通道都是单向的，所以输入和输出流的通道不相同，必须建立2个通道，通道内的都是传输==0101001···==的字节数据。<br>&emsp;&emsp;NIO是面向缓冲区的，它会建立一个通道（Channel），该通道我们可以理解为铁路，该铁路上可以运输各种货物，而通道上会有一个缓冲区（Buffer）用于存储真正的数据，缓冲区我们可以理解为一辆火车。通道（铁路）只是作为运输数据的一个连接资源，而真正存储数据的是缓冲区（火车）。即通道负责传输，缓冲区负责存储。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/BIO%E7%BB%93%E6%9E%84.jpg" alt="BIO结构"><br><img src="https://gitee.com/linqiankun/picurl/raw/master/java/NIO%E7%BB%93%E6%9E%84.jpg" alt="NIO结构"></p><p>&emsp;&emsp;区别基本可以用下表表示：</p><table><thead><tr><th>BIO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流</td><td>面向缓冲区</td></tr><tr><td>单向通道</td><td>双向通道</td></tr><tr><td>阻塞IO</td><td>非阻塞IO</td></tr><tr><td>—</td><td>选择器Selectors</td></tr></tbody></table><hr><h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><h2 id="缓冲区（Buffer）"><a href="#缓冲区（Buffer）" class="headerlink" title="缓冲区（Buffer）"></a>缓冲区（Buffer）</h2><p>&emsp;缓冲区是存储数据的区域，在 Java 中，缓冲区就是数组，为了可以操作不同数据类型的数据，Java 提供了许多不同类型的缓冲区，除了布尔类型以外，其它基本数据类型都有对应的缓冲区数组对象。<br>&emsp;&emsp;因为NIO是基于缓冲的，所以buffer是最底层的必要类，这也是IO和NIO的根本不同，虽然stream等有buffer开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而NIO却是直接读到buffer中进行操作。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/NIOBuffer.jpg" alt="Buffer"></p><h2 id="通道（Channel）"><a href="#通道（Channel）" class="headerlink" title="通道（Channel）"></a>通道（Channel）</h2><p>&emsp;&emsp;类似于IO的stream，但是不同的是除了FileChannel，其他的channel都能以非阻塞状态运行。FileChannel执行的是文件的操作，可以直接DMA操作内存而不依赖于CPU。其他比如socketchannel就可以在数据准备好时才进行调用。IO分为磁盘IO和网络IO，所以通常意义上的NIO是指网络IO，即除FileChnnel之外的channel都可以非阻塞。<br>&emsp;&emsp;通道是可以双向读写的，传统的 BIO 需要使用输入/输出流表示数据的流向，在 NIO 中可以减少通道资源的消耗。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/NIOChannel.jpg" alt="Channel"></p><p>可以通过 getChannel() 方法获取一个通道，支持获取通道的类如下：</p><ul><li>文件IO：FileInputStream、FileOutputStream、RandomAccessFile</li><li>TCP网络IO：Socket、ServerSocket</li><li>UDP网络IO：DatagramSocket</li></ul><h2 id="选择器（Selectors）"><a href="#选择器（Selectors）" class="headerlink" title="选择器（Selectors）"></a>选择器（Selectors）</h2><p>&emsp;&emsp;选择器是提升IO性能的灵魂之一，它底层利用了多路复用IO机制，让选择器可以监听多个IO连接，根据IO的状态响应到服务器端进行处理。通俗地说：选择器可以监听多个IO连接，而传统的BIO每个IO连接都需要有一个线程去监听和处理。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/NIOSelectors.jpg" alt="Selectors"></p><p>&emsp;&emsp;在BIO中，每个Socket都需要有一个专门的线程去处理每个请求，而在NIO中，只需要一个Selector即可监听各个Socket请求，而且Selector并不是阻塞的，所以不会因为多个线程之间切换导致上下文切换带来的开销。<br>&emsp;&emsp;在Java NIO中，选择器是使用Selector类表示，Selector可以接收各种IO连接，在IO状态准备就绪时，会通知该通道注册的 elector，Selector在下一次轮询时会发现该IO连接就绪，进而处理该连接，Selector选择器主要用于网络IO当中。<br>&emsp;&emsp;选择器的作用就是：<strong>监听多个IO通道，当有通道就绪时选择器会轮询发现该通道，并做相应的处理。那么IO状态分为很多种，我们如何去识别就绪的通道是处于哪种状态呢？在Java中提供了选择键（SelectionKey）。</strong></p><h3 id="选择键（SelectionKey）"><a href="#选择键（SelectionKey）" class="headerlink" title="选择键（SelectionKey）"></a>选择键（SelectionKey）</h3><p>&emsp;&emsp;在选择器轮询到有就绪通道时，会返回这些通道的就绪选择键（SelectionKey），通过选择键可以获取到通道进行操作。<br>&emsp;&emsp;java中提供了四种选择键：</p><ul><li>SelectionKey.OP_READ：套接字通道准备好进行读操作</li><li>SelectionKey.OP_WRITE：套接字通道准备好进行写操作</li><li>SelectionKey.OP_ACCEPT：服务器套接字通道接受其它通道</li><li>SelectionKey.OP_CONNECT：套接字通道准备完成连接</li></ul><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://juejin.cn/post/6869537077122301965#heading-6">为什么一个还没毕业的大学生能够把 IO 讲的这么好？</a></li><li><a href="https://segmentfault.com/a/1190000021493582">BIO、NIO、AIO疑点解析</a></li><li><a href="https://segmentfault.com/a/1190000037714804">理解什么是BIO/NIO/AIO</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;NIO是当下非常火热的一种IO工作方式，它能够解决传统BIO的痛点：阻塞。&lt;br&gt;&amp;emsp;&amp;emsp;NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。&lt;br&gt;&amp;emsp;&amp;emsp;同步非阻塞式IO以块的方式处理数据，面向缓存区的，采用多路复，Reactor模式，基于事件驱动。Netty是实现了NIO的一个流行框架，JBoss的。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/"/>
    
    <category term="io" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/io/"/>
    
    
    <category term="io" scheme="http://linqiankun.gitee.io/hexoblog/tags/io/"/>
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/tags/java/"/>
    
    <category term="网络" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="nio" scheme="http://linqiankun.gitee.io/hexoblog/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>java传统IO流-BIO</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/06/08/md/java/IO/java%E4%BC%A0%E7%BB%9FIO%E6%B5%81-BIO/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/06/08/md/java/IO/java%E4%BC%A0%E7%BB%9FIO%E6%B5%81-BIO/</id>
    <published>2021-06-08T02:25:22.000Z</published>
    <updated>2021-06-10T06:35:40.086Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;数据都以二进制存储在设备中，流就是将这些数据以二进制在各种设备间进行传输。  </p><span id="more"></span><p>&emsp;&emsp;IO流的核心特点：</p><ol><li>顺序读写：读写数据时，大部分情况下都是按照顺序读写，读取时从文件开头的第一个字节到最后一个字节，写出时也是也如此（RandomAccessFile 可以实现随机读写）。</li><li>读写数据时本质上都是对字节数组做读取和写出操作，即使是字符流，也是在字节流基础上转化为一个个字符，所以字节数组是 IO 流读写数据的本质。</li></ol><hr><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>&emsp;&emsp;流根据数据的流向不同分为：输入流和输出流。</p><ul><li>输入流：从磁盘或者其它外设中将数据输入到进程中。</li><li>输出流：从进程中将数据输出到磁盘或者其他外设中保存。</li></ul><h2 id="字符流-amp-字节流"><a href="#字符流-amp-字节流" class="headerlink" title="字符流&amp;字节流"></a>字符流&amp;字节流</h2><p>&emsp;&emsp;根据处理数据的基本单位不同分为：字节流和字符流。</p><ul><li>字节流：以<strong>字节（1Byte=8bit）</strong> 为单位做数据的传输。</li><li>字符流：以字符为单位做数据的传输。<blockquote><p>字符流的本质也是通过字节流读取，Java 中的字符采用 Unicode 标准，在读取和输出的过程中，通过以字符为单位，查找对应的码表将字节转换为对应的字符。</p></blockquote></li></ul><p>&emsp;&emsp;根据这两种分类，在java.io包中定义了四个顶层的抽象：</p><table><thead><tr><th>数据类型/数据流向</th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>&emsp;&emsp;在这四个顶层抽象下面还有很多的成员，分别有不同的作用。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/io.jpg" alt="io"><br><img src="https://gitee.com/linqiankun/picurl/raw/master/java/IO.jpeg" alt="IO"></p><p>&emsp;&emsp;java中处理传输用的外，还提供了一堆扩展的流，比如压缩，序列化用的。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/JAVAIO.png" alt="IO"></p><p>&emsp;&emsp;这其中还提供了用于字节流与字符流中间的转换流。</p><table><thead><tr><th>转换流/数据类型</th><th>转换</th></tr></thead><tbody><tr><td>输入（字节-&gt;字符）</td><td>InputStreamReader</td></tr><tr><td>输出（字符-&gt;字节）</td><td>OutputStreamWriter</td></tr></tbody></table><blockquote><p>在存储设备上，所有数据都是以字节为单位存储的，所以输入到内存时必定是以字节为单位输入，输出到存储设备时必须是以字节为单位输出，字节流才是计算机最根本的存储方式，而字符流是在字节流的基础上对数据进行转换，输出字符，但每个字符依旧是以字节为单位存储的。</p></blockquote><h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><p>&emsp;&emsp;这是对流的根据功能的再一次分类。</p><ul><li>节点流：节点流是真正传输数据的流对象，用于向特定的一个地方（节点）读写数据，称为节点流。</li><li>处理流：处理流是对节点流的封装，使用外层的处理流读写数据，本质上是利用节点流的功能，外层的处理流可以提供额外的功能。处理流的基类都是以Filter开头。</li></ul><p>&emsp;&emsp;还有将两个流合并的SequenceInputOutStream。</p><hr><h1 id="字节流和字符流的转换"><a href="#字节流和字符流的转换" class="headerlink" title="字节流和字符流的转换"></a>字节流和字符流的转换</h1><p>&emsp;&emsp;从任何地方把数据读入到内存都是先以字节流形式读取，即使是使用字符流去读取数据，依然成立，因为数据永远是以字节的形式存在于互联网和硬件设备中，字符流是通过字符集的映射，才能够将字节转换为字符。  </p><p>&emsp;&emsp;java中提供了两种转换流：</p><ul><li>InputStreamReader：从字节流转换为字符流，将字节数据转换为字符数据读入到内存。</li><li>OutputStreamWriter：从字符流转换为字节流，将字符数据转换为字节数据写出到指定位置。</li></ul><blockquote><ol><li>传统的 BIO 是以流为基本单位处理数据的，想象成水流，一点点地传输字节数据，IO 流传输的过程永远是以字节形式传输。</li><li>字节流和字符流的区别在于操作的数据单位不相同，字符流是通过将字节数据通过字符集映射成对应的字符，字符流本质上也是字节流。</li></ol></blockquote><hr><h1 id="整理"><a href="#整理" class="headerlink" title="整理"></a>整理</h1><p>&emsp;&emsp;所有的流基本如下：</p><table><thead><tr><th>数据类型</th><th>基于字节的Input</th><th>基于字节的Output</th><th>基于字符的Input</th><th>基于字符的Output</th></tr></thead><tbody><tr><td>基础</td><td>InputStream</td><td>OutputStream</td><td>Reader</td><td>Writer</td></tr><tr><td>转换</td><td></td><td></td><td>InputStreamReader</td><td>OutputStreamWriter</td></tr><tr><td>数组</td><td>ByteArrayInputStream</td><td>ByteArrayOutputStream</td><td>CharArrayReader</td><td>CharArrayWriter</td></tr><tr><td>文件</td><td>FileInputStream、RandomAccessFile</td><td>FileOutputStream、RandomAccessFile</td><td>FileReader</td><td>FileWriter</td></tr><tr><td>管道</td><td>PipedInputStream</td><td>PipedOutputStream</td><td>PipedReader</td><td>PipedWriter</td></tr><tr><td>缓冲</td><td>BufferedInputStream</td><td>BufferedOutputStream</td><td>BufferedReader</td><td>BufferedWriter</td></tr><tr><td>过滤</td><td>FilterInputStream</td><td>FilterOutputStream</td><td>FilterReader</td><td>FilterWriter</td></tr><tr><td>解析</td><td>PushbackInputStream、StreamTokenizer</td><td></td><td>PushbackReader、LineNumberReader</td><td></td></tr><tr><td>字符串</td><td></td><td></td><td>StringReader</td><td>StringWriter</td></tr><tr><td>数据</td><td>DataInputStream</td><td>DataOutputStream</td><td></td><td></td></tr><tr><td>数据格式化</td><td></td><td>PrintStream</td><td></td><td>PrintWriter</td></tr><tr><td>对象</td><td>ObjectInputStream</td><td>ObjectOutputStream</td><td></td><td></td></tr><tr><td>合并流</td><td>SequenceInputStream</td><td></td><td></td><td></td></tr></tbody></table><hr><h1 id="传统BIO的问题"><a href="#传统BIO的问题" class="headerlink" title="传统BIO的问题"></a>传统BIO的问题</h1><ol><li>每个请求都需要创建独立的线程，与对应的客户端进行数据处理。</li><li>当并发数大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则当前线程会一直阻塞在Read操作上，造成线程资源浪费。</li></ol><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><p><a href="https://segmentfault.com/a/1190000037714804">JAVA IO BIO NIO AIO</a></p><ul><li><a href="https://juejin.cn/post/6844903664256024584">BIO，NIO，AIO概览</a></li><li><a href="https://juejin.cn/post/6869537077122301965#heading-6">为什么一个还没毕业的大学生能够把 IO 讲的这么好？</a></li><li><a href="https://segmentfault.com/a/1190000037714804">理解什么是BIO/NIO/AIO</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;数据都以二进制存储在设备中，流就是将这些数据以二进制在各种设备间进行传输。  &lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/"/>
    
    <category term="io" scheme="http://linqiankun.gitee.io/hexoblog/categories/java/io/"/>
    
    
    <category term="io" scheme="http://linqiankun.gitee.io/hexoblog/tags/io/"/>
    
    <category term="java" scheme="http://linqiankun.gitee.io/hexoblog/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq集群简介</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/31/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/31/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B/</id>
    <published>2021-05-31T06:20:57.000Z</published>
    <updated>2021-05-31T06:44:29.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;Rocketmq的四部分每一部分都可以进行集群部署。<a href="https://www.yuque.com/jiufenshiren/mvgau4/cn_operation#b5212acf">集群搭建</a></p><span id="more"></span><h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><p>&emsp;&emsp;NameServer通常是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息。</p><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>&emsp;&emsp;与NameServer相比，Broker的集群比较复杂些。<br>&emsp;&emsp;Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。<br>&emsp;&emsp;broker集群可以分为：单Master模式，多Master模式，多Master多Slave模式。</p><h3 id="单Master模式"><a href="#单Master模式" class="headerlink" title="单Master模式"></a>单Master模式</h3><p>&emsp;&emsp;这种模式一般用于本地学习，或者测试，不适合线上使用，一旦单个Broker挂掉了，会造成所有通信失败。</p><h3 id="多Master模式"><a href="#多Master模式" class="headerlink" title="多Master模式"></a>多Master模式</h3><p>&emsp;&emsp;全是Master，没有Slave。当然，一个broker宕机了，应用是无影响的，缺点在于宕机的Master上未被消费的消息在Master没有恢复之前不可以订阅。<br>&emsp;&emsp;配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高。<br>&emsp;&emsp;缺点是：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</p><h3 id="多Master多Slave模式"><a href="#多Master多Slave模式" class="headerlink" title="多Master多Slave模式"></a>多Master多Slave模式</h3><p>&emsp;&emsp;这种又可以分为两种，根据数据同步的时间分为，异步复制，同步双写。</p><h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><p>&emsp;&emsp;多对Master-Slave，高可用！采用异步复制的方式，主备之间短暂延迟，MS级别。Master宕机，消费者可以从Slave上进行消费，不受影响，但是Master的宕机，会导致丢失掉极少量的消息。<br>&emsp;&emsp;即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样。<br>&emsp;&emsp;缺点在于：Master宕机，磁盘损坏情况下会丢失少量消息。</p><h4 id="同步双写"><a href="#同步双写" class="headerlink" title="同步双写"></a>同步双写</h4><p>&emsp;&emsp;和上面的区别点在于采用的是同步方式，也就是在Master/Slave都写成功的前提下，向应用返回成功，可见不论是数据，还是服务都没有单点，都非常可靠！缺点在于同步的性能比异步稍低。<br>&emsp;&emsp;据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高。<br>&emsp;&emsp;缺点是：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%90%8C%E6%AD%A5%E5%8F%8C%E5%86%99%E5%92%8C%E5%BC%82%E6%AD%A5%E5%8F%8C%E5%86%99.png" alt="同步双写和异步双写"></p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/mq%E9%9B%86%E7%BE%A4%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94.png" alt="集群方式对比"></p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95.png" alt="高可用测试"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Rocketmq的四部分每一部分都可以进行集群部署。&lt;a href=&quot;https://www.yuque.com/jiufenshiren/mvgau4/cn_operation#b5212acf&quot;&gt;集群搭建&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
    <category term="分布式" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq消息可靠性</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/28/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/28/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/</id>
    <published>2021-05-28T02:48:52.000Z</published>
    <updated>2021-05-31T08:32:28.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h1><p>&emsp;&emsp;指的是消费者消费消息失败后，mq需要让消费者重新消费一次。</p><span id="more"></span><p>&emsp;&emsp;只有消费模式处于集群模式下时，才会有重试机制，广播模式下是没有重试机制的。<br>&emsp;&emsp;消费者消费消息失败通常有以下两种情况：</p><ol><li>消息的原因，反序列化失败，消息本身数据无法处理等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li><li>消费者依赖的下游服务不可用，遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li></ol><p>&emsp;&emsp;RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。<br>&emsp;&emsp;考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。<br>&emsp;&emsp;RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p><p>&emsp;&emsp;实际上，以下情况会触发消息重试：</p><ol><li>业务消费方返回ConsumeConcurrentlyStatus.RECONSUME_LATER。</li><li>业务消费方返回null。</li><li>业务消费方抛出异常。</li></ol><p>&emsp;&emsp;对于抛出异常的情况，只要我们在业务逻辑中显式抛出异常或者非显式抛出异常，broker也会重新投递消息，如果业务对异常做了捕获，那么该消息将不会发起重试。因此对于需要重试的业务，消费方在捕获异常时要注意返回ConsumeConcurrentlyStatus.RECONSUME_LATER或null，输出日志并打印当前重试次数。推荐返回ConsumeConcurrentlyStatus.RECONSUME_LATER。</p><p>&emsp;&emsp;RocketMQ可在broker.conf文件中配置Consumer端的重试次数和重试时间间隔，也可以在代码里控制重试次数。</p><h2 id="重试逻辑"><a href="#重试逻辑" class="headerlink" title="重试逻辑"></a>重试逻辑</h2><p>&emsp;&emsp;rocketmq使用时间衰减策略，进行重试。<br>&emsp;&emsp;时间间隔可以为：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token attr-name">messageDelayLevel</span><span class="token punctuation">=</span><span class="token attr-value">1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&emsp;&emsp;重试逻辑：</p><ol><li>首先判断消费端有没有显式设置最大重试次数，如果没有就默认16次。</li><li>当消息发送失败，mq会发起消费重试。</li><li>判断消息当前重试次数是否等于大于最大重试次数，如果达到，或者配置的次数小于0，获取死信队列，将超时的消息投递至死信队列中。</li><li>正常需要重试的消息，将采用延时消息的模式进行重试。将新的延时消息（就是原来的需要重试的消息）重新刷盘。采用定时任务进行投递。</li></ol><p>&emsp;&emsp;对于重试的消息，mq并不会从原队列获取消息，而是创建了一个新的topic进行保存。<br>&emsp;&emsp;对于所有消费者消费失败的消息，rocketMQ都会把重试的消息 重新new出来（即上文提到的MessageExtBrokerInner对象），然后投递到主题SCHEDULE_TOPIC_XXXX下的队列中，然后由定时任务进行调度重试，而重试的周期符合我们在上文中提到的delayLevel周期。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">重试代码还没有搞上来<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h1 id="消息重投（生产者发送失败，未收到mq的ACK）"><a href="#消息重投（生产者发送失败，未收到mq的ACK）" class="headerlink" title="消息重投（生产者发送失败，未收到mq的ACK）"></a>消息重投（生产者发送失败，未收到mq的ACK）</h1><p>&emsp;&emsp;生产者在发送消息时，同步消息失败则会重投，异步消息失败有重试，oneway没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题。<br>&emsp;&emsp;消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer负载变化也会导致重复消息。<br>&emsp;&emsp;如下方法可以设置消息重试策略：</p><ol><li>retryTimesWhenSendFailed：同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li><li>retryTimesWhenSendAsyncFailed：异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li><li>retryAnotherBrokerWhenNotStoreOK：消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li></ol><hr><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><p>&emsp;&emsp;消息重试超过一定次数的消息，将会进入死信队列。<br>&emsp;&emsp;死信队列逻辑：</p><ol><li>首先判断消息当前重试次数是否大于等于16（默认是16），或者消息延迟级别是否小于0。</li><li>只要满足上述的任意一个条件，设置新的topic（死信topic）为：%DLQ%+consumerGroup。</li><li>进行前置属性的添加。<blockquote><p>备份原先topic和队列id等。</p></blockquote></li><li>将死信消息投递到上述步骤2建立的死信topic对应的死信队列中并落盘，使消息持久化。</li></ol><p>&emsp;&emsp;死信队列中的消息需要人工介入处理，在RocketMQ中，可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p><hr><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>&emsp;&emsp;生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。  </p><h2 id="生产者流控"><a href="#生产者流控" class="headerlink" title="生产者流控"></a>生产者流控</h2><p>&emsp;&emsp;生产者流控模式下，不会进行消息重投。  </p><ol><li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。操作系统页缓存繁忙。</li><li>如果开启transientStorePoolEnable == true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</li><li>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</li><li>broker通过拒绝send 请求方式实现流量控制。</li></ol><h2 id="消费者流控"><a href="#消费者流控" class="headerlink" title="消费者流控"></a>消费者流控</h2><p>&emsp;&emsp;消费者流控的结果是降低拉取频率。</p><ol><li>消费者本地缓存消息数量pullThresholdForQueue时，默认1000。</li><li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。</li><li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</li></ol><hr><h1 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h1><p>&emsp;&emsp;个人理解，产生流控时，必定伴随着消息堆积。mq中将消息刷盘，记录消费进度，天然支持消息堆积。</p><hr><h1 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h1><p>&emsp;&emsp;mq支持消息的高可靠，影响可靠性的几种情况：</p><ol><li>Broker非正常关闭</li><li>Broker异常Crash</li><li>OS Crash</li><li>机器掉电，但是能立即恢复供电情况</li><li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li><li>磁盘设备损坏</li></ol><p>&emsp;&emsp;1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。<br>&emsp;&emsp;5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。</p><h2 id="消息刷盘"><a href="#消息刷盘" class="headerlink" title="消息刷盘"></a>消息刷盘</h2><p>&emsp;&emsp;消息存储是RocketMQ中最为复杂和最为重要的一部分。</p><p><a href="https://www.yuque.com/jiufenshiren/mvgau4/cn_design#512cc468">消息存储</a></p><h2 id="MessageQuene与ConsumeQuene"><a href="#MessageQuene与ConsumeQuene" class="headerlink" title="MessageQuene与ConsumeQuene"></a>MessageQuene与ConsumeQuene</h2><p>&emsp;&emsp;个人理解，MessageQuene是逻辑上的东西，是将Topic进一步划分之后的字主题，也是消息存储队列。<br>&emsp;&emsp;ConsumeQuene又称为消费逻辑队列，是在文件系统中存在实际的文件的，内存存储者Commitlog中消息的位置（commit offset，消息长度，tag的hashcode值）等相关信息，可以看作是消息的索引文件。<br>&emsp;&emsp;根据ConsumeQuene文件的组织方式，可以看出，相同Topic下相同MessageQuene下的ConsumeQuene文件在相同的位置（相同的文件夹内）。<br>&emsp;&emsp;CommitLog文件存储着所有的消息，名称从0开始，文件名称代表了文件中第一个消息的偏移量，文件名称长度20位，每个大小最大1G。<br>&emsp;&emsp;ConsumeQuene文件，按照topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。这里的queneId就是MessageQuene的id，同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M。可以看作是CommitLog文件按照位置，quene的索引文件。<br>&emsp;&emsp;IndexFile，索引文件，提供了一种按照key或者时间区间查询消息的索引。index文件的存储位置是：$HOME \store\index${fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p><p>&emsp;&emsp;生产者发送消息的过程，会将消息发送到指定的Topic，然后根据负载均衡选择该Topic下的一个MessageQuene，实际上发送消息时，会将消息保存进CommitLog文件，同时会在对应Quene的ConsumeQuene文件中写入索引，也会在Index文件中写入时间索引。<br>&emsp;&emsp;消费者消费时，会根据负载均衡到的MessageQuene定位到具体的文件夹，在根据消息消费进度，确定具体的ConsumeQuene文件，从而在CommitLog文件中查出具体的消息。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;消息重试&quot;&gt;&lt;a href=&quot;#消息重试&quot; class=&quot;headerlink&quot; title=&quot;消息重试&quot;&gt;&lt;/a&gt;消息重试&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;指的是消费者消费消息失败后，mq需要让消费者重新消费一次。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq负载均衡</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/27/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/27/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2021-05-27T09:00:22.000Z</published>
    <updated>2021-05-27T11:46:29.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>&emsp;&emsp;RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。<br>&emsp;&emsp;<a href="https://www.yuque.com/jiufenshiren/mvgau4/cn_design#b59a14cd">官方的解释</a></p><span id="more"></span><h2 id="生产端负载均衡"><a href="#生产端负载均衡" class="headerlink" title="生产端负载均衡"></a>生产端负载均衡</h2><p>&emsp;&emsp;Producer端在发送消息的时候，会先根据Topic找到指定的TopicPublishInfo，在获取了TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列（MessageQueue）进行发送消息。（这里采用轮询）<br>&emsp;&emsp;具体的容错策略均在MQFaultStrategy这个类中定义。这里有一个sendLatencyFaultEnable开关变量，如果开启，在随机递增取模的基础上，再过滤掉not available的Broker代理。<br>&emsp;&emsp;所谓的”latencyFaultTolerance”，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%8F%91%E9%80%81%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="发送端负载均衡"></p><h2 id="消费端负载均衡"><a href="#消费端负载均衡" class="headerlink" title="消费端负载均衡"></a>消费端负载均衡</h2><p>&emsp;&emsp;在RocketMQ中，Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。<br>&emsp;&emsp;在两种基于拉模式的消费方式（Push/Pull）中，均需要Consumer端在知道从Broker端的哪一个消息队列—队列中去获取消息。因此，有必要在Consumer端来做负载均衡，即Broker端中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer消费。<br>&emsp;&emsp;Producer向一些队列轮流发送消息，队列集合称为Topic，Consumer如果做广播消费，则一个consumer实例消费这个Topic对应的所有队列；如果做集群消费，则多个Consumer实例平均消费这个Topic对应的队列集合。<br>&emsp;&emsp;如果有3个队列，2个consumer，那么第一个Consumer消费2个队列，第二consumer消费1个队列。这里采用的就是平均分配策略，它类似于我们的分页，TOPIC下面的所有queue就是记录，Consumer的个数就相当于总的页数，那么每页有多少条记录，就类似于某个Consumer会消费哪些队列。<br>&emsp;&emsp;通过这样的策略来达到大体上的平均消费，这样的设计也可以很方面的水平扩展Consumer来提高消费能力。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E6%B6%88%E8%B4%B9%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="消费端负载均衡"></p><h3 id="负载均衡过程"><a href="#负载均衡过程" class="headerlink" title="负载均衡过程"></a>负载均衡过程</h3><p>&emsp;&emsp;客户端负载均衡过程，实际上就是把某个topic下的所有MessageQuene按照一定的算法平均分给各个consunmer的过程。</p><p>//TODO</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">代码还没搞上来<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;https://www.yuque.com/jiufenshiren/mvgau4/cn_design#b59a14cd&quot;&gt;官方的解释&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq消息消费</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/27/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/27/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/</id>
    <published>2021-05-27T07:50:20.000Z</published>
    <updated>2021-05-27T11:32:41.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息获取"><a href="#消息获取" class="headerlink" title="消息获取"></a>消息获取</h1><p>&emsp;&emsp;rocketmq中consumer有两种消息获取模式，分别是pull和push。  </p><span id="more"></span><p>&emsp;&emsp;push模式指MQ主动向消费端推送消息。<br>&emsp;&emsp;pull模式指消费端消费时主动到MQ拉取消息。<br>&emsp;&emsp;本质上，两种模式都是消费端主动到MQ拉取消息，push模式只不过是pull模式的封装。其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。<br>&emsp;&emsp;Consumer端每隔一段时间主动向broker发送拉消息请求，broker在收到Pull请求后，如果有消息就立即返回数据，Consumer端收到返回的消息后，再回调消费者设置的Listener方法。如果broker在收到Pull请求时，消息队列里没有数据，broker端会阻塞请求直到有数据传递或超时才返回。<br>&emsp;&emsp;当然，Consumer端是通过一个线程将阻塞队列LinkedBlockingQueue<PullRequest>中的PullRequest发送到broker拉取消息，以防止Consumer一致被阻塞。而Broker端，在接收到Consumer的PullRequest时，如果发现没有消息，就会把PullRequest扔到ConcurrentHashMap中缓存起来。<br>&emsp;&emsp;broker在启动时，会启动一个线程不停的从ConcurrentHashMap取出PullRequest检查，直到有数据返回。</p><hr><h1 id="消息消费模式"><a href="#消息消费模式" class="headerlink" title="消息消费模式"></a>消息消费模式</h1><p>&emsp;&emsp;Consumer端有两种消息消费模式，集群消费模式和广播消费模式。<br>&emsp;&emsp;集群：消费者集群：使用相同Group ID的订阅者属于同一个集群。同一个集群下的订阅者消费逻辑必须完全一致（包括 Tag 的使用），这些订阅者在逻辑上可以认为是一个消费节点，这些属于一个订阅者组。</p><h2 id="集群消费模式"><a href="#集群消费模式" class="headerlink" title="集群消费模式"></a>集群消费模式</h2><p>&emsp;&emsp;当使用集群消费模式时，MQ认为任意一条消息只需要被集群内的任意一台消费者处理即可。<br>&emsp;&emsp;集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F.png" alt="集群模式消费"></p><h2 id="广播消费模式"><a href="#广播消费模式" class="headerlink" title="广播消费模式"></a>广播消费模式</h2><p>&emsp;&emsp;广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。<br>&emsp;&emsp;当使用广播消费模式时，MQ会每条消息推送给集群内所有注册过的机器消费，保证每台机器至少消费一次。<br>&emsp;&emsp;一条消息被多个Consumer消费，即使这些Consumer属于同一个Consumer Group，消息也会被Consumer Group中的每个Consumer都消费一次。在广播消费中的Consumer Group概念可以认为在消息划分方面无意义。　</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F.png" alt="广播模式消费"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><ol><li>消费端集群化部署，每条消息只消费一次。</li><li>消费进度维护再MQ中，更加可靠。</li><li>每一条消息都只会被分发到一台机器上处理。如果需要被集群下的每一台机器都处理，请使用广播模式。</li><li>不保证每一次失败重试的消息路由到同一台机器上，因此处理消息时不应该做任何确定性假设。</li></ol><h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><ol><li>广播模式下不支持顺序消息。</li><li>广播模式下不支持重置消费位点。</li><li>每条消息都需要被相同逻辑的多台机器处理。</li><li>消费进度在客户端维护，出现重复的概率稍大于集群模式。</li><li>消息队列RocketMQ保证每条消息至少被每台客户端消费一次，但是并不会对消费失败的消息进行失败重投，因此业务方需要关注消费失败的情况。</li><li>客户端每一次重启都会从最新消息消费。客户端在被停止期间发送至服务端的消息将会被自动跳过，请谨慎选择。</li><li>每条消息都会被大量的客户端重复处理，因此推荐尽可能使用集群模式。</li><li>目前仅 Java 客户端支持广播模式。</li><li>广播模式下MQ不维护消费进度，所以消息队列 RocketMQ 控制台不支持消息堆积查询、消息堆积报警和订阅关系查询功能。</li></ol><h3 id="使用集群模式模拟广播模式"><a href="#使用集群模式模拟广播模式" class="headerlink" title="使用集群模式模拟广播模式"></a>使用集群模式模拟广播模式</h3><p>&emsp;&emsp;将原来同一个消费者组的下消费者，拆分成每个消费者一个消费者组，这样就有很多个消费者组。<br>&emsp;&emsp;每个消费者组都订阅需要发送的消息，这样消息会发给每个消费者组，发给了每台机器，都可以消费。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%B9%BF%E6%92%AD.png" alt="集群模式模拟广播模式"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;消息获取&quot;&gt;&lt;a href=&quot;#消息获取&quot; class=&quot;headerlink&quot; title=&quot;消息获取&quot;&gt;&lt;/a&gt;消息获取&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;rocketmq中consumer有两种消息获取模式，分别是pull和push。  &lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq消息分类</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/26/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E5%88%86%E7%B1%BB/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/26/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E5%88%86%E7%B1%BB/</id>
    <published>2021-05-26T11:17:11.000Z</published>
    <updated>2021-05-27T08:32:37.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><p>&emsp;&emsp;message就是要传输的信息，一条消息必须有一个主题（Topic）。</p><span id="more"></span><h2 id="从特点区分"><a href="#从特点区分" class="headerlink" title="从特点区分"></a>从特点区分</h2><p>&emsp;&emsp;mq中的消息从特点区分可以分为三类：同步消息，异步消息，单向消息。</p><h3 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h3><p>&emsp;&emsp;同步发送是指消息发送方发出数据后，会阻塞直到MQ服务方发回响应消息。  </p><h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><p>&emsp;&emsp;异步发送是指发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。<br>&emsp;&emsp;MQ 的异步发送，需要用户实现异步发送回调接口（SendCallback），在执行消息的异步发送时，应用不需要等待服务器响应即可直接返回，通过回调接口接收服务器响应，并对服务器的响应结果进行处理。</p><h3 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h3><p>&emsp;&emsp;单向（Oneway）发送特点为只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别。这种消息常用于日志收集。</p><h2 id="从共功能分"><a href="#从共功能分" class="headerlink" title="从共功能分"></a>从共功能分</h2><p>&emsp;&emsp;从使用功能也可以分为多种消息，最广为人知的就是事务消息。<br>&emsp;&emsp;消息共有以下分类：</p><ol><li>普通消息</li><li>顺序消息</li><li>广播消息</li><li>延时消息</li><li>批量消息</li><li>事务消息</li></ol><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>&emsp;&emsp;消息有序指的是一类消息消费时，能按照发送的顺序来消费。</p><h3 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h3><p>&emsp;&emsp;广播消息与普通消息不同的是，普通消息只会由消费者组中负载均衡到消息所在MessageQuene的消费者消费，而广播消息由消费者组中的所有消费者消费。</p><h3 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h3><p>&emsp;&emsp;<a href="https://www.yuque.com/jiufenshiren/mvgau4/cn_features#19cff416">定时消息</a><br>&emsp;&emsp;定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。<br>&emsp;&emsp;broker有配置项messageDelayLevel，可以配置不同的DelayLevel延迟不同的时间。<br>&emsp;&emsp;定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。<br>&emsp;&emsp;需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p><h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>&emsp;&emsp;<a href="https://www.yuque.com/jiufenshiren/mvgau4/cn_design#dc145683">官方的事务消息解释</a><br>&emsp;&emsp;RocketMQ事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ的事务消息提供类似X/Open XA的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/rocketmq_design_10.png" alt="事务消息大概流程"></p><p>&emsp;&emsp;事务消息的大概流程：</p><ol><li>发送一个事务的半消息。</li><li>服务端将消息持久化成功之后，向发送方ACK确认消息已经发送成功，此时消息为半消息。</li><li>开始执行本地事务，如果发送消息失败，本地事务不执行。</li><li>根据本地事务向mq进行二次提交，Commit或rollback，commit会生成消息索引，mq收到Commit状态则将半消息标记为可投递，订阅方最终将收到该消息；服务端收到Rollback状态则删除半消息，订阅方将不会接受该消息。</li></ol><p>&emsp;&emsp;补偿流程：补偿流程用于mq没有收到发送者二次提交的情况下：</p><ol><li>对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”。（最大回查15次）</li><li>Producer收到回查消息，检查回查消息对应的本地事务的状态。</li><li>根据本地事务状态，重新Commit或者Rollback。</li></ol><p>&emsp;&emsp;注意：</p><ol><li>需要消息回查接口。</li><li>不能保证消息幂等，需要消费方手动控制，在消费者未ack情况下，可能重复消费。</li></ol><hr><h1 id="消息问题"><a href="#消息问题" class="headerlink" title="消息问题"></a>消息问题</h1><p><a href="https://www.cnblogs.com/duanxz/p/6053598.html">RocketMQ之二：分布式开放消息系统RocketMQ的原理与实践（消息的顺序问题、重复问题、可靠消息/事务消息）</a></p><h2 id="消息顺序问题"><a href="#消息顺序问题" class="headerlink" title="消息顺序问题"></a>消息顺序问题</h2><p>&emsp;&emsp;有着一定顺序的消息，一般需要发送到同一个MessageQuene，因为MessageQuene采用先进先出队列，消费方就可以按照发送的顺序进行消费。<br>&emsp;&emsp;可以自定义MessageQueueSelector实现的算法来选择一个队列。<br>&emsp;&emsp;mq顺序消息中，mq需要收到消费方对上一个消息的确认ACK后才能投递下一个消息，这个会带来上一个消息ack收不到的情况下，会造成重复消费。</p><h2 id="消息重复问题"><a href="#消息重复问题" class="headerlink" title="消息重复问题"></a>消息重复问题</h2><p>&emsp;&emsp;mq中并没有处理消息的重复问题，需要消费方自己实现幂等，解决消息重复消费的问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;消息&quot;&gt;&lt;a href=&quot;#消息&quot; class=&quot;headerlink&quot; title=&quot;消息&quot;&gt;&lt;/a&gt;消息&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;message就是要传输的信息，一条消息必须有一个主题（Topic）。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq_NameServer启动流程</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/26/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq-NameServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/26/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq-NameServer%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2021-05-26T08:47:07.000Z</published>
    <updated>2021-06-01T03:22:16.235Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。</p><span id="more"></span><hr><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>&emsp;&emsp;看看项目结构</p><p>&emsp;&emsp;<img src="https://gitee.com/linqiankun/picurl/raw/master/java/nameServer.jpg" alt="项目结构"></p><ul><li>KVConfigManager：nameServer的KV配置管理器，这里加载NameSrv的启动配置。</li><li>KVConfigSerializeWrapper：kv配置的存储位置，每一个kv配置都会被解析存储进入一个该对象中。</li><li>ClusterTestRequestProcessor：暂时忽略。</li><li>DefaultRequestProcessor：默认的请求处理器，里面定义了对broker，topic等的一系列操作等。</li><li>BrokerHousekeepingService：</li><li>RouteInfoManager：路由信息管理类，里面存放了broker的状态信息和broker及topic的关联信息。</li><li>NamesrvController：nameServer的控制类，管理NameServer的启动，初始化，停止等生命周期。</li><li>NamesrvStartup：nameServer的启动入口。</li></ul><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>&emsp;&emsp;启动从NamesrvStartup开始。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 从main方法进入走到了这里</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">NamesrvController</span> <span class="token function">main0</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 闯将启动控制器NameServerController</span>        <span class="token class-name">NamesrvController</span> controller <span class="token operator">=</span> <span class="token function">createNamesrvController</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 启动NameServer</span>        <span class="token function">start</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> tip <span class="token operator">=</span> <span class="token string">"The Name Server boot success. serializeType="</span> <span class="token operator">+</span> <span class="token class-name">RemotingCommand</span><span class="token punctuation">.</span><span class="token function">getSerializeTypeConfigInThisServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span>tip<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s%n"</span><span class="token punctuation">,</span> tip<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> controller<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;createNamesrvController中主要就是构造参数创建控制器。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 这个方法中主要进入NameServerController的构造，会添加很多参数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">NamesrvController</span> <span class="token function">createNamesrvController</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">JoranException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token class-name">RemotingCommand</span><span class="token punctuation">.</span>REMOTING_VERSION_KEY<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token class-name">MQVersion</span><span class="token punctuation">.</span>CURRENT_VERSION<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//PackageConflictDetect.detectFastjson();</span>    <span class="token class-name">Options</span> options <span class="token operator">=</span> <span class="token class-name">ServerUtil</span><span class="token punctuation">.</span><span class="token function">buildCommandlineOptions</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Options</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里解析手动启动时传入的命令行参数</span>    commandLine <span class="token operator">=</span> <span class="token class-name">ServerUtil</span><span class="token punctuation">.</span><span class="token function">parseCmdLine</span><span class="token punctuation">(</span><span class="token string">"mqnamesrv"</span><span class="token punctuation">,</span> args<span class="token punctuation">,</span> <span class="token function">buildCommandlineOptions</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">PosixParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> commandLine<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 定义NameServer和使用到的Netty的配置</span>    <span class="token keyword">final</span> <span class="token class-name">NamesrvConfig</span> namesrvConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NamesrvConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> <span class="token class-name">NettyServerConfig</span> nettyServerConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NettyServerConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 监听端口</span>    nettyServerConfig<span class="token punctuation">.</span><span class="token function">setListenPort</span><span class="token punctuation">(</span><span class="token number">9876</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 处理-c参数后的参数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>commandLine<span class="token punctuation">.</span><span class="token function">hasOption</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        。。。    <span class="token punctuation">&#125;</span>    <span class="token comment">// 处理-p参数后的参数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>commandLine<span class="token punctuation">.</span><span class="token function">hasOption</span><span class="token punctuation">(</span><span class="token string">'p'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        。。。    <span class="token punctuation">&#125;</span>    <span class="token comment">// 将参数转换位NameServConfig对象，这是Common包的定义的类</span>    <span class="token class-name">MixAll</span><span class="token punctuation">.</span><span class="token function">properties2Object</span><span class="token punctuation">(</span><span class="token class-name">ServerUtil</span><span class="token punctuation">.</span><span class="token function">commandLine2Properties</span><span class="token punctuation">(</span>commandLine<span class="token punctuation">)</span><span class="token punctuation">,</span> namesrvConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> namesrvConfig<span class="token punctuation">.</span><span class="token function">getRocketmqHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Please set the %s variable in your environment to match the location of the RocketMQ installation%n"</span><span class="token punctuation">,</span> <span class="token class-name">MixAll</span><span class="token punctuation">.</span>ROCKETMQ_HOME_ENV<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">LoggerContext</span> lc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">LoggerContext</span><span class="token punctuation">)</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getILoggerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">JoranConfigurator</span> configurator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JoranConfigurator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    configurator<span class="token punctuation">.</span><span class="token function">setContext</span><span class="token punctuation">(</span>lc<span class="token punctuation">)</span><span class="token punctuation">;</span>    lc<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    configurator<span class="token punctuation">.</span><span class="token function">doConfigure</span><span class="token punctuation">(</span>namesrvConfig<span class="token punctuation">.</span><span class="token function">getRocketmqHome</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/conf/logback_namesrv.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    log <span class="token operator">=</span> <span class="token class-name">InternalLoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">LoggerName</span><span class="token punctuation">.</span>NAMESRV_LOGGER_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">MixAll</span><span class="token punctuation">.</span><span class="token function">printObjectProperties</span><span class="token punctuation">(</span>log<span class="token punctuation">,</span> namesrvConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">MixAll</span><span class="token punctuation">.</span><span class="token function">printObjectProperties</span><span class="token punctuation">(</span>log<span class="token punctuation">,</span> nettyServerConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 创建控制器，使用上面构造的参数</span>    <span class="token keyword">final</span> <span class="token class-name">NamesrvController</span> controller <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NamesrvController</span><span class="token punctuation">(</span>namesrvConfig<span class="token punctuation">,</span> nettyServerConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// remember all configs to prevent discard</span>    controller<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">registerConfig</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> controller<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;start方法中，会初始化控制器，如果初始化失败，就会关闭，后面在进行启动，最终调用controller中的Start方法。<br>&emsp;&emsp;controller中的Start方法，直接调用了romoting模块中netty的启动方法，打开端口，启动netty服务。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// NamesrvStartup.start</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">NamesrvController</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">NamesrvController</span> controller<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> controller<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"NamesrvController is null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">boolean</span> initResult <span class="token operator">=</span> controller<span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>initResult<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        controller<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addShutdownHook</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ShutdownHookThread</span><span class="token punctuation">(</span>log<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">Void</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>            controller<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    controller<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> controller<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">NamesrvController</span><span class="token punctuation">.</span>start<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>remotingServer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>fileWatchService <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>fileWatchService<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;主要流程看Controller的initialize方法，看看做了什么。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 加载kv配置</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>kvConfigManager<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>remotingServer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NettyRemotingServer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>nettyServerConfig<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>brokerHousekeepingService<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 初始化线程池</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>remotingExecutor <span class="token operator">=</span>        <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>nettyServerConfig<span class="token punctuation">.</span><span class="token function">getServerWorkerThreads</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThreadFactoryImpl</span><span class="token punctuation">(</span><span class="token string">"RemotingExecutorThread_"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 注册请求处理器</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 这里面采用了心跳机制，去检测broker的存活，定时线程池去，扫描所有broker。</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>scheduledExecutorService<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">NamesrvController</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>routeInfoManager<span class="token punctuation">.</span><span class="token function">scanNotActiveBroker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 定时将所有的broker和topic信息打出到日志。</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>scheduledExecutorService<span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">NamesrvController</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>kvConfigManager<span class="token punctuation">.</span><span class="token function">printAllPeriodically</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">TlsSystemConfig</span><span class="token punctuation">.</span>tlsMode <span class="token operator">!=</span> <span class="token class-name">TlsMode</span><span class="token punctuation">.</span>DISABLED<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Register a listener to reload SslContext</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            fileWatchService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileWatchService</span><span class="token punctuation">(</span>                <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">TlsSystemConfig</span><span class="token punctuation">.</span>tlsServerCertPath<span class="token punctuation">,</span>                    <span class="token class-name">TlsSystemConfig</span><span class="token punctuation">.</span>tlsServerKeyPath<span class="token punctuation">,</span>                    <span class="token class-name">TlsSystemConfig</span><span class="token punctuation">.</span>tlsServerTrustCertPath                <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">FileWatchService<span class="token punctuation">.</span>Listener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token keyword">boolean</span> certChanged<span class="token punctuation">,</span> keyChanged <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token annotation punctuation">@Override</span>                    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onChanged</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">TlsSystemConfig</span><span class="token punctuation">.</span>tlsServerTrustCertPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"The trust certificate changed, reload the ssl context"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token function">reloadServerSslContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">TlsSystemConfig</span><span class="token punctuation">.</span>tlsServerCertPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            certChanged <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">TlsSystemConfig</span><span class="token punctuation">.</span>tlsServerKeyPath<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            keyChanged <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>certChanged <span class="token operator">&amp;&amp;</span> keyChanged<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"The certificate and private key changed, reload the ssl context"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            certChanged <span class="token operator">=</span> keyChanged <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                            <span class="token function">reloadServerSslContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reloadServerSslContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">NettyRemotingServer</span><span class="token punctuation">)</span> remotingServer<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">loadSslContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"FileWatchService created error, can't load the certificate dynamically"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;看看注册的请求处理器，在默认的请求处理器中定义了系列的处理方法，会根据不同的请求进行不同的处理。这些方法中大多调用了Controller中的方法，Controller中定义了路由信息管理器，KV配置管理器等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Controller.registerProcessor</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">registerProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>namesrvConfig<span class="token punctuation">.</span><span class="token function">isClusterTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>remotingServer<span class="token punctuation">.</span><span class="token function">registerDefaultProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClusterTestRequestProcessor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> namesrvConfig<span class="token punctuation">.</span><span class="token function">getProductEnvName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>remotingExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 默认注册default的请求处理器</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>remotingServer<span class="token punctuation">.</span><span class="token function">registerDefaultProcessor</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DefaultRequestProcessor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>remotingExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// DefaultRequestProcessor.processRequest</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">RemotingCommand</span> <span class="token function">processRequest</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span>    <span class="token class-name">RemotingCommand</span> request<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">RemotingCommandException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"receive request, &#123;&#125; &#123;&#125; &#123;&#125;"</span><span class="token punctuation">,</span>            request<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span><span class="token function">parseChannelRemoteAddr</span><span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 根据不同请求进行不同的处理</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>PUT_KV_CONFIG<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">putKVConfig</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_KV_CONFIG<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getKVConfig</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>DELETE_KV_CONFIG<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteKVConfig</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>QUERY_DATA_VERSION<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token function">queryBrokerTopicConfig</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>REGISTER_BROKER<span class="token operator">:</span>            <span class="token class-name">Version</span> brokerVersion <span class="token operator">=</span> <span class="token class-name">MQVersion</span><span class="token punctuation">.</span><span class="token function">value2Version</span><span class="token punctuation">(</span>request<span class="token punctuation">.</span><span class="token function">getVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>brokerVersion<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token class-name">MQVersion<span class="token punctuation">.</span>Version</span><span class="token punctuation">.</span>V3_0_11<span class="token punctuation">.</span><span class="token function">ordinal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerBrokerWithFilterServer</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerBroker</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>UNREGISTER_BROKER<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unregisterBroker</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_ROUTEINFO_BY_TOPIC<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getRouteInfoByTopic</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_BROKER_CLUSTER_INFO<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBrokerClusterInfo</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>WIPE_WRITE_PERM_OF_BROKER<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wipeWritePermOfBroker</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_ALL_TOPIC_LIST_FROM_NAMESERVER<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token function">getAllTopicListFromNameserver</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>DELETE_TOPIC_IN_NAMESRV<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token function">deleteTopicInNamesrv</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_KVLIST_BY_NAMESPACE<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getKVListByNamespace</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_TOPICS_BY_CLUSTER<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTopicsByCluster</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_SYSTEM_TOPIC_LIST_FROM_NS<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSystemTopicListFromNs</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_UNIT_TOPIC_LIST<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getUnitTopicList</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_HAS_UNIT_SUB_TOPIC_LIST<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getHasUnitSubTopicList</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_HAS_UNIT_SUB_UNUNIT_TOPIC_LIST<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getHasUnitSubUnUnitTopicList</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>UPDATE_NAMESRV_CONFIG<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateConfig</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token class-name">RequestCode</span><span class="token punctuation">.</span>GET_NAMESRV_CONFIG<span class="token operator">:</span>            <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getConfig</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> &emsp;&emsp;Controller的initialize方法中，处理上面注册的处理器外，还有进行心跳检测的周期性定时线程池。从scanNotActiveBroker方法进入。<br> &emsp;&emsp;调度线程定时的扫描brokerLiveTable里面broker的状态信息，发现最近的更新时间与当前时间相差大于BROKER_CHANNEL_EXPIRED_TIME =1000 *60 *2，即两分钟的话，就删除当前broker。</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">scanNotActiveBroker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 遍历brokerLiveTable</span>    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">BrokerLiveInfo</span><span class="token punctuation">></span><span class="token punctuation">></span></span> it <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>brokerLiveTable<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">BrokerLiveInfo</span><span class="token punctuation">></span></span> next <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> last <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getLastUpdateTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 判断更新时间和当前时间的差值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>last <span class="token operator">+</span> BROKER_CHANNEL_EXPIRED_TIME<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">RemotingUtil</span><span class="token punctuation">.</span><span class="token function">closeChannel</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 移除</span>            it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">"The broker channel expired, &#123;&#125; &#123;&#125;ms"</span><span class="token punctuation">,</span> next<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> BROKER_CHANNEL_EXPIRED_TIME<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 删除broker</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">onChannelDestroy</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> next<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> &emsp;&emsp;删除broker就是删除RouteInfoManager中维护的几个hashmap中关于broker的信息。onChannelDestroy方法中删除了broker。</p> <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onChannelDestroy</span><span class="token punctuation">(</span><span class="token class-name">String</span> remoteAddr<span class="token punctuation">,</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> brokerAddrFound <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>channel <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">BrokerLiveInfo</span><span class="token punctuation">></span><span class="token punctuation">></span></span> itBrokerLiveTable <span class="token operator">=</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>brokerLiveTable<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>itBrokerLiveTable<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">BrokerLiveInfo</span><span class="token punctuation">></span></span> entry <span class="token operator">=</span> itBrokerLiveTable<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> channel<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        brokerAddrFound <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"onChannelDestroy Exception"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> brokerAddrFound<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        brokerAddrFound <span class="token operator">=</span> remoteAddr<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"the broker's channel destroyed, &#123;&#125;, clean it's data structure at once"</span><span class="token punctuation">,</span> brokerAddrFound<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>brokerAddrFound <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> brokerAddrFound<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lockInterruptibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>brokerLiveTable<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>brokerAddrFound<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>filterServerTable<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>brokerAddrFound<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> brokerNameFound <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                <span class="token keyword">boolean</span> removeBrokerName <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">BrokerData</span><span class="token punctuation">></span><span class="token punctuation">></span></span> itBrokerAddrTable <span class="token operator">=</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span>brokerAddrTable<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>itBrokerAddrTable<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> brokerNameFound<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">BrokerData</span> brokerData <span class="token operator">=</span> itBrokerAddrTable<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> it <span class="token operator">=</span> brokerData<span class="token punctuation">.</span><span class="token function">getBrokerAddrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">></span></span> entry <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">Long</span> brokerId <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">String</span> brokerAddr <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>brokerAddr<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>brokerAddrFound<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            brokerNameFound <span class="token operator">=</span> brokerData<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"remove brokerAddr[&#123;&#125;, &#123;&#125;] from brokerAddrTable, because channel destroyed"</span><span class="token punctuation">,</span>                                brokerId<span class="token punctuation">,</span> brokerAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>brokerData<span class="token punctuation">.</span><span class="token function">getBrokerAddrs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        removeBrokerName <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                        itBrokerAddrTable<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"remove brokerName[&#123;&#125;] from brokerAddrTable, because channel destroyed"</span><span class="token punctuation">,</span>                            brokerData<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>brokerNameFound <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> removeBrokerName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span><span class="token punctuation">></span></span> it <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clusterAddrTable<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entry <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">String</span> clusterName <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> brokerNames <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">boolean</span> removed <span class="token operator">=</span> brokerNames<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>brokerNameFound<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>removed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"remove brokerName[&#123;&#125;], clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed"</span><span class="token punctuation">,</span>                                brokerNameFound<span class="token punctuation">,</span> clusterName<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>brokerNames<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"remove the clusterName[&#123;&#125;] from clusterAddrTable, because channel destroyed and no broker in this cluster"</span><span class="token punctuation">,</span>                                    clusterName<span class="token punctuation">)</span><span class="token punctuation">;</span>                                it<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>removeBrokerName<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">QueueData</span><span class="token punctuation">></span><span class="token punctuation">></span><span class="token punctuation">></span></span> itTopicQueueTable <span class="token operator">=</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>topicQueueTable<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">while</span> <span class="token punctuation">(</span>itTopicQueueTable<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                        <span class="token class-name">Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">QueueData</span><span class="token punctuation">></span><span class="token punctuation">></span></span> entry <span class="token operator">=</span> itTopicQueueTable<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">String</span> topic <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QueueData</span><span class="token punctuation">></span></span> queueDataList <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">QueueData</span><span class="token punctuation">></span></span> itQueueData <span class="token operator">=</span> queueDataList<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">while</span> <span class="token punctuation">(</span>itQueueData<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            <span class="token class-name">QueueData</span> queueData <span class="token operator">=</span> itQueueData<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>queueData<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>brokerNameFound<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                                itQueueData<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"remove topic[&#123;&#125; &#123;&#125;], from topicQueueTable, because channel destroyed"</span><span class="token punctuation">,</span>                                    topic<span class="token punctuation">,</span> queueData<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">&#125;</span>                        <span class="token punctuation">&#125;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>queueDataList<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                            itTopicQueueTable<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"remove topic[&#123;&#125;] all queue, from topicQueueTable, because channel destroyed"</span><span class="token punctuation">,</span>                                topic<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">&#125;</span>                    <span class="token punctuation">&#125;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"onChannelDestroy Exception"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq生产消费流程</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/26/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/26/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B/</id>
    <published>2021-05-26T06:07:32.000Z</published>
    <updated>2021-05-31T06:32:09.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rocketmq工作流程"><a href="#Rocketmq工作流程" class="headerlink" title="Rocketmq工作流程"></a>Rocketmq工作流程</h1><p>&emsp;&emsp;rocketmq中几乎每个节点都可以集群部署，namesrv，broker，producer，consumer。</p><span id="more"></span><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/rocketmq_architecture_3.png" alt="部署结构"></p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/mq%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%BF%A1%E6%81%AF.png" alt="部署后节点保存的信息"></p><h2 id="网络部署特点"><a href="#网络部署特点" class="headerlink" title="网络部署特点"></a>网络部署特点</h2><ol><li>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</li><li>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。</li><li>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li><li>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。</li></ol><h2 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h2><ol><li>启动NameServer，NameServer启动后会监听端口，等待Broker，Producer，Consumer连上来，相当于一个路由控制中心，类似于dubbo中zk发挥的作用。</li><li>Broker启动，跟所有NameServer保持长连接，定时发送心跳包。心跳包包含当前Broker信息，以及存储所有Topic的信息。注册成功后，NameServer集群中就有Topic和Broker的映射关系。</li><li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li><li>Producer发送消息，启动时先跟NameServer中的一台建立长连接，并从其中获取当前发送的Topic存在那些Broker上，从Topic中的MessageQuene中选取一个（采用轮询），然后与队列所在Broker建立长连接从而向Broker发送消息。</li><li>Consumer跟Producer一样，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。只由BrokerId=1的Slave Broker才会提供读服务。<blockquote><p>一个Topic下的所有MessageQuene会负载均衡到消费者组中的每一台机器，每一台机器负责几个队列，保证均衡，这里要求，消费者组中的机器数少于队列数。</p></blockquote></li></ol><h2 id="Recketmq完整通信流程"><a href="#Recketmq完整通信流程" class="headerlink" title="Recketmq完整通信流程"></a>Recketmq完整通信流程</h2><p>&emsp;&emsp;Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master建立长连接，且定时向Broker发送心跳。<br>&emsp;&emsp;Producer只能将消息发送到Broker master，但是Consumer则不一样，它同时和提供Topic服务的Master和Slave建立长连接，既可以从Broker Master订阅消息，也可以从Broker Slave订阅消息。</p><p><a href="https://juejin.cn/post/6844904008629354504#heading-25">《浅入浅出》-RocketMQ</a></p><ol><li>Broker启动后需要完成一次将自己注册至NameServer的操作；随后每隔30s时间定时向NameServer上报Topic路由信息。</li><li>消息生产者Producer作为客户端发送消息时候，需要根据消息的Topic从本地缓存的TopicPublishInfoTable获取路由信息。如果没有则更新路由信息会从NameServer上重新拉取，同时Producer会默认每隔30s向NameServer拉取一次路由信息。</li><li>消息生产者Producer根据2）中获取的路由信息选择一个队列（MessageQueue）进行消息发送；Broker作为消息的接收者接收消息并落盘存储。</li><li>消息消费者Consumer根据2）中获取的路由信息，并再完成客户端的负载均衡后，选择其中的某一个或者某几个消息队列来拉取消息并进行消费。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rocketmq工作流程&quot;&gt;&lt;a href=&quot;#Rocketmq工作流程&quot; class=&quot;headerlink&quot; title=&quot;Rocketmq工作流程&quot;&gt;&lt;/a&gt;Rocketmq工作流程&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;rocketmq中几乎每个节点都可以集群部署，namesrv，broker，producer，consumer。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
    <category term="分布式" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq概念总结</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/25/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/25/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-25T11:20:54.000Z</published>
    <updated>2021-05-26T11:50:32.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h1><p><a href="https://github.com/apache/rocketmq/tree/master/docs/cn">官方文档看看挺好的</a><br>&emsp;&emsp;rocketmq主要有四大核心组成部分：NameServer，Broker，Producer，Consumer四部分。  </p><span id="more"></span><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/rocketmq_architecture_1.jpg" alt="架构设计"></p><h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><p>&emsp;&emsp;主要负责对源数据的管理，包括了对于Topic和路由信息的管理。  </p><blockquote><p>&emsp;&emsp;NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。<br>&emsp;&emsp;NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer，Consumer仍然可以动态感知Broker的路由的信息。 </p></blockquote><p>&emsp;&emsp;NameServer是一个功能齐全的服务器，其角色类似Dubbo中的Zookeeper，但NameServer与Zookeeper相比更轻量。主要是因为每个NameServer节点互相之间是独立的，没有任何信息交互。<br>&emsp;&emsp;NameServer压力不会太大，平时主要开销是在维持心跳和提供Topic-Broker的关系数据。<br>&emsp;&emsp;Broker向NameServer发心跳时，会带上当前自己所负责的所有Topic信息，如果Topic个数太多（万级别），会导致一次心跳中，就Topic的数据就几十M，网络情况差的话， 网络传输失败，心跳失败，导致NameServer误认为Broker心跳失败。<br>&emsp;&emsp;NameServer被设计成几乎无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是一个伪集群。<br>&emsp;&emsp;每个 Broker 在启动的时候会到 NameServer 注册，Producer 在发送消息前会根据 Topic 到 NameServer 获取到 Broker 的路由信息，Consumer 也会定时获取 Topic 的路由信息。</p><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>&emsp;&emsp;消息中转角色，负责存储消息，转发消息。  </p><blockquote><p>Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker包含了以下几个重要子模块。</p><ol><li>Remoting Module：整个Broker的实体，负责处理clients端的请求。</li><li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息。</li><li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</li><li>HA service：高可用服务，提供Master Broker和Slave Broker之间的数据同步功能。</li><li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li></ol></blockquote><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/broker.png" alt="Broker结构"></p><p>&emsp;&emsp;Broker是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接和心跳，并会定时将topic的信息注册到NameServer，底层的通信和连接都是通过Netty实现的。<br>&emsp;&emsp;Broker负责消息存储，以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。<br>&emsp;&emsp;支持上亿的消息堆积能力，同时可以严格保证消息的有序性。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/topic%E4%B8%8Ebroker.png" alt="Topic与Broker关系"></p><h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><p>&emsp;&emsp;消息生产者，负责产生消息。</p><blockquote><p>消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p></blockquote><p>&emsp;&emsp;Producer由用户进行分布式部署，消息由Producer通过多种负载均衡模式发送到Broker集群，发送低延时，支持快速失败。  </p><p>&emsp;&emsp;rocketmq提供了三种消息发送方式：<strong>同步，异步，单向</strong>。</p><ol><li>同步发送：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</li><li>异步发送：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</li><li>单向发送：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</li></ol><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>&emsp;消息消费者，负责消费消息，一般时下游业务系统。  </p><blockquote><p>消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</p></blockquote><p>&emsp;&emsp;Consumer也由用户部署，支持PUSH和PULL两种消费模式，支持集群消费和广播消息，提供实时的消息订阅机制。</p><ol><li>PUSH：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push 称为被动消费类型，但从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push 首先要注册消费监听器，当监听器处触发后才开始消费消息。</li><li>PULL：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。</li></ol><hr><h1 id="消息相关概念"><a href="#消息相关概念" class="headerlink" title="消息相关概念"></a>消息相关概念</h1><h2 id="Message（消息）"><a href="#Message（消息）" class="headerlink" title="Message（消息）"></a>Message（消息）</h2><p>&emsp;&emsp;message就是要传输的信息，一条消息必须有一个主题（Topic）。<br>&emsp;&emsp;一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务Key并在Broker上查找此消息以便在开发期间查找问题。<br>&emsp;&emsp;一个Topic可以分散在多个Broker上，也可以在一个Broker上。<br>&emsp;&emsp;消息分为三种：同步消息，异步消息，单向消息。</p><h2 id="Topic（主题）"><a href="#Topic（主题）" class="headerlink" title="Topic（主题）"></a>Topic（主题）</h2><p>&emsp;&emsp;可以看做消息的分类，它是消息的第一级类型。<br>&emsp;&emsp;Topic与生产者和消费者的关系非常松散，一个Topic可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的Topic发送消息。一个Topic也可以被多个或者1个消费者订阅。</p><h2 id="Tag（标签）"><a href="#Tag（标签）" class="headerlink" title="Tag（标签）"></a>Tag（标签）</h2><p>&emsp;&emsp;以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。<br>&emsp;&emsp;使用标签，同一业务模块不同目的的消息就可以用相同Topic而不同的Tag来标识，一条消息可以没有Tag。</p><h2 id="Group（分组）"><a href="#Group（分组）" class="headerlink" title="Group（分组）"></a>Group（分组）</h2><p>&emsp;&emsp;一个分组可以订阅多个Topic。<br>&emsp;&emsp;分组分为生产者分组和消费者分组，一般同一个服务作为一个组，一个组生产或消费的消息都是一致的。</p><h2 id="Quene（队列）"><a href="#Quene（队列）" class="headerlink" title="Quene（队列）"></a>Quene（队列）</h2><p>&emsp;&emsp;每个Queue内部是有序的，在RocketMQ中分为读和写两种队列，一般来说读写队列数量一致，如果不一致就会出现很多问题。</p><h2 id="MessageQuene（消息队列）"><a href="#MessageQuene（消息队列）" class="headerlink" title="MessageQuene（消息队列）"></a>MessageQuene（消息队列）</h2><p>&emsp;&emsp;一个主题被划分为多个子主题，就是消息队列。<br>&emsp;&emsp;一个Topic下可以设置多个消息队列，发送消息时执行该消息的Topic，RocketMQ会轮询该Topic下的所有队列将消息发出去，只会发送到一个MessageQuene中。<br>&emsp;&emsp;消息的物理管理单位。一个Topic下可以有多个Queue，Queue的引入使得消息的存储可以分布式集群化，具有了水平扩展能力。</p><h2 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h2><p>&emsp;&emsp;在RocketMQ中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用Offset来访问，Offset为long类型，64位，理论上在100年内不会溢出，所以认为是长度无限。<br>&emsp;&emsp;也可以认为Message Queue是一个长度无限的数组，Offset就是下标。</p><h2 id="消息消费模式"><a href="#消息消费模式" class="headerlink" title="消息消费模式"></a>消息消费模式</h2><p>&emsp;&emsp;分为两种，集群消费模式，广播消费模式。  </p><h3 id="集群消费模式"><a href="#集群消费模式" class="headerlink" title="集群消费模式"></a>集群消费模式</h3><p>&emsp;&emsp;默认情况下就是集群消费，该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p><h3 id="广播消费模式"><a href="#广播消费模式" class="headerlink" title="广播消费模式"></a>广播消费模式</h3><p>&emsp;&emsp;而广播消费消息会发给消费者组中的每一个消费者进行消费，一个消息会被多次消费。</p><h2 id="Message-Order"><a href="#Message-Order" class="headerlink" title="Message Order"></a>Message Order</h2><p>&emsp;&emsp;消息消费顺序，也有两种：顺序消费，并行消费。</p><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><p>&emsp;&emsp;顺序消费表示消息消费的顺序同生产者为每个消息队列发送的顺序一致，所以如果正在处理全局顺序是强制性的场景，需要确保使用的主题只有一个消息队列。</p><h3 id="并行消费"><a href="#并行消费" class="headerlink" title="并行消费"></a>并行消费</h3><p>&emsp;&emsp;并行消费不再保证消息顺序，消费的最大并行数量受每个消费者客户端指定的线程池限制。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;核心组成&quot;&gt;&lt;a href=&quot;#核心组成&quot; class=&quot;headerlink&quot; title=&quot;核心组成&quot;&gt;&lt;/a&gt;核心组成&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/apache/rocketmq/tree/master/docs/cn&quot;&gt;官方文档看看挺好的&lt;/a&gt;&lt;br&gt;&amp;emsp;&amp;emsp;rocketmq主要有四大核心组成部分：NameServer，Broker，Producer，Consumer四部分。  &lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>异常的三次握手四次挥手</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/21/md/internet/%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/21/md/internet/%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2021-05-21T10:43:17.000Z</published>
    <updated>2021-05-24T08:09:40.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;TCP作为一个靠谱的协议，在传输数据的前后，需要在双端之间建立连接，并在双端各自维护连接的状态。<br>&emsp;&emsp;建立连接前，TCP会通过三次握手来保证双端状态正确，然后就可以正常传输数据了。当数据传输完成，需要断开连接的时候，TCP会通过四次握手来完成双端的断连，并回收各自的资源。<br>&emsp;&emsp;这个过程中也会产生各种问题，有因网络原因造成的也有其他原因造成的。一般来说主要就是丢包的问题，基本就是超时重传等来保证TCP的可靠性。</p><span id="more"></span><p><a href="https://network.51cto.com/art/202002/610542.htm">TCP异常</a></p><hr><h1 id="三次握手中的问题"><a href="#三次握手中的问题" class="headerlink" title="三次握手中的问题"></a>三次握手中的问题</h1><h2 id="客户端第一个SYN包丢失"><a href="#客户端第一个SYN包丢失" class="headerlink" title="客户端第一个SYN包丢失"></a>客户端第一个SYN包丢失</h2><p>&emsp;&emsp;如果客户端的第一个ACK包丢失，服务器无法收到这个包，不会做任何事情。<br>&emsp;&emsp;而在TCP协议中，某端的一组「请求-应答」中，在一定时间范围内，只要没有收到应答的「ACK」包，无论是请求包对方没有收到，还是对方的应答包自己没有收到，均认为是丢包了，都会触发超时重传机制。<br>&emsp;&emsp;此时客户端会重传丢失的SYN包。</p><h2 id="服务端收到SYNd返回的SYN-ACK包丢失"><a href="#服务端收到SYNd返回的SYN-ACK包丢失" class="headerlink" title="服务端收到SYNd返回的SYN+ACK包丢失"></a>服务端收到SYNd返回的SYN+ACK包丢失</h2><p>&emsp;&emsp;此时服务端已经收到客户端的数据，并且发出了对于改信息的回复。<br>&emsp;&emsp;这个问题站在客户端而言，无法区分是服务端没有收到第一次的SYN包，还是自己没有收到回复信息，只能等待一段时间后重新发送SYN包，这和上面的情况就一样了。<br>&emsp;&emsp;对于服务端，发送了SYN+ACK包后，无法等到对方的确认ACK信息，也只能对这个SYN+ACK包进行重传。<br>&emsp;&emsp;由于客户端的重传，服务端会收到这个重传的SYN包，此时会针对这个新的SYN包立即发送SYN+ACK信息。</p><h2 id="客户端收到SYN-ACK返回的ACK包丢失"><a href="#客户端收到SYN-ACK返回的ACK包丢失" class="headerlink" title="客户端收到SYN+ACK返回的ACK包丢失"></a>客户端收到SYN+ACK返回的ACK包丢失</h2><p>&emsp;&emsp;如果最后一个ACK包丢了，服务端因为收不到ACK会走重传机制，而客户端此时进入ESTABLISHED状态。<br>&emsp;&emsp;多数情况下，客户端进入ESTABLISHED状态后，则认为连接已建立，会立即发送数据。但是服务端因为没有收到最后一个ACK包，依然处于SYN-RCVD状态。<br>&emsp;&emsp;所以当服务端处于SYN-RCVD状态下时，接收到客户端真实发送来的数据包时，会认为连接已建立，并进入ESTABLISHED状态。<br>&emsp;&emsp;也有地方认为当服务端处于SYN-RCVD状态下，收到客户端的数据包后，会直接回复RST包响应，表示服务端错误，并进入CLOSE状态。<br>&emsp;&emsp;实际情况下，当客户端在ESTABLISHED状态下，开始发送数据包时，会携带上一个ACK的确认序号，所以哪怕客户端响应的ACK包丢了，服务端在收到这个数据包时，能够通过包内ACK的确认序号，正常进入ESTABLISHED状态。</p><h2 id="客户端故意不发最后一次ACK包"><a href="#客户端故意不发最后一次ACK包" class="headerlink" title="客户端故意不发最后一次ACK包"></a>客户端故意不发最后一次ACK包</h2><p>-0<br>&emsp;&emsp;如果客户端是恶意的，在发送SYN包后，并收到SYN+ACK后就不回复了，那么服务端此时处于一种半连接的状态，虽然服务端会通过tcp_synack_retries配置重试的次数，不会无限等待下去，但是这也是有一个时间周期的。<br>&emsp;&emsp;如果短时间内存在大量的这种恶意连接，对服务端来说压力就会很大，这就是所谓的SYN FLOOD攻击。</p><hr><h1 id="四次挥手中的问题"><a href="#四次挥手中的问题" class="headerlink" title="四次挥手中的问题"></a>四次挥手中的问题</h1><h2 id="客户端断开连接的FIN包丢失"><a href="#客户端断开连接的FIN包丢失" class="headerlink" title="客户端断开连接的FIN包丢失"></a>客户端断开连接的FIN包丢失</h2><p>&emsp;&emsp;这种情况下，会触发超时重传机制，不会去考虑是自己发出的包丢失，还是无法收到对方发来的恢复，直到关闭连接。</p><h2 id="服务端第一次返回的ACK包丢失"><a href="#服务端第一次返回的ACK包丢失" class="headerlink" title="服务端第一次返回的ACK包丢失"></a>服务端第一次返回的ACK包丢失</h2><p>&emsp;&emsp;这种情况下，客户端无法收到服务端返回的ACK包，会触发重传机制，重传FIN包。<br>&emsp;&emsp;而服务器收到重传的FIN包后，会立即在重传对FIN包的ACK包。<br>&emsp;&emsp;而此时服务器已经进入CLOSED-WAIT状态，开始做断开连接前的准备工作。当准备好之后，会回复FIN+ACK，这个消息是携带了之前ACK的响应序号的，这就是第三次挥手的包。</p><h2 id="服务器发送的FIN-ACK包丢失"><a href="#服务器发送的FIN-ACK包丢失" class="headerlink" title="服务器发送的FIN+ACK包丢失"></a>服务器发送的FIN+ACK包丢失</h2><p>&emsp;&emsp;这是第三次挥手的包丢失了，此时客户端有两种情况，要么处于FIN-WAIT-2状态(之前的 ACK 也丢了)，会一直等待；要么处于TIME-WAIT状态，会等待 2MSL 时间。<br>&emsp;&emsp;而服务端则收不到对应的ACK确认包，则会进行超时重传。</p><h2 id="客户端最后返回的ACK包丢失"><a href="#客户端最后返回的ACK包丢失" class="headerlink" title="客户端最后返回的ACK包丢失"></a>客户端最后返回的ACK包丢失</h2><p>&emsp;&emsp;客户端在回复ACK后，会进入TIME-WAIT状态，开始长达2MSL的等待，服务端因为没有收到ACK的回复，会重试一段时间，直到服务端重试超时后主动断开。<br>&emsp;&emsp;或者等待新的客户端接入后，收到服务端重试的FIN消息后，回复RST消息，在收到RST消息后，复位服务端的状态。</p><h2 id="客户端收到ACK后服务端跑路"><a href="#客户端收到ACK后服务端跑路" class="headerlink" title="客户端收到ACK后服务端跑路"></a>客户端收到ACK后服务端跑路</h2><p>&emsp;&emsp;客户端在收到ACK后，进入了FIN-WAIT-2状态，等待服务端发来的FIN包，而如果服务端跑路了，这个包永远都等不到。<br>&emsp;&emsp;在TCP协议中，是没有对这个状态的处理机制的。但是协议不管，系统来凑，操作系统会接管这个状态，在一段时间后，直接进行客户端关闭，这中间会用心跳等进行检测。</p><h2 id="客户端收到ACK后客户端跑路"><a href="#客户端收到ACK后客户端跑路" class="headerlink" title="客户端收到ACK后客户端跑路"></a>客户端收到ACK后客户端跑路</h2><p>&emsp;&emsp;客户端收到ACK后直接跑路，服务端后续在发送的FIN+ACK就没有接收端，也就不会得到回复，会不断的走TCP的超时重试的机制，此时服务端处于LAST-ACK状态。<br>&emsp;&emsp;这种情况下，有两种情况：在超过一定时间后，服务器直接进行关闭，这种类似于客户端的关闭；另一种情况则是收到客户端的RST消息，关闭连接。<br>&emsp;&emsp;RST消息是一种重置消息，表示当前错误了，应该回到初始的状态。如果客户端跑路后有新的客户端接入，会在此发送SYN以期望建立连接，此时这个SYN将被忽略，并直接回复FIN+ACK消息，新客户端在收到FIN消息后是不会认的，并且会回复一个RST消息。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;TCP作为一个靠谱的协议，在传输数据的前后，需要在双端之间建立连接，并在双端各自维护连接的状态。&lt;br&gt;&amp;emsp;&amp;emsp;建立连接前，TCP会通过三次握手来保证双端状态正确，然后就可以正常传输数据了。当数据传输完成，需要断开连接的时候，TCP会通过四次握手来完成双端的断连，并回收各自的资源。&lt;br&gt;&amp;emsp;&amp;emsp;这个过程中也会产生各种问题，有因网络原因造成的也有其他原因造成的。一般来说主要就是丢包的问题，基本就是超时重传等来保证TCP的可靠性。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="TCP" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E7%BD%91%E7%BB%9C/TCP/"/>
    
    
    <category term="TCP" scheme="http://linqiankun.gitee.io/hexoblog/tags/TCP/"/>
    
    <category term="网络" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>nginx基础安装及使用</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/20/md/DEVOPS/nginx/nginx%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/20/md/DEVOPS/nginx/nginx%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-20T07:11:44.000Z</published>
    <updated>2021-05-20T08:31:21.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><span id="more"></span><p>&emsp;&emsp;nginx可以用来做：反向代理服务器，静态Http服务器，负载均衡，虚拟主机。</p><hr><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>&emsp;&emsp;这里的安装目前是在windows环境下，傻瓜式安装即可。  </p><h2 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h2><p>&emsp;&emsp;nginx在windows安装很简单，下载后解压就好，纯绿色安装。<br>&emsp;&emsp;在官方地址下载nginx，解压后放在想要放的文件夹。<br>&emsp;&emsp;下载地址：<a href="http://nginx.org/en/download.html">下载地址</a>。</p><hr><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><p>&emsp;&emsp;启动，关机，重新加载等基础操作。<br>&emsp;&emsp;如果没有配置环境变量，启动前请进入nginx安装目录，如果有配置可以不进入。  </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入解压后的nginx</span><span class="token builtin class-name">cd</span> nginx-1.18.0<span class="token comment"># 启动nginx（windows下）</span>start nginx./nginx<span class="token comment"># 停止nginx</span><span class="token comment"># stop是快速停止nginx，quit是有序停止nginx。</span>./nginx -s stop./nginx -s quit<span class="token comment"># 重新加载配置</span>./nginx -s reload<span class="token comment"># 校验配置</span>./nginx -t<span class="token comment"># 查看版本</span>./nginx -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。&lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://linqiankun.gitee.io/hexoblog/categories/nginx/"/>
    
    
    <category term="linux" scheme="http://linqiankun.gitee.io/hexoblog/tags/linux/"/>
    
    <category term="nginx" scheme="http://linqiankun.gitee.io/hexoblog/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件简介</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/19/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/19/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E4%BB%8B/</id>
    <published>2021-05-19T11:28:22.000Z</published>
    <updated>2021-05-26T08:45:33.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>&emsp;&emsp;消息中间件主要用于异步，削峰，解耦这几大典型场景。</p><span id="more"></span><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>&emsp;&emsp;对于没有强制顺序的任务，可以并行接受消息队列，并行对不同的业务逻辑进行异步处理，比如优惠卷，积分业务。</p><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>&emsp;&emsp;对于高并发业务，可以将请求放入消息队列中，消费方按照比较稳定的消费速度，对请求进行处理，从而起到削峰作用。</p><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>&emsp;&emsp;将不同的业务模块，分离出来，每个单独部署，单独维护，互相之间采用消息队列进行通信，从而起到解耦作用。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="系统复杂性"><a href="#系统复杂性" class="headerlink" title="系统复杂性"></a>系统复杂性</h3><p>&emsp;&emsp;使用消息队列，会增加系统维护成本，不仅要维护原来的系统，还要对消息队列进行维护。<br>&emsp;&emsp;与此同时，还需要考虑对消息的正常处理，异常处理（重复消费，消息丢失，消息的顺序消费）。</p><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>&emsp;&emsp;这是分布式系统中的一个问题，在使用了消息中间件的系统中，消息发送方无法保证消费方是否正确的消费了消息，如果是异常的消费消息，就有可能造成，发送方与接收方的数据不一致。<br>&emsp;&emsp;这里就需要分布式事务来保证数据的一致性，将消费方，发送方的业务逻辑放在一个事务里面提交，一起成功，一起失败，保证数据的一致性。</p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>&emsp;&emsp;MQ自己的可靠性，同样需要开发者进行维护。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;h2 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;消息中间件主要用于异步，削峰，解耦这几大典型场景。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
</feed>
