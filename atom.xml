<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Study</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="https://linqiankun.github.io/hexoblog/atom.xml" rel="self"/>
  
  <link href="https://linqiankun.github.io/hexoblog/"/>
  <updated>2021-09-18T07:38:37.981Z</updated>
  <id>https://linqiankun.github.io/hexoblog/</id>
  
  <author>
    <name>linqiankun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TODO</title>
    <link href="https://linqiankun.github.io/hexoblog/TODO/"/>
    <id>https://linqiankun.github.io/hexoblog/TODO/</id>
    <published>2022-12-31T15:59:59.000Z</published>
    <updated>2021-09-18T07:38:37.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><span id="more"></span><h2 id="QUEST-TODO"><a href="#QUEST-TODO" class="headerlink" title="QUEST_TODO"></a>QUEST_TODO</h2><ul><li><input disabled="" type="checkbox"> zk同时接收到创建节点请求</li><li><input disabled="" type="checkbox"> mysql分库分表</li></ul><h2 id="POSTS-TODO"><a href="#POSTS-TODO" class="headerlink" title="POSTS_TODO"></a>POSTS_TODO</h2><ul><li><input disabled="" type="checkbox"> rocketmq负载均衡代码</li><li><input disabled="" type="checkbox"> rocketmq消息可靠性消费重试代码</li><li><input disabled="" type="checkbox"> jekins安装和使用<ul><li><input disabled="" type="checkbox"> jekins安装过程</li><li><input disabled="" type="checkbox"> jekins基本使用</li></ul></li><li><input disabled="" type="checkbox"> B+树</li><li><input disabled="" type="checkbox"> deepin安装docker</li><li><input disabled="" type="checkbox"> jvm命令</li><li><input disabled="" type="checkbox"> jvm调优</li><li><input disabled="" type="checkbox"> SpringBean的初始化过程</li><li><input disabled="" type="checkbox"> SpringBean的生命周期</li><li><input disabled="" type="checkbox"> redis底层的8种数据结构</li></ul><h2 id="面经-TODO"><a href="#面经-TODO" class="headerlink" title="面经_TODO"></a>面经_TODO</h2><ul><li><input disabled="" type="checkbox"> 雪球科技一面面经</li><li><input disabled="" type="checkbox"> 雪球科技二面面经</li><li><input disabled="" type="checkbox"> 网易一面面经</li><li><input disabled="" type="checkbox"> 信也科技一面面经</li><li><input disabled="" type="checkbox"> 禾连科技一面面经</li><li><input disabled="" type="checkbox"> 海康威视一面面经</li><li><input disabled="" type="checkbox"> 同花顺一面面经</li></ul><h2 id="DRAFTS-TODO"><a href="#DRAFTS-TODO" class="headerlink" title="DRAFTS_TODO"></a>DRAFTS_TODO</h2><ul><li><input disabled="" type="checkbox"> AIO</li><li><input disabled="" type="checkbox"> kafka简介</li><li><input disabled="" type="checkbox"> rocketmq-Broker启动流程</li><li><input disabled="" type="checkbox"> B+树</li></ul><h2 id="OTHER-TODO"><a href="#OTHER-TODO" class="headerlink" title="OTHER_TODO"></a>OTHER_TODO</h2><ul><li><input disabled="" type="checkbox"> shiro</li><li><input disabled="" type="checkbox"> mq消费失败处理</li><li><input disabled="" type="checkbox"> 单例模式</li><li><input disabled="" type="checkbox"> 腾讯烧香问题</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h1&gt;</summary>
    
    
    
    <category term="todo" scheme="https://linqiankun.github.io/hexoblog/categories/todo/"/>
    
    
    <category term="todo" scheme="https://linqiankun.github.io/hexoblog/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>外包公司大汇总</title>
    <link href="https://linqiankun.github.io/hexoblog/%E5%A4%96%E5%8C%85%E5%85%AC%E5%8F%B8%E5%A4%A7%E6%B1%87%E6%80%BB/"/>
    <id>https://linqiankun.github.io/hexoblog/%E5%A4%96%E5%8C%85%E5%85%AC%E5%8F%B8%E5%A4%A7%E6%B1%87%E6%80%BB/</id>
    <published>2022-12-31T15:59:58.000Z</published>
    <updated>2021-07-12T11:38:30.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外包公司汇总"><a href="#外包公司汇总" class="headerlink" title="外包公司汇总"></a>外包公司汇总</h1><span id="more"></span><ol><li>德科（华为）</li><li>捷程易信（网易）</li><li>恒生（阿里）</li><li><em>乌鸠科技</em>（阿里）</li><li><em>端点</em>（阿里）</li><li>博彦科技</li><li>科蓝软件</li><li>奥解思</li><li>法本</li><li>广讯通信</li><li>京北方</li><li>汉克时代</li><li>华钦软件CLPS</li><li>长亮科技（银行）</li><li>信雅达科技</li><li>网达软件（咪咕）</li><li>神州信息（银行）</li><li>宇信科技（银行）</li><li>宁波易简电子科技（银行）</li><li>安硕信息技术</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;外包公司汇总&quot;&gt;&lt;a href=&quot;#外包公司汇总&quot; class=&quot;headerlink&quot; title=&quot;外包公司汇总&quot;&gt;&lt;/a&gt;外包公司汇总&lt;/h1&gt;</summary>
    
    
    
    <category term="todo" scheme="https://linqiankun.github.io/hexoblog/categories/todo/"/>
    
    
    <category term="todo" scheme="https://linqiankun.github.io/hexoblog/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>md流程图系列</title>
    <link href="https://linqiankun.github.io/hexoblog/md/tool/md%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%B3%BB%E5%88%97/"/>
    <id>https://linqiankun.github.io/hexoblog/md/tool/md%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%B3%BB%E5%88%97/</id>
    <published>2021-10-31T11:01:30.000Z</published>
    <updated>2021-10-31T12:20:47.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><span id="more"></span><h2 id="Mermaid-系列"><a href="#Mermaid-系列" class="headerlink" title="Mermaid 系列"></a>Mermaid 系列</h2><h3 id="横向流程图"><a href="#横向流程图" class="headerlink" title="横向流程图"></a>横向流程图</h3><pre class="mermaid">graph LR    A[方形] -->B(圆角)    B --> C{条件a}    C -->|a=1| D[结果1]    C -->|a=2| E[结果2]    F[横向流程图]</pre><h3 id="竖向流程图"><a href="#竖向流程图" class="headerlink" title="竖向流程图"></a>竖向流程图</h3><pre class="mermaid">graph TD    A[方形] --> B(圆角)    B --> C{条件a}    C --> |a=1| D[结果1]    C --> |a=2| E[结果2]    C --> |a=2| E[结果2]    F[竖向流程图]</pre><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><pre class="mermaid">sequenceDiagram    participant 张三    participant 李四    张三->王五: 王五你好吗？    loop 健康检查        王五->王五: 与疾病战斗    end    Note right of 王五: 合理 食物 <br/>看医生...    李四-->>张三: 很好!    王五->李四: 你怎么样?    李四-->王五: 很好!</pre><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><pre class="mermaid">gantt    dateFormat  YYYY-MM-DD    title 软件开发甘特图    section 设计    需求                      :done,    des1, 2014-01-06,2014-01-08    原型                      :active,  des2, 2014-01-09, 3d    UI设计                    :         des3, after des2, 5d    未来任务                  :         des4, after des3, 5d    section 开发    学习准备理解需求           :crit, done, 2014-01-06,24h    设计框架                  :crit, done, after des2, 2d    开发                      :crit, active, 3d    未来任务                  :crit, 5d    耍                        :2d    section 测试    功能测试                  :active, a1, after des3, 3d    压力测试                  :after a1, 20h    测试报告                  : 48h</pre><hr><h2 id="Flow系列"><a href="#Flow系列" class="headerlink" title="Flow系列"></a>Flow系列</h2><h3 id="横向流程图-1"><a href="#横向流程图-1" class="headerlink" title="横向流程图"></a>横向流程图</h3><div id="flowchart-0" class="flow-chart"></div><h3 id="竖向流程图-1"><a href="#竖向流程图-1" class="headerlink" title="竖向流程图"></a>竖向流程图</h3><div id="flowchart-1" class="flow-chart"></div><hr><h2 id="sequence系列"><a href="#sequence系列" class="headerlink" title="sequence系列"></a>sequence系列</h2><h3 id="uml时序图"><a href="#uml时序图" class="headerlink" title="uml时序图"></a>uml时序图</h3><div id="sequence-0"></div><h3 id="uml复杂时序图"><a href="#uml复杂时序图" class="headerlink" title="uml复杂时序图"></a>uml复杂时序图</h3><div id="sequence-1"></div><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st->op->condcond(yes)->io->econd(no)->sub1(right)->op</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st(right)->op(right)->condcond(yes)->io(bottom)->econd(no)->sub1(right)->op</textarea><textarea id="flowchart-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><script src="https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">对象A->对象B: 对象B你好吗？（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B-->对象A: 我很好(响应)对象A->对象B: 你真的好吗？</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">对象A->对象B: 对象B你好吗？（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B-->对象A: 我很好(响应)对象B->小三: 你好吗小三-->>对象A: 对象B找我了对象A->对象B: 你真的好吗？Note right of C: 没人陪我玩Note over 小三,对象B: 我们是朋友</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;画图&quot;&gt;&lt;a href=&quot;#画图&quot; class=&quot;headerlink&quot; title=&quot;画图&quot;&gt;&lt;/a&gt;画图&lt;/h1&gt;</summary>
    
    
    
    <category term="tool" scheme="https://linqiankun.github.io/hexoblog/categories/tool/"/>
    
    
    <category term="tool" scheme="https://linqiankun.github.io/hexoblog/tags/tool/"/>
    
    <category term="md" scheme="https://linqiankun.github.io/hexoblog/tags/md/"/>
    
  </entry>
  
  <entry>
    <title>redis哨兵模式</title>
    <link href="https://linqiankun.github.io/hexoblog/md/redis/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/md/redis/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-09-18T03:11:01.000Z</published>
    <updated>2021-09-18T08:19:59.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h1><p>&emsp;&emsp;redis的高可用模式一般有三种，主从复制，哨兵模式，集群模式。</p><span id="more"></span><h1 id="redis哨兵机制"><a href="#redis哨兵机制" class="headerlink" title="redis哨兵机制"></a>redis哨兵机制</h1><p>&emsp;&emsp;原理简单来说就是：通过一个哨兵集群去监控redis服务器集群，从而在集群中的主服务器挂掉之后，能第一时间选择一个从机升级为主机顶上去。<br>&emsp;&emsp;哨兵模式是一种特殊的模式，Redis提供了哨兵命令，哨兵是一个独立的进程。<br>&emsp;&emsp;其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控多个运行的Redis实例。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="Redis哨兵"></p><p>这里哨兵发挥两个作用：</p><ol><li>通过发送命令，让Redis服务器返回其运行状态，包括主服务器和从服务器。</li><li>当哨兵检测到主机宕机时，会自动将从机切换成主机，然后通过发布订阅模式，通知其他从机，通知它们修改配置，切换主机。</li></ol><p>&emsp;&emsp;当单个哨兵监控集群时，可能会出现问题，可以使用多个哨兵进行监控，哨兵之间还可以相互监控，就形成了多哨兵模式。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%93%A8%E5%85%B5%E7%BE%A4.png" alt="多哨兵监控集群"></p><p>&emsp;&emsp;故障切换过程，假设主服务器宕机，哨兵1检测到这个结果，系统并不会马山进行failover过程，仅仅时哨兵1主观的认为主服务不可用，这个现象称为主观下线。当后面的哨兵也检测到主服务不可用时，并且数量达到一定值（n/2+1，就是一半加1）的时候，哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作，切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。</p><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.jianshu.com/p/06ab9daf921d">Redis哨兵（Sentinel）模式</a></li><li><a href="https://www.jianshu.com/p/3088df513196">Redis哨兵集群</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;redis高可用&quot;&gt;&lt;a href=&quot;#redis高可用&quot; class=&quot;headerlink&quot; title=&quot;redis高可用&quot;&gt;&lt;/a&gt;redis高可用&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;redis的高可用模式一般有三种，主从复制，哨兵模式，集群模式。&lt;/p&gt;</summary>
    
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/categories/redis/"/>
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>大华二面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%A4%A7%E5%8D%8E%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%A4%A7%E5%8D%8E%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-27T01:28:46.000Z</published>
    <updated>2021-07-27T07:19:39.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>项目介绍</li><li>系统结构介绍</li><li>AQS<ol><li>底层结构</li><li>用在那些地方</li></ol></li><li>redis<ol><li>redis分布式锁的实现</li><li>集群情况</li></ol></li><li>rocketmq<ol><li>用在什么场景</li><li>消息同步不一致的情况怎么处理</li></ol></li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><ul><li><a href="../../../md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS">juc之AQS</a></li><li><a href="../../../md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E4%B8%80">juc之AQS源码一</a></li><li><a href="../../../md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E4%BA%8C">juc之AQS源码二</a></li></ul><h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><ul><li><a href="../../../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">redis分布式锁</a></li><li><a href="../../../categories/redis/">redis分类</a></li></ul><h2 id="rocketmq"><a href="#rocketmq" class="headerlink" title="rocketmq"></a>rocketmq</h2><ul><li><a href="../../../md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7">rocketmq消息可靠性</a></li><li><a href="../../../categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/">rocketmq分类</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="answer" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/answer/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>索引的优缺点</title>
    <link href="https://linqiankun.github.io/hexoblog/md/mysql/%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>https://linqiankun.github.io/hexoblog/md/mysql/%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</id>
    <published>2021-07-22T06:53:37.000Z</published>
    <updated>2021-07-22T07:20:59.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>&emsp;&emsp;索引的作用在于创建索引能大大提高系统的性能。</p><span id="more"></span><hr><h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><ul><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li><li>大大加快数据的检索速度，这也是创建索引的最主要原因</li><li>加快表与表之间的连接，在实现数据的参考完整性方面特别有意义</li><li>在使用分组和排序，子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ul><hr><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li>创建索引和维护索引需要时间，这种时间随着数据量的增加而增加</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占物理空间，如果要建立聚簇索引，需要的空间更大</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这就降低了数据的维护速度。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;索引的作用在于创建索引能大大提高系统的性能。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
    <category term="mysql" scheme="https://linqiankun.github.io/hexoblog/tags/mysql/"/>
    
    <category term="数据库" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>大华一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%A4%A7%E5%8D%8E%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%A4%A7%E5%8D%8E%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-21T01:52:29.000Z</published>
    <updated>2021-07-25T09:14:41.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>jvm类的加载过程？</li><li>dubbo如何做选举的？</li><li>了解的设计模式，spring用的设计模式？</li><li>还了解那些设计模式？</li><li>springboot里面的listener？</li><li>代理模式与AOP？</li><li>redis主从复制与哨兵模式？</li><li>分布式事务实现？</li><li>syncnorized和ReentrantLock的区别？</li><li>反问</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="jvm类的加载过程"><a href="#jvm类的加载过程" class="headerlink" title="jvm类的加载过程"></a>jvm类的加载过程</h2><ul><li><a href="../../../md/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">类加载机制</a>  </li><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/dvd9gz">类加载机制</a></li></ul><h2 id="dubbo如何做选举的"><a href="#dubbo如何做选举的" class="headerlink" title="dubbo如何做选举的"></a>dubbo如何做选举的</h2><p>&emsp;&emsp;这里的选举并不是zk的选举，而是服务消费方获取到提供方节点后，根据负载均衡算法选择某台机器进行远程调用。常见的负载均衡算法有：  </p><ul><li>轮询</li><li>随机</li><li>一致性Hash</li></ul><h2 id="spring用到的设计模式？"><a href="#spring用到的设计模式？" class="headerlink" title="spring用到的设计模式？"></a>spring用到的设计模式？</h2><ul><li>单例模式</li><li>工厂模式</li><li>代理模式</li><li>等</li></ul><h2 id="还了解那些设计模式？"><a href="#还了解那些设计模式？" class="headerlink" title="还了解那些设计模式？"></a>还了解那些设计模式？</h2><ul><li>模板方法模式</li><li>建造者模式</li><li>策略模式</li></ul><h2 id="springboot里面的listener？"><a href="#springboot里面的listener？" class="headerlink" title="springboot里面的listener？"></a>springboot里面的listener？</h2><h2 id="代理模式与AOP？"><a href="#代理模式与AOP？" class="headerlink" title="代理模式与AOP？"></a>代理模式与AOP？</h2><p>&emsp;&emsp;代理模式分为静态代理，动态代理，动态代理又可分为很多种，jdk，cglib等。<br>&emsp;&emsp;AOP是面向切面编程，其中用到了动态代理。</p><h2 id="redis主从复制与哨兵模式？"><a href="#redis主从复制与哨兵模式？" class="headerlink" title="redis主从复制与哨兵模式？"></a>redis主从复制与哨兵模式？</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/haaf3c">redis的高可用方案</a></li></ul><h2 id="分布式事务的实现"><a href="#分布式事务的实现" class="headerlink" title="分布式事务的实现"></a>分布式事务的实现</h2><ul><li><a href="../../../md/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">分布式事务</a>  </li><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/fwl3rv">分布式事务</a></li></ul><h2 id="syncnorized和ReentrantLock的区别？"><a href="#syncnorized和ReentrantLock的区别？" class="headerlink" title="syncnorized和ReentrantLock的区别？"></a>syncnorized和ReentrantLock的区别？</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/rc3ofp">syncnorized</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="answer" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/answer/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>同花顺一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%90%8C%E8%8A%B1%E9%A1%BA%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%90%8C%E8%8A%B1%E9%A1%BA%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-21T01:49:24.000Z</published>
    <updated>2021-07-27T09:12:20.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>jvm<ol><li>堆内存溢出<ol><li>怎么快速的堆内存溢出</li><li>溢出怎么防止</li><li>为什么会堆内存溢出</li><li>不段创建String对象，和不断创建线程造成溢出的区别？</li><li>怎么分析，dump内存文件</li><li>分析hprof文件，有那些内容</li></ol></li><li>栈指针溢出<ol><li>怎么快速的栈指针溢出</li><li>怎么防止</li><li>为什么会栈指针溢出</li></ol></li><li>垃圾回收器<ol><li>你们用的垃圾回收器</li><li>你知道的垃圾回收器</li><li>讲一讲过程，区别（CMS，G1）</li></ol></li></ol></li><li>redis分布式锁实现</li><li>mysql索引，为什么需要索引，自己的理解</li><li>mysql索引的数据结构</li><li>你们数据量级，一次处理的数据量</li><li>线程池，几个核心参数的作用，不背原理</li><li>hashmap和hashtable的区别</li><li>dubbo如何实现高可用的</li><li>反问</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="redis分布式锁的实现"><a href="#redis分布式锁的实现" class="headerlink" title="redis分布式锁的实现"></a>redis分布式锁的实现</h2><ul><li><a href="../../../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">reids分布式锁</a></li><li><a href="../../../md/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a></li></ul><h2 id="mysql索引，为什么需要索引"><a href="#mysql索引，为什么需要索引" class="headerlink" title="mysql索引，为什么需要索引"></a>mysql索引，为什么需要索引</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/aoz98d">mysql索引</a></li><li><a href="../../../md/mysql/%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">索引的优缺点</a></li></ul><p>&emsp;&emsp;mysql索引的最大最用就在于提高查询效率，原理在数据结构中，索引在提高查询效率的同时降低了修改的效率。  </p><h2 id="mysql索引的数据结构"><a href="#mysql索引的数据结构" class="headerlink" title="mysql索引的数据结构"></a>mysql索引的数据结构</h2><p>&emsp;&emsp;索引数据的组织结构和数据的组织结构是一样的，都是B+树的结构，区别在于他们的叶子节点所存储的数据，数据存储文件中叶子节点中存储着主键索引和表中的数据，而索引保存文件中，叶子节点则存储着索引字段以及对应的主键id值。<br>&emsp;&emsp;当通过素引进行查询时，会先根据索引查询出主键id的值，在在数据保存文件中，根据id查出所需要的数据，这个过程叫做回表。</p><h2 id="线程池理解（corepoolsize）"><a href="#线程池理解（corepoolsize）" class="headerlink" title="线程池理解（corepoolsize）"></a>线程池理解（corepoolsize）</h2><ul><li><a href="../../../md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/threadpool">threadpool</a></li><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/egl1t0">threadpool</a><br>&emsp;&emsp;个人理解，核心线程数，就相当于车间里面的流水线数，就是正常情况下运行的流水线数，最大的线程数，就是再有紧急订单的情况下，我们在正常的流水线上，扩充到的流水线数。</li></ul><h2 id="hashmap和hashtable"><a href="#hashmap和hashtable" class="headerlink" title="hashmap和hashtable"></a>hashmap和hashtable</h2><p>&emsp;&emsp;hashmap和hashtable的区别有几点：</p><ul><li>继承和实现方式不同<ul><li>hashmap实现的是map接口</li><li>hashtable实现的是map接口继承的Dictionary类</li></ul></li><li>线程安全不同<ul><li>hashmap线程不安全</li><li>hashtable线程安全，在每个方法中都加入Synchronize方法。</li></ul></li><li>对null的处理不同<ul><li>hashtable键与值均不允许null</li><li>hashmap均可以null，null为键只会有一个</li></ul></li><li>支持的遍历种类不同<ul><li>Hashtable、HashMap都使用了Iterator。</li><li>而由于历史原因，Hashtable还使用了Enumeration的方式 。</li></ul></li><li>通过Iterator迭代器遍历时，遍历的顺序不同<ul><li>hashmap采用fail-fast机制</li><li>hashtable在1.8以后才用了fail-fast机制</li></ul></li><li>容量的初始值和增加方式都不一样<ul><li>hashmap初始16，扩容为2倍</li><li>hashtable为11，扩容为2*N+1</li></ul></li><li>添加key-value时的hash值算法不同<ul><li>haspmap采用key的hashcode确定位置</li><li>hashtable采用对象的hashcode，然后对长度才用除留余数法确定位置</li></ul></li></ul><h2 id="dubbo如何实现高可用"><a href="#dubbo如何实现高可用" class="headerlink" title="dubbo如何实现高可用"></a>dubbo如何实现高可用</h2><p>&emsp;&emsp;dubbo通过一系列手段实现了，高可用。</p><ul><li>zookeeper宕机与dubbo直连<ul><li>zookeeper注册中心宕机，还可以消费dubbo暴露的服务<ul><li>监控中心宕掉不影响使用，只是丢失部分采样数据</li><li>数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务</li><li>注册中心对等集群，任意一台宕掉后，将自动切换到另一台</li><li>注册中心全部宕机后，可以通过本地缓存进行通信，（直连）</li><li>服务提供者无状态，任意一台宕掉后，不影响使用</li><li>服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复</li></ul></li></ul></li><li>集群下的负载均衡<ul><li>带权重的随机</li><li>带权重的轮询</li><li>最少活跃数</li><li>一致性hash</li></ul></li><li>服务降级</li><li>集群容错机制<ul><li>Failover Cluster：失败自动切换</li><li>Failfast Cluster：快速失败，失败则立即报错</li><li>Failsafe Cluster：安全失败，失败就会忽略</li><li>Failback Cluster：失败自动恢复，会定时重发</li><li>Forking Cluster：并行调用，只需一个成功返回</li><li>Broadcast Cluster：广播调用，逐个调用每个提供者，任意一台报错则报错</li></ul></li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h3><h4 id="怎么快速的堆内存溢出？"><a href="#怎么快速的堆内存溢出？" class="headerlink" title="怎么快速的堆内存溢出？"></a>怎么快速的堆内存溢出？</h4><p>&emsp;&emsp;通过jvm参数去设置堆内存大小，然后再循环里面不断的创建线程，直到报OutOfMemory异常。</p><h4 id="堆内存溢出怎么防止？"><a href="#堆内存溢出怎么防止？" class="headerlink" title="堆内存溢出怎么防止？"></a>堆内存溢出怎么防止？</h4><p>&emsp;&emsp;最直接的办法就是直接调整堆内存的大小，也有一写在编写代码过程中注意的，防止内存溢出：</p><ul><li>尽早释放无用对象的引用</li><li>程序进行字符串处理时，尽量避免使用String，而应该使用StringBuffer</li><li>尽量少用静态变量（全局的，存在方法区，不会被回收）</li><li>避免集中创建对象，尤其是大对象，如果可以的话尽量使用流操作</li><li>尽量运用对象池技术以提高系统性能</li><li>不要在经常调用的方法中创建对象，尤其忌讳在循环中创建对象</li><li>优化配置<ul><li>从代码层面进行优化完善，尽量避免该情况发生</li><li>调整优化服务器配置：<ul><li>设置-Xms、-Xmx等</li><li>设置NewSize、MaxNewSize相等</li><li>设置Heap size，PermGen space</li></ul></li></ul></li></ul><p>&emsp;&emsp;可以通过一些手段保证代码安全：</p><ul><li>是否应用中的类中和引用变量过多使用了Static修饰</li><li>是否应用中使用了大量的递归或无限递归（递归中创建对象）</li><li>是否App中使用了大量循环或死循环（循环中创建对象）</li><li>检查应用中是否使用了向数据库查询所有记录的方法</li><li>检查是否有数组，List，Map中存放的是对象的引用而不是对象（这些引用会使得对象无法被释放）</li><li>检查是否使用了“非字面量字符串进行+”的操作，String对象每次+</li></ul><h4 id="为什么会堆内存溢出？"><a href="#为什么会堆内存溢出？" class="headerlink" title="为什么会堆内存溢出？"></a>为什么会堆内存溢出？</h4><p>&emsp;&emsp;内存大小不够；是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory。</p><h4 id="不断创建String和不断创建线程造成内存溢出的区别？"><a href="#不断创建String和不断创建线程造成内存溢出的区别？" class="headerlink" title="不断创建String和不断创建线程造成内存溢出的区别？"></a>不断创建String和不断创建线程造成内存溢出的区别？</h4><p>&emsp;&emsp;本质上，创建String就是创建了一个对象，分配了一块内存空间，而创建线程，则也会创建线程对象（Thread类的对象），区别在于创建线程的对象中，会包含一些线程的相关信息，也就是区别在线程对象的信息和普通对象的信息不同。</p><h4 id="怎么分析，dump内存文件"><a href="#怎么分析，dump内存文件" class="headerlink" title="怎么分析，dump内存文件"></a>怎么分析，dump内存文件</h4><p>&emsp;&emsp;一般有两种方法，自动和手动。</p><ul><li>jvm参数：-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/admin/logs/java.hprof</li><li>jmap -dump:format=b,file=/home/admin/logs/heap.hprof javapid</li></ul><p>&emsp;&emsp;dump内存文件后，可以通过一些工具进行分析。</p><ul><li>mat</li><li>visual VM</li><li>JProfiler</li></ul><h3 id="栈指针溢出"><a href="#栈指针溢出" class="headerlink" title="栈指针溢出"></a>栈指针溢出</h3><h4 id="怎么快速栈指针溢出？"><a href="#怎么快速栈指针溢出？" class="headerlink" title="怎么快速栈指针溢出？"></a>怎么快速栈指针溢出？</h4><p>&emsp;&emsp;通过死循环内调用方法，或者递归没有出口，无限递归，造成StackOverFlow异常。</p><h4 id="怎么防止栈指针溢出？"><a href="#怎么防止栈指针溢出？" class="headerlink" title="怎么防止栈指针溢出？"></a>怎么防止栈指针溢出？</h4><p>&emsp;&emsp;通过一些判断，保证代码安全，破坏栈指针溢出的条件：</p><ul><li>是否有递归调用</li><li>是否有大量循环或者死循环</li><li>全局变量是否过多</li><li>数组、List、map数据是否过大</li><li>使用DDMS工具进行查找大概出现栈溢出的位置</li></ul><h4 id="为什么为栈指针溢出？"><a href="#为什么为栈指针溢出？" class="headerlink" title="为什么为栈指针溢出？"></a>为什么为栈指针溢出？</h4><p>&emsp;&emsp;栈指针溢出其实可以分为两种，不过一般说的是第一种，本质都是由内存不足引起的。</p><ul><li>线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError</li><li>虚拟机在扩展栈深度时无法申请到足够的内存空间，将抛出OutOfMemberError</li></ul><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><h4 id="你们用的垃圾回收器？你知道的垃圾回收器？CMS和G1的区别？"><a href="#你们用的垃圾回收器？你知道的垃圾回收器？CMS和G1的区别？" class="headerlink" title="你们用的垃圾回收器？你知道的垃圾回收器？CMS和G1的区别？"></a>你们用的垃圾回收器？你知道的垃圾回收器？CMS和G1的区别？</h4><ul><li><a href="../../../md/jvm/JVM%E2%80%94GC">JVM-GC</a></li></ul><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/treasure716/p/10019506.html">如何避免内存泄漏、溢出</a></li><li><a href="https://blog.csdn.net/u011983531/article/details/63250882">写代码实现堆溢出、栈溢出、永久代溢出、直接内存溢出</a></li><li><a href="https://blog.csdn.net/hukuncd/article/details/105528122">java内存溢出、栈溢出的原因与排查方法</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>禾连科技一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E7%A6%BE%E8%BF%9E%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E7%A6%BE%E8%BF%9E%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-15T11:38:41.000Z</published>
    <updated>2021-08-12T08:13:45.392Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>项目介绍</li><li>用到那些jdk版本？</li><li>1.8有哪些新特性？</li><li>Stream API用到那些方法？</li><li>Stream API并行情况？</li><li>用到那些集合？</li><li>用到那些线程安全的集合？</li><li>threadlocal用在什么场景？</li><li>threadlocal结构？</li><li>子线程能否拿到主线程threadlocal的内容？怎么拿？</li><li>为什么用dubbo？</li><li>dubbo用什么做注册中心？</li><li>还有那些注册中心？</li><li>dubbo启动扫描服务的过程？</li><li>同一个dubbo服务，不同的用户要使用，dubbo怎么做用户区分？</li><li>索引失效的情况？</li><li>like对字段后半截查询（前半截模糊，后半截精确），如何优化？</li><li>为什么有young gc和old gc？</li><li>标记清除算法用在那个阶段？</li><li>反射有那些方法得到一个类？</li><li>Class.forName和ClassLoader.loadclass的区别？</li><li>为什么要用Class.forName？使用场景？</li><li>为什么用rocketmq？</li><li>rocketmq用在什么场景？</li><li>分布式锁怎么实现的？为什么没有用成熟的解决方案？</li><li>反问</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="jdk1-8有哪些新特性？"><a href="#jdk1-8有哪些新特性？" class="headerlink" title="jdk1.8有哪些新特性？"></a>jdk1.8有哪些新特性？</h2><p>&emsp;&emsp;1.8中添加了一些新的特性。</p><ul><li>Lambda表达式</li><li>函数式接口</li><li>方法引用和构造器引用（前三个一般联合使用）</li><li>Stream API</li><li>接口中的默认方法和静态方法</li><li>LocalDate API</li><li>Optional类</li><li>Base64 API</li><li>数组并行操作</li><li>永久代移除，增加元空间</li></ul><h2 id="Stream-API用到那些方法？"><a href="#Stream-API用到那些方法？" class="headerlink" title="Stream API用到那些方法？"></a>Stream API用到那些方法？</h2><ul><li><a href="https://mp.weixin.qq.com/s/jUBKPGGgF0mkuxQ6RBeYyA">20 个实例玩转 Java 8 Stream</a></li><li><a href="https://mp.weixin.qq.com/s/Vu5LMjlBMXtmdFk2QfnFtw">深度掌握java stream 流操作，让你的代码高出一个逼格！</a></li></ul><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/StreamAPI.jpg" alt="StreamAPI"><br><img src="https://gitee.com/linqiankun/picurl/raw/master/java/StreamAPI2.png" alt="StreamAPI"></p><h2 id="Stream-API并行情况？"><a href="#Stream-API并行情况？" class="headerlink" title="Stream API并行情况？"></a>Stream API并行情况？</h2><ul><li><a href="https://mp.weixin.qq.com/s/7J56xP1DVXa8H1kH32QFhA">你了解 JDK 8 Stream 数据流效率吗？千万级数据量性能如何？</a></li><li><a href="https://mp.weixin.qq.com/s/EOw9zVIlC6MnEaGCHqca6A">Java8 Stream 数据流，大数据量下的性能效率怎么样？</a></li><li><a href="https://mp.weixin.qq.com/s/ESmH1vLGENEop-C1R2HCAQ">JDK 8 Stream 数据流效率怎么样？</a></li></ul><h2 id="常用的有哪些集合？"><a href="#常用的有哪些集合？" class="headerlink" title="常用的有哪些集合？"></a>常用的有哪些集合？</h2><p>&emsp;&emsp;常用的集合主要可以分为4类，map、set、list和vector，hashtable等其他的。  </p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E9%9B%86%E5%90%881.jpg" alt="集合集成关系图"></p><h2 id="常用的并发安全集合集合有哪些？"><a href="#常用的并发安全集合集合有哪些？" class="headerlink" title="常用的并发安全集合集合有哪些？"></a>常用的并发安全集合集合有哪些？</h2><ul><li><a href="https://www.jianshu.com/p/b8544e2c5fdb">多线程并发下的线程安全的集合类的使用</a></li></ul><p>&emsp;&emsp;并发安全的集合有多种，也可以将不安全的集合转化为并发安全的集合。</p><ul><li>ConcurrentHashMap</li><li>HashTable</li><li>Collections.synchronizedCollection()方法转换</li><li>StringBuffer</li></ul><h2 id="threadlocal用在什么场景？"><a href="#threadlocal用在什么场景？" class="headerlink" title="threadlocal用在什么场景？"></a>threadlocal用在什么场景？</h2><p>&emsp;&emsp;ThreadLocal有两大典型使用场景。</p><ul><li><strong>场景1：</strong> 每个线程需要一个独享的对象（通常是工具类，典型需要使用的类有SimpleDateFormat和Random<blockquote><p>SimpleDateFormat这种每个线程都需要使用，但是线程不安全的类</p></blockquote></li><li><strong>场景2：</strong> 每个线程内需要保存全局变量（例如在拦截器中获取用户信息），可以让不同方法直接使用，避免参数传递的麻烦。</li></ul><h2 id="threadlocal结构？"><a href="#threadlocal结构？" class="headerlink" title="threadlocal结构？"></a>threadlocal结构？</h2><p>&emsp;&emsp;threadLocal底层采用了一个和线程绑定的ThreadLocalMap，这个map与线程绑定，每个线程都是自己，对自己的进行操作。<br>&emsp;&emsp;ThreadLocalMap的底层则是一个Entry数组，用threadlocal作为Entry的key，而值则是由我们控制。</p><h2 id="子线程能否拿到主线程threadlocal的内容？怎么拿？"><a href="#子线程能否拿到主线程threadlocal的内容？怎么拿？" class="headerlink" title="子线程能否拿到主线程threadlocal的内容？怎么拿？"></a>子线程能否拿到主线程threadlocal的内容？怎么拿？</h2><p>&emsp;&emsp;默认情况下，子线程是无法拿到主线程的ThreadLocal中的信息的，可以通过手动传递，ThreadLocal有一个子类，可以使用<code>InheritableThreadLocal</code>，可以进行父子线程传递数据。</p><h2 id="为什么用dubbo？"><a href="#为什么用dubbo？" class="headerlink" title="为什么用dubbo？"></a>为什么用dubbo？</h2><ul><li><a href="../../../md/rpc/dubbo/dubbo%E5%9F%BA%E7%A1%80%E5%8F%8A%E4%BB%8B%E7%BB%8D">dubbo基础及介绍</a></li></ul><h2 id="dubbo用什么做注册中心？"><a href="#dubbo用什么做注册中心？" class="headerlink" title="dubbo用什么做注册中心？"></a>dubbo用什么做注册中心？</h2><p>&emsp;&emsp;dubbo的注册中心有四种：</p><ul><li><p>Nacos注册中心</p></li><li><p>Multicast注册中心</p><blockquote><p>不需要启动任何中心节点，只要广播地址一样，就可以互相发现。<br>为了减少广播量，Dubbo缺省使用单播发送提供者地址信息给消费者，如果一个机器上同时启了多个消费者进程，消费者需声明unicast=false，否则只会有一个消费者能收到消息；当服务者和消费者运行在同一台机器上，消费者同样需要声明unicast=false，否则消费者无法收到消息，导致<code>No provider available for the service</code>异常。</p></blockquote></li><li><p>Zookeeper注册中心</p></li><li><p>Redis注册中心</p><blockquote><p>从2.1.0版本开始支持。<br>使用Redis的Key/Map结构存储数据结构。<br>使用Redis的Publish/Subscribe事件通知数据变更。</p></blockquote></li><li><p>Simple注册中心</p><blockquote><p>Simple注册中心本身就是一个普通的Dubbo服务，可以减少第三方依赖，使整体通讯方式一致。<br>不支持集群</p></blockquote></li><li><p><a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/registry/">https://dubbo.apache.org/zh/docs/v2.7/user/references/registry/</a></p></li></ul><h2 id="dubbo启动扫描服务的过程？"><a href="#dubbo启动扫描服务的过程？" class="headerlink" title="dubbo启动扫描服务的过程？"></a>dubbo启动扫描服务的过程？</h2><ul><li><a href="../../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5%E6%B5%81%E7%A8%8B">dubbo服务发现</a></li><li><a href="../../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">dubbo服务调用过程</a></li></ul><h2 id="同一个dubbo服务，不同的用户要使用，dubbo怎么做用户区分？"><a href="#同一个dubbo服务，不同的用户要使用，dubbo怎么做用户区分？" class="headerlink" title="同一个dubbo服务，不同的用户要使用，dubbo怎么做用户区分？"></a>同一个dubbo服务，不同的用户要使用，dubbo怎么做用户区分？</h2><p>&emsp;&emsp;对于这种情况，可以通过对相同的接口采用不同的版本进行区分。</p><h2 id="索引失效的情况？"><a href="#索引失效的情况？" class="headerlink" title="索引失效的情况？"></a>索引失效的情况？</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/aoz98d#1ETQP">索引失效的情况</a></li></ul><h2 id="like对字段后半截查询（前半截模糊，后半截精确），如何优化？"><a href="#like对字段后半截查询（前半截模糊，后半截精确），如何优化？" class="headerlink" title="like对字段后半截查询（前半截模糊，后半截精确），如何优化？"></a>like对字段后半截查询（前半截模糊，后半截精确），如何优化？</h2><p>&emsp;&emsp;一般而言在后半段模糊的情况下，like中的值可以根据前半段进行索引匹配，提高效率。<br>&emsp;&emsp;对于前半段模糊的情况，可以考虑使用覆盖索引，对like中的值和一个其他字段建立复合索引。<br>&emsp;&emsp;也考虑使用函数达到优化的效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> LOCATE(<span class="string">&#x27;substr&#x27;</span>,str,pos)：返回substr在(pos后)str中第一次出现的位置，如果substr在str中不存在，返回值为<span class="number">0</span>。</span><br><span class="line">  <span class="operator">&gt;</span> <span class="keyword">SELECT</span> `<span class="keyword">column</span>` <span class="keyword">FROM</span> `<span class="keyword">table</span>` <span class="keyword">WHERE</span> LOCATE(<span class="string">&#x27;keyword&#x27;</span>, `field`)<span class="operator">&gt;</span><span class="number">0</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">POSITION</span>(<span class="string">&#x27;substr&#x27;</span> <span class="keyword">IN</span> `field`)</span><br><span class="line">  <span class="operator">&gt;</span> <span class="keyword">SELECT</span> `<span class="keyword">column</span>` <span class="keyword">FROM</span> `<span class="keyword">table</span>` <span class="keyword">WHERE</span> <span class="built_in">POSITION</span>(<span class="string">&#x27;keyword&#x27;</span> <span class="keyword">IN</span> `filed`)</span><br><span class="line"><span class="operator">-</span> INSTR(`str`,<span class="string">&#x27;substr&#x27;</span>)</span><br><span class="line">  <span class="operator">&gt;</span> <span class="keyword">SELECT</span> `<span class="keyword">column</span>` <span class="keyword">FROM</span> `<span class="keyword">table</span>` <span class="keyword">WHERE</span> INSTR(`field`, <span class="string">&#x27;keyword&#x27;</span> )<span class="operator">&gt;</span><span class="number">0</span> </span><br><span class="line"><span class="operator">-</span> FIND_IN_SET(str1,str2)：返回str2中str1所在的位置索引，其中str2必须以&quot;,&quot;分割开。</span><br><span class="line">  <span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `person` <span class="keyword">WHERE</span> FIND_IN_SET(<span class="string">&#x27;keyword&#x27;</span>,`field`);</span><br></pre></td></tr></table></figure><ul><li><a href="https://blog.csdn.net/soinice/article/details/98476139">MySQL - 如何优化模糊查询（like 模糊查询)</a></li><li><a href="https://blog.csdn.net/UFO___/article/details/81164996">https://blog.csdn.net/UFO___/article/details/81164996</a></li></ul><h2 id="为什么有young-gc和old-gc？"><a href="#为什么有young-gc和old-gc？" class="headerlink" title="为什么有young gc和old gc？"></a>为什么有young gc和old gc？</h2><p>&emsp;&emsp;GC是为了清理JVM在运行中产生的垃圾内存，回收使用。因为GC的效率问题，才会分为young gc和old gc。<br>&emsp;&emsp;相对而言，young gc速度快、次数多，而old gc速度慢、次数少、会停止任务的执行。  </p><ul><li><a href="../../../md/jvm/JVM%E2%80%94GC">GC</a></li><li><a href="https://blog.csdn.net/wildwolf_001/article/details/108873331">Minor GC、Young GC、Full GC、Old GC、Major GC、Mixed GC傻傻分不清</a></li></ul><h2 id="标记清除算法用在什么阶段？"><a href="#标记清除算法用在什么阶段？" class="headerlink" title="标记清除算法用在什么阶段？"></a>标记清除算法用在什么阶段？</h2><p>&emsp;&emsp;标记清除算法一般用在老年代的垃圾回收，主要用在CMS垃圾回收器。</p><h2 id="Class-forName和ClassLoader-loadclass的区别？"><a href="#Class-forName和ClassLoader-loadclass的区别？" class="headerlink" title="Class.forName和ClassLoader.loadclass的区别？"></a>Class.forName和ClassLoader.loadclass的区别？</h2><p>&emsp;&emsp;两者都是加载类的方法，ClassLoader.loadclass中会又三种类加载器，当前类加载器，指定类加载器，线程上下文类加载器。<br>&emsp;&emsp;Class.forName则是通过当前类加载器加载类的。底层会采用ClassLoader.loadclass。<br>&emsp;&emsp;Class.forName加载类的同时进行了初始化工作，ClassLoader.loadclass只加载进了内存中，ClassLoader.loadclass加载的类在用new关键字构造对象时才会初始化。<br>&emsp;&emsp;jdbc中规定，加载的同时需要将类注册进DriverManager中，ClassLoader.loadclass中没有类进行初始化，所以无法注册，不能使用。</p><ul><li><a href="https://www.jianshu.com/p/aedee0e14319">Class.forName和ClassLoader.loadClass</a></li><li><a href="https://blog.csdn.net/a24b86/article/details/119112800">应用在JDBC的Class.forName和ClassLoader.loadClass区别</a></li><li><a href="https://www.cnblogs.com/zeng1994/p/81976a2ea470861e34a4223b7561a970.html">Class.forName() 与 ClassLoader.loadClass()的区别</a></li></ul><h2 id="为什么要用Class-forName？使用场景？"><a href="#为什么要用Class-forName？使用场景？" class="headerlink" title="为什么要用Class.forName？使用场景？"></a>为什么要用Class.forName？使用场景？</h2><p>&emsp;&emsp;<code>Class.forName()</code>，是为了动态加载类，在数据库驱动场景中使用较多，一般在动态加载类后还需要调用<code>newInstance()</code>方法来实例化对象。<br>&emsp;&emsp;<code>Class.forName()</code>返回的是类，<code>newInstance()</code>返回的是实例化的对象。<br>&emsp;&emsp;<code>newInstance()</code>方法返回的对象是弱类型，而<code>new</code>返回的对象是强类型。<br>&emsp;&emsp;java中有三种获得类的方法：</p><ul><li>Class Object = object.getClass();</li><li>Class Object = Object.class;</li><li>Class Object = Class.forName(“java.lang.Object”);</li></ul><h2 id="为什么使用rocketmq？rocketmq用在什么场景？"><a href="#为什么使用rocketmq？rocketmq用在什么场景？" class="headerlink" title="为什么使用rocketmq？rocketmq用在什么场景？"></a>为什么使用rocketmq？rocketmq用在什么场景？</h2><ul><li><a href="../../../categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/">rocketmq分类</a></li></ul><h2 id="分布式锁怎么实现的？为什么没有用成熟的解决方案？"><a href="#分布式锁怎么实现的？为什么没有用成熟的解决方案？" class="headerlink" title="分布式锁怎么实现的？为什么没有用成熟的解决方案？"></a>分布式锁怎么实现的？为什么没有用成熟的解决方案？</h2><ul><li><a href="../../../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">redis分布式</a></li><li><a href="../../../md/zookeeper/zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">zookeeper实现分布式锁</a></li><li><a href="../../../md/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a></li></ul><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.jianshu.com/p/b8544e2c5fdb">多线程并发下的线程安全的集合类的使用</a></li><li><a href="https://mp.weixin.qq.com/s/7J56xP1DVXa8H1kH32QFhA">你了解 JDK 8 Stream 数据流效率吗？千万级数据量性能如何？</a></li><li><a href="https://mp.weixin.qq.com/s/EOw9zVIlC6MnEaGCHqca6A">Java8 Stream 数据流，大数据量下的性能效率怎么样？</a></li><li><a href="https://mp.weixin.qq.com/s/ESmH1vLGENEop-C1R2HCAQ">JDK 8 Stream 数据流效率怎么样？</a></li><li><a href="https://mp.weixin.qq.com/s/jUBKPGGgF0mkuxQ6RBeYyA">20 个实例玩转 Java 8 Stream</a></li><li><a href="https://mp.weixin.qq.com/s/Vu5LMjlBMXtmdFk2QfnFtw">深度掌握java stream 流操作，让你的代码高出一个逼格！</a></li><li><a href="https://blog.csdn.net/ZytheMoon/article/details/89715618">Java版本：JDK8的十大新特性介绍</a></li><li><a href="https://blog.csdn.net/qq_29411737/article/details/80835658">JDK1.8 新特性（全）</a></li><li><a href="https://blog.csdn.net/wildwolf_001/article/details/108873331">Minor GC、Young GC、Full GC、Old GC、Major GC、Mixed GC傻傻分不清</a></li><li><a href="https://www.jianshu.com/p/aedee0e14319">Class.forName和ClassLoader.loadClass</a></li><li><a href="https://blog.csdn.net/a24b86/article/details/119112800">应用在JDBC的Class.forName和ClassLoader.loadClass区别</a></li><li><a href="https://www.cnblogs.com/zeng1994/p/81976a2ea470861e34a4223b7561a970.html">Class.forName() 与 ClassLoader.loadClass()的区别</a></li><li><a href="https://dubbo.apache.org/zh/docs/v2.7/user/references/registry/">https://dubbo.apache.org/zh/docs/v2.7/user/references/registry/</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="answer" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/answer/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>redis底层采用的数据结构</title>
    <link href="https://linqiankun.github.io/hexoblog/md/redis/redis%E5%BA%95%E5%B1%82%E9%87%87%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://linqiankun.github.io/hexoblog/md/redis/redis%E5%BA%95%E5%B1%82%E9%87%87%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-07-15T10:03:30.000Z</published>
    <updated>2021-07-21T08:53:37.715Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;redis是用C语言编写的，底层自己设计了一些数据结构，用这些数据结构完成了对外功能的提供。常说的redis可以存储的几种数据结构，底层就是采用这些数据结构实现的。  </p><span id="more"></span><p>&emsp;&emsp;redis底层的数据结构有：</p><ul><li>SDS：简单动态字符串</li><li>list：链表</li><li>dict：字典</li><li>skiplist：跳跃表</li><li>intset：整数集合</li><li>ziplist：压缩列表</li></ul><hr><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="SDS：简单动态字符串"><a href="#SDS：简单动态字符串" class="headerlink" title="SDS：简单动态字符串"></a>SDS：简单动态字符串</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;redis采用C语言编写，但是redis中的字符串并没有使用C语言提供的字符串，而是自己定义了一种SDS的结构体，用来保存字符串。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span>  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> len;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度  </span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 数据空间  </span></span><br><span class="line">    <span class="keyword">char</span> buf[];  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><ul><li>len变量：用于记录buf中已经使用的空间长度</li><li>free变量：用于记录buf中还空余的空间</li><li>buf：字符数组，用于记录我们的字符串</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>&emsp;&emsp;传统的C语言中，采用长度为N+1的字符数组来保存长度为N的字符串，这样做在获取长度，字符串扩展等操作中效率缓慢。<br>&emsp;&emsp;SDS与传统的C语言字符串有一些优点：</p><ul><li>获取字符串长度快速O(1)与O(n)</li><li>杜绝缓冲区溢出<ul><li>C语言不记录字符串长度，除了获取的时候复杂度高以外，还容易导致缓冲区溢出。修改前面的字符串，不重新分配空间的情况下，有可能覆盖后面的字符串。</li><li>SDS中不会发生溢出，当我们需要对一个SDS 进行修改的时候，redis 会在执行拼接操作之前，预先检查给定SDS 空间是否足够，如果不够，会先拓展SDS 的空间，然后再执行拼接操作。</li></ul></li><li>减少修改字符串时带来的内存重新分配次数<ul><li>字符串拼接会产生字符串的内存空间的扩充，在拼接的过程中，原来的字符串的大小很可能小于拼接后的字符串的大小，那么这样的话，就会导致一旦忘记申请分配空间，就会导致内存的溢出。</li><li>字符串在进行收缩的时候，内存空间会相应的收缩，而如果在进行字符串的切割的时候，没有对内存的空间进行一个重新分配，那么这部分多出来的空间就成为了内存泄露。</li></ul></li><li>二进制安全<blockquote><p>&emsp;&emsp;字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存想图片，音频，视频，压缩文件这样的二进制数据。<br>&emsp;&emsp;但是在Redis中，不是靠空字符来判断字符串的结束的，而是通过len这个属性。那么，即便是中间出现了空字符对于SDS来说，读取该字符仍然是可以的。</p></blockquote></li><li>惰性空间释放<blockquote><p>通过len与free参数，减少了扩展与收缩操作的次数。</p></blockquote></li><li>兼容部分C语言字符串</li></ul><h2 id="List：链表"><a href="#List：链表" class="headerlink" title="List：链表"></a>List：链表</h2><p>&emsp;&emsp;链表提供了搞笑的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。<br>&emsp;&emsp;列表键的底层实现之一就是链表。当一个列表键包含了数量较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;链表的定义分为链表节点的定义和链表的定义。redis中的链表是一个双端链表。</p><p>&emsp;&emsp;链表节点的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">prev</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span></span><br><span class="line">      <span class="keyword">void</span> * value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;链表的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode  * head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode  * tail;</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>双端：链表节点带有prev 和next 指针，获取某个节点的前置节点和后置节点的时间复杂度都是O（N）</li><li>无环：表头节点的 prev 指针和表尾节点的next 都指向NULL，对立案表的访问时以NULL为截止</li><li>表头和表尾：因为链表带有head指针和tail 指针，程序获取链表头结点和尾节点的时间复杂度为O(1)</li><li>长度计数：链表中存有记录链表长度的属性 len</li><li>多态：链表节点使用 void* 指针来保存节点值，并且可以通过list 结构的dup 、 free、 match三个属性为节点值设置类型特定函数。</li></ul><h2 id="Dict：字典"><a href="#Dict：字典" class="headerlink" title="Dict：字典"></a>Dict：字典</h2><p>&emsp;&emsp;字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对的抽象数据结构。<br>&emsp;&emsp;在字典中，一个键（key）可以和一个值（value）进行关联，字典中的每个键都是独一无二的。在C语言中，并没有这种数据结构，但是Redis 中构建了自己的字典实现。</p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;字典的定义分为三块，分别是字典定义，哈希表定义，哈希节点定义。</p><p>&emsp;&emsp;字典定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privedata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht  ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash 索引</span></span><br><span class="line">    in trehashidx;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;哈希表定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">   <span class="comment">//哈希表数组</span></span><br><span class="line">   dictEntry **table;</span><br><span class="line">   <span class="comment">//哈希表大小</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">   <span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;哈希节点定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typeof <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">   <span class="comment">//键</span></span><br><span class="line">   <span class="keyword">void</span> *key;</span><br><span class="line">   <span class="comment">//值</span></span><br><span class="line">   <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">      <span class="keyword">void</span> *val;</span><br><span class="line">      uint64_tu64;</span><br><span class="line">      int64_ts64;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;它们之间的结构关系如下图：</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/redis%E5%AD%97%E5%85%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="redis字典的结构"></p><p>&emsp;&emsp;可以看出来，结构的后半程同hashmap的接口类似，同样也是采用了链地址法来解决hash冲突的问题。</p><h3 id="扩展与收缩"><a href="#扩展与收缩" class="headerlink" title="扩展与收缩"></a>扩展与收缩</h3><p>&emsp;&emsp;随着对哈希表的不断操作，哈希表保存的键值对会逐渐的发生改变，为了让哈希表的负载因子维持在一个合理的范围之内，我们需要对哈希表的大小进行相应的扩展或者压缩，这时候，我们可以通过 rehash（重新散列）操作来完成。<br>&emsp;&emsp;哈希表的空间分配规则：</p><ol><li>如果执行的是拓展操作，那么ht[1]的大小为第一个大于等于ht[0]的2的n次幂</li><li>如果执行的是收缩操作，那么ht[1] 的大小为第一个大于等于ht[0] 的2的n次幂</li></ol><p>&emsp;&emsp;扩展流程：</p><ol><li>ht[0]满数据的情况下</li><li>为ht[1]按照上面的逻辑分配空间</li><li>讲ht[0]的数据转移进ht[1]，这个过程中需要重新进行hash计算</li><li>将ht[0]释放，将ht[1]设置为新的ht[0]</li></ol><p>&emsp;&emsp;数据量较小的时候，可以通过这种方式进行扩容，实际情况下一般采用渐进式rehash。采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。流程基本是：</p><ol><li>为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li><li>在几点钟维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash开始</li><li>在rehash进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash到ht[1]表中，并且将rehashidx加一</li><li>当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash结束</li></ol><h2 id="SkipList：跳表"><a href="#SkipList：跳表" class="headerlink" title="SkipList：跳表"></a>SkipList：跳表</h2><p>&emsp;&emsp;跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表是一种随机化的数据,跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树媲美 ——查找、删除、添加等操作都可以在对数期望时间下完成，并且比起平衡树来说，跳跃表的实现要简单直观得多。<br>&emsp;&emsp;Redis 只在两个地方用到了跳跃表，一个是实现有序集合键，另外一个是在集群节点中用作内部数据结构。</p><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;跳跃表的定义分为两块，表定义和节点定义。<br>&emsp;&emsp;数据节点定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">　　　<span class="comment">//层</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">　　　　　<span class="comment">//前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">　　　　<span class="comment">//跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">　　<span class="comment">//后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">　　<span class="comment">//分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">　　<span class="comment">//成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>层：level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针。</li><li>前进指针：用于指向表尾方向的前进指针</li><li>跨度：用于记录两个节点之间的距离</li><li>后退指针：用于从表尾向表头方向访问节点</li><li>分值和成员：跳跃表中的所有节点都按分值从小到大排序。成员对象指向一个字符串，这个字符串对象保存着一个SDS值</li></ul><p>&emsp;&emsp;跳跃表定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">     <span class="comment">//表头节点和表尾节点</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">     <span class="comment">//表中节点数量</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">     <span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">     <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>跳跃表是有序集合的底层实现之一</li><li>主要有zskiplist 和zskiplistNode两个结构组成</li><li>每个跳跃表节点的层高都是1至32之间的随机数</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的对象必须是唯一的</li><li>节点按照分值的大小从大到小排序，如果分值相同，则按成员对象大小排序</li></ul><h2 id="IntSet：整数集合"><a href="#IntSet：整数集合" class="headerlink" title="IntSet：整数集合"></a>IntSet：整数集合</h2><p>&emsp;&emsp;整数集合是集合建的底层实现之一，当一个集合中只包含整数，且这个集合中的元素数量不多时，redis就会使用整数集合intset作为集合的底层实现。<br>&emsp;&emsp;其实就是一个特殊的集合，里面存储的数据只能够是整数，并且数据量不能过大。</p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> enconding;</span><br><span class="line">   <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组    </span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>encoding：整数集合的编码方式</li><li>length：集合中的元素数量</li><li>contents：用于保存元素的数组</li></ul><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>&emsp;&emsp;intset 在默认情况下会帮我们设定整数集合中的编码方式，但是当我们存入的整数不符合整数集合中的编码格式时，就需要使用到Redis 中的升级策略来解决。流程基本有：</p><ol><li>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</li><li>将底层数组现有的所有元素都转换成新的编码格式，重新分配空间</li><li>将新元素加入到底层数组中</li></ol><p>&emsp;&emsp;升级策略的实现可以提升整数集合的灵活性，节约内存。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>整数集合是集合建的底层实现之一</li><li>整数集合的底层实现为数组，这个数组以有序，无重复的范式保存集合元素，在有需要时，程序会根据新添加的元素类型改变这个数组的类型</li><li>升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存</li><li>整数集合只支持升级操作，不支持降级操作</li></ul><h2 id="ZipList：压缩列表"><a href="#ZipList：压缩列表" class="headerlink" title="ZipList：压缩列表"></a>ZipList：压缩列表</h2><p>&emsp;&emsp;压缩列表是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。</p><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>&emsp;&emsp;压缩列表的结构如图所示：</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="压缩列表的结构"></p><ul><li>zlbytes：用于记录整个压缩列表占用的内存字节数</li><li>zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节</li><li>zllen：记录了压缩列表包含的节点数量</li><li>entryX：列表保存的各个节点</li><li>zlend：用于标记压缩列表的末端</li></ul><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li>压缩列表是一种为了节约内存而开发的顺序型数据结构</li><li>压缩列表被用作列表键和哈希键的底层实现之一</li><li>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值</li><li>添加新节点到压缩列表，可能会引发连锁更新操作</li></ul><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/jaycekon/p/6227442.html">深入浅出Redis-redis底层数据结构（上）</a></li><li><a href="https://www.cnblogs.com/jaycekon/p/6277653.html">深入浅出Redis-redis底层数据结构（下）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;redis是用C语言编写的，底层自己设计了一些数据结构，用这些数据结构完成了对外功能的提供。常说的redis可以存储的几种数据结构，底层就是采用这些数据结构实现的。  &lt;/p&gt;</summary>
    
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/categories/redis/"/>
    
    
    <category term="数据结构" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>spring中bean的生命周期</title>
    <link href="https://linqiankun.github.io/hexoblog/md/spring/spring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://linqiankun.github.io/hexoblog/md/spring/spring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-07-14T08:01:10.000Z</published>
    <updated>2021-07-16T08:48:10.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;Spring中Bean的生命周期，大概可以分为四个阶段和多个扩展点：</p><ol><li>实例化</li><li>属性注入</li><li>初始化</li><li>销毁</li></ol><div id="flowchart-0" class="flow-chart"></div><span id="more"></span><hr><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>&emsp;&emsp;生命周期的的主要过程都在doCreate()方法中，在其中顺序的调用实例化，属性赋值，初始化方法。</p><ol><li>createBeanInstance() -&gt; 实例化</li><li>populateBean() -&gt; 属性赋值</li><li>initializeBean() -&gt; 初始化</li></ol><p>&emsp;&emsp;销毁则在容器关闭时调用，详见<code>ConfigurableApplicationContext#close()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略了无关代码</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 实例化阶段！</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// 属性赋值阶段！</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">       <span class="comment">// 初始化阶段！</span></span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.jianshu.com/p/1dec08d290c1">请别再问Spring Bean的生命周期了！</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: 实例化op2=>operation: 属性注入op3=>operation: 初始化op4=>operation: 销毁op1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Spring中Bean的生命周期，大概可以分为四个阶段和多个扩展点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实例化&lt;/li&gt;
&lt;li&gt;属性注入&lt;/li&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;li&gt;销毁&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&quot;flowchart-0&quot; class=&quot;flow-chart&quot;&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="spring" scheme="https://linqiankun.github.io/hexoblog/categories/spring/"/>
    
    
    <category term="spring" scheme="https://linqiankun.github.io/hexoblog/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring中Bean的实例化过程</title>
    <link href="https://linqiankun.github.io/hexoblog/md/spring/Spring%E4%B8%ADBean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>https://linqiankun.github.io/hexoblog/md/spring/Spring%E4%B8%ADBean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</id>
    <published>2021-07-14T06:57:04.000Z</published>
    <updated>2021-07-14T11:26:10.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;简要说明Spring什么时候实例化bean。</p><span id="more"></span><hr><h1 id="实例化时间"><a href="#实例化时间" class="headerlink" title="实例化时间"></a>实例化时间</h1><p>&emsp;&emsp;如果你使用BeanFactory作为Spring Bean的工厂类，则所有的bean都是在第一次使用该bean的时候实例化。<br>&emsp;&emsp;如果使用ApplicationContext作为工厂类，则可以分为：</p><ol><li>如果bean的scope是singleton的，并且lazy-init为false（默认是false，所以可以不用设置），则 ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中，下次再使用该Bean的时候， 直接从这个缓存中取。</li><li>如果bean的scope是singleton的，并且lazy-init为true，则该Bean的实例化是在第一次使用该Bean的时候进行实例化。</li><li>如果bean的scope是prototype的，则该Bean的实例化是在第一次使用该Bean的时候进行实例化。</li></ol><hr><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/springbean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg" alt="bean的实例化过程"></p><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://blog.csdn.net/mawming/article/details/52287786">spring装配Bean过程以及Bean实例化过程</a></li><li><a href="https://www.cnblogs.com/kevin-yuan/p/12157017.html">Spring Bean 的实例化过程</a></li><li><a href="https://blog.csdn.net/shuangyue/article/details/8585736">Spring Bean实例化过程（2）</a></li><li><a href="https://www.jianshu.com/p/1d0fb520e5c0">spring之Bean实例化过程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;简要说明Spring什么时候实例化bean。&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="https://linqiankun.github.io/hexoblog/categories/spring/"/>
    
    
    <category term="spring" scheme="https://linqiankun.github.io/hexoblog/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>redis中的数据结构</title>
    <link href="https://linqiankun.github.io/hexoblog/md/redis/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://linqiankun.github.io/hexoblog/md/redis/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-07-14T06:53:44.000Z</published>
    <updated>2021-07-21T08:45:48.865Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;redis中共有8种数据结构，其中常用的有5种。这些数据结构基本采用了底层的8种数据结构实现。</p><span id="more"></span><h2 id="常用的5种数据结构"><a href="#常用的5种数据结构" class="headerlink" title="常用的5种数据结构"></a>常用的5种数据结构</h2><ul><li>String（字符串）</li><li>Hash（哈希）</li><li>List（链表）</li><li>Set（集合）</li><li>ZSet（有序集合）</li></ul><h2 id="不常用的3种数据结构"><a href="#不常用的3种数据结构" class="headerlink" title="不常用的3种数据结构"></a>不常用的3种数据结构</h2><ul><li>geospatial（地理位置）</li><li>hyperloglog</li><li>Bitmap（位图）</li></ul><h2 id="底层使用的数据结构"><a href="#底层使用的数据结构" class="headerlink" title="底层使用的数据结构"></a>底层使用的数据结构</h2><ul><li>SDS：简单动态字符串，支持动态扩容的字节数组</li><li>list：链表</li><li>dict：使用双哈希表实现的, 支持平滑扩容的字典</li><li>skiplist：附加了后向指针的跳跃表</li><li>intset：用于存储整数数值集合的自有结构</li><li>ziplist：压缩列表，一种实现上类似于TLV，但比TLV复杂的, 用于存储任意数据的有序序列的数据结构</li><li>quicklist：一种以ziplist作为结点的双链表结构, 实现的非常不错 </li><li>zipmap：一种用于在小规模场合使用的轻量级字典结构</li></ul><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/redis%E7%9A%84%C2%B7%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="redis的五种常用的数据结构"></p><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>&emsp;&emsp;String是redis中最基础的数据类型，普通的kay/value都可以归为此类，value也可以是数字。<br>&emsp;&emsp;redis的String是二进制安全的，可以包含任何数据，如字符串，图片，序列化数据。<br>&emsp;&emsp;使用get、set、del、incr、decr等命令。<br>&emsp;&emsp;String底层采用SDS实现。  </p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>redis为字符串分配空间的次数，是小于等于字符串的长度N，而原C语言中的分配原则必为N。降低了分配次数提高了追加速度，代价就是多占用一些内存空间，且这些空间不会自动释放。</li><li>二进制安全的。</li><li>高效的计算字符串长度。</li><li>高效的追加字符串操作。</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>缓存：经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li><li>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li><li>session：常见方案spring session + redis实现session共享。</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>&emsp;&emsp;Lists就是链表，在redis中的List是一个双端链表，是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。<br>&emsp;&emsp;在3.2版本之前，redis中采用ziplist和linkedlist实现，在3.2版本之后采用quicklist实现。<br>&emsp;&emsp;3.2版本之前，列表对象满足如下条件时采用ziplist，否则采用linkedlist。</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节</li><li>列表对象保存的元素数量小于512个</li></ul><h3 id="使用特点"><a href="#使用特点" class="headerlink" title="使用特点"></a>使用特点</h3><ul><li>lpush+lpop=Stack(栈)</li><li>lpush+rpop=Queue（队列）</li><li>lpush+ltrim=Capped Collection（有限集合）</li><li>lpush+brpop=Message Queue（消息队列）</li></ul><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul><li>timeline：时间轴，按时间的顺序。</li><li>消息队列。</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>&emsp;&emsp;redis的散列可以存储多个键值对之间的映射，散列存储的值既可以是字符串也可以是数字值，并且用户同样可以对散列存储的数字值执行自增操作或者自减操作。散列可以看作是一个文档或关系数据库里的一行。<br>&emsp;&emsp;使用所有hash的命令都是h开头的hget、hset、hdel等。<br>&emsp;&emsp;底层有两种数据结构实现：</p><ul><li>一种是ziplist，当存储的数据超过配置的阀值时就是转用hashtable的结构。使用ziplist的条件是：<ul><li>当键的个数小于hash-max-ziplist-entries（默认512）</li><li>当所有值都小于hash-max-ziplist-value（默认64）</li></ul></li><li>另一种就是hashtable。这种结构的时间复杂度为O(1)，但是会消耗比较多的内存空间。</li></ul><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><ul><li>缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>&emsp;&emsp;集合类型也是用来保存多个字符串的元素。<br>&emsp;&emsp;与列表的不同之处：</p><ul><li>不允许有重复的元素</li><li>集合中的元素是无序的，不能通过索引下标获取元素</li><li>支持集合间的操作，可以取多个集合取交集、并集、差集</li></ul><p>&emsp;&emsp;集合采用HashTable来实现元素不可重复。在hashtable中将set的值作为hashtable的键，而值则为空。<br>&emsp;&emsp;使用命令都是以s开头的sset、srem、scard、smembers、sismember。</p><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><ul><li>标签：给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li><li>点赞，或点踩，收藏等，可以放到set中实现。</li></ul><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p>&emsp;&emsp;有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member),每个成员都是各不相同的。有序集合的值则被称为分值（score），分值必须为浮点数，有序集合中根据分数进行排序。<br>&emsp;&emsp;有序集合是redis里面唯一一个既可以根据成员访问元素(这一点和散列一样)，又可以根据分值以及分值的排列顺序访问元素的结构。<br>&emsp;&emsp;使用有序集合的命令都是以z开头zadd、zrange、zscore。<br>&emsp;&emsp;底层有两种数据结构实现：</p><ul><li>第一种是压缩列表，ziplist</li><li>第二种是skiplist和dict的结合</li></ul><h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><ul><li>排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li></ul><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/haoprogrammer/p/11065461.html">Redis(一)、Redis五种数据结构</a></li><li><a href="https://blog.csdn.net/xpsallwell/article/details/84030285">redis的五种数据结构原理分析</a></li><li><a href="https://www.cnblogs.com/cnki/p/6113109.html">Redis实战（2）Redis八种数据结构（Windows Server）</a></li><li><a href="https://www.cnblogs.com/knowledgesea/p/4970026.html">Redis数据结构详解(一)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;redis中共有8种数据结构，其中常用的有5种。这些数据结构基本采用了底层的8种数据结构实现。&lt;/p&gt;</summary>
    
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/categories/redis/"/>
    
    
    <category term="数据结构" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>信也科技（拍拍贷）一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E4%BF%A1%E4%B9%9F%E7%A7%91%E6%8A%80%EF%BC%88%E6%8B%8D%E6%8B%8D%E8%B4%B7%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E4%BF%A1%E4%B9%9F%E7%A7%91%E6%8A%80%EF%BC%88%E6%8B%8D%E6%8B%8D%E8%B4%B7%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-09T08:49:43.000Z</published>
    <updated>2021-07-25T09:15:06.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>项目介绍</li><li>业务介绍</li><li>dubbo服务调用流程</li><li>redis分布式锁实现</li><li>shiro<ol><li>shiro用到那些表</li><li>登录的实现原理</li></ol></li><li>小项目的介绍</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="dubbo服务调用流程"><a href="#dubbo服务调用流程" class="headerlink" title="dubbo服务调用流程"></a>dubbo服务调用流程</h2><p>&emsp;&emsp;<a href="../../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">dubbo服务调用过程</a><br>&emsp;&emsp;<a href="../../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%9A%B4%E9%9C%B2%E8%BF%87%E7%A8%8B">dubbo服务启动暴露过程</a><br>&emsp;&emsp;<a href="../../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5%E6%B5%81%E7%A8%8B">dubbo服务引入流程</a></p><h2 id="redis分布式锁实现"><a href="#redis分布式锁实现" class="headerlink" title="redis分布式锁实现"></a>redis分布式锁实现</h2><p>&emsp;&emsp;<a href="../../../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">redis分布式锁</a></p><h2 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h2><h3 id="shiro用到了那些表？"><a href="#shiro用到了那些表？" class="headerlink" title="shiro用到了那些表？"></a>shiro用到了那些表？</h3><p>&emsp;&emsp;shiro中将权限系统分为了用户，角色，权限三个维度。要使用到一些表：</p><ul><li>用户表</li><li>角色表</li><li>资源表（权限表）</li><li>用户角色关联表</li><li>角色权限关联表</li><li>用户登录信息表（自己扩展）</li></ul><p>&emsp;&emsp;通过这种方式可以比较精细的将权限控制到每个页面，每个按钮。</p><h3 id="登录的实现原理？"><a href="#登录的实现原理？" class="headerlink" title="登录的实现原理？"></a>登录的实现原理？</h3><p>&emsp;&emsp;配合shiro可以有多种实现原理。</p><ul><li>shiro+token+inteceptor</li><li>shiro+session</li></ul><p>&emsp;&emsp;还可以搭配其他的手段实现，jwt，oauth2等，都可以进行集成。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="answer" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/answer/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>光云科技一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%85%89%E4%BA%91%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%85%89%E4%BA%91%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-08T09:00:25.000Z</published>
    <updated>2021-07-21T05:42:06.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>集合Hashmap<ol><li>底层结构，版本</li><li>1.7与1.8的结构区别，其他区别</li></ol></li><li>ConcurrentHashmap与HashMap<ol><li>结构，区别</li><li>不同版本的区别</li></ol></li><li>CAS是什么？</li><li>常用的jvm虚拟机</li><li>jvm垃圾回收器<ol><li>有那些常用的垃圾回收器</li><li>CMS的垃圾回收过程</li></ol></li><li>单例模式<ol><li>有哪些写法</li><li>区别是什么</li><li>双检锁的优点？是完美的吗？</li></ol></li><li>数据库索引？（聚簇索引、非聚簇索引；hash索引、B+树索引）</li><li> B+树结构？</li><li>事务的隔离级别？作用？</li><li>MVCC<ol><li> MVCC原理</li><li> MVCC在不同的隔离级别的区别</li></ol></li><li>Spring<ol><li> 有什么特点，功能，ioc，aop，DI</li><li> xml配置如何转成Bean</li><li> Bean的实例化过程</li><li> 循环依赖</li></ol></li><li>redis<ol><li> 分布式锁怎么实现的</li><li> 有哪些数据结构</li></ol></li><li>rocketmq<ol><li> 消息消费失败怎么处理的（没处理，使用mq的原生的重发机制）（分为投递失败，业务处理失败）</li></ol></li><li>synchronized<ol><li> synchronized原理？</li><li> synchronized加在方法上和代码块上的区别？生成的指令的区别？</li></ol></li><li>反问</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="集合HashMap？"><a href="#集合HashMap？" class="headerlink" title="集合HashMap？"></a>集合HashMap？</h2><p>&emsp;&emsp;jdk1.8中hashmap底层采用<code>数组+链表+红黑树</code>的结构；jdk1.7中hashmap底层采用<code>数组+链表</code>的结构。采用链地址法解决hashmap中的hash冲突问题，当链表长度达到8时进化为红黑树，节点数小于等于6时退化为链表。<br>&emsp;&emsp;jdk1.7与jdk1.8中，数据结构发生了变化，链表的尾插法改成了头插法，尾插法在hashmap扩容时有可能造成死循环。</p><h2 id="ConcurrentHashmap与Hashmap？"><a href="#ConcurrentHashmap与Hashmap？" class="headerlink" title="ConcurrentHashmap与Hashmap？"></a>ConcurrentHashmap与Hashmap？</h2><p>&emsp;&emsp;ConcurrentHashmap是juc包中的类，是用于在多线程情况下的hashmap，解决了hashmap在多线程情况下并发不安全的问题。<br>&emsp;&emsp;ConcurrentHashmap在1.7和1.8中采用了不同的结构和加锁方式。<br>&emsp;&emsp;jdk1.7中采用了段（Segment）的设计，每一个段中都是一个Hashmap的结构，将很多个段组合起来就是ConcurrentHashmap的结构，1.7中保证并发安全采用了分段锁的机制，就是在段设计的基础上，对每一个段加悲观锁（syncronized）。<br>&emsp;&emsp;jdk1.8中ConcurrentHashmap的数据结构采用了和Hashmap相同的数据结构，通过使用CAS操作来保证并发下的安全性。</p><h2 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h2><p>&emsp;&emsp;CAS就是比较并交换，全称Compare And Set，是一种原子性修改内存数据的一种策略。<br>&emsp;&emsp;CAS操作过程是：会将内存中的数据与一个期望值进行比较，比较结果相等了，才会将内存中的值修改为要改成的值（一般在缓存）。<br>&emsp;&emsp;java中很多地方都用到了CAS，比如AQS中就是用CAS去修改值，ConcurrentHashmap中也用到了。</p><h2 id="常用的JVM虚拟机？"><a href="#常用的JVM虚拟机？" class="headerlink" title="常用的JVM虚拟机？"></a>常用的JVM虚拟机？</h2><p>&emsp;&emsp;主要jvm虚拟机是Hotspot虚拟机，IBM有一款J9 JVM。</p><h2 id="jvm的垃圾回收器？"><a href="#jvm的垃圾回收器？" class="headerlink" title="jvm的垃圾回收器？"></a>jvm的垃圾回收器？</h2><ul><li><a href="../../../md/jvm/JVM%E2%80%94GC">jvm的垃圾回收算法与垃圾回收器</a></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>&emsp;&emsp;单例模式共有8种写法。</p><ul><li>饿汉式-静态常量</li><li>饿汉式-静态代码块</li><li>懒汉式（默认线程不安全）</li><li>懒汉式-同步方法</li><li>懒汉式-同步代码块</li><li>双重检查锁</li><li>静态内部类</li><li>枚举</li></ul><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/aoz98d">mysql的索引</a></li></ul><h2 id="B-树结构？"><a href="#B-树结构？" class="headerlink" title="B+树结构？"></a>B+树结构？</h2><ul><li><a href="../../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B+%E6%A0%91">数据结构-B+树</a></li></ul><h2 id="事务的隔离级别？作用？"><a href="#事务的隔离级别？作用？" class="headerlink" title="事务的隔离级别？作用？"></a>事务的隔离级别？作用？</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/iarni8">事务的隔离级别</a></li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li><a href="../../../md/mysql/mysql%E4%B8%AD%E7%9A%84MVCC">mysql中的MVCC</a></li></ul><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring特点，功能"><a href="#Spring特点，功能" class="headerlink" title="Spring特点，功能"></a>Spring特点，功能</h3><ul><li>方便解耦，简化开发</li><li>支持AOP编程，很容易实现权限拦截，运行期监控</li><li>声明式事务支持，spring容器提供的功能</li><li>方便集成各种优秀框架</li><li>提供了众多工具类，简化API使用难度</li><li>的DI机制降低了业务对象替换的复杂性</li></ul><h3 id="XML配置如何转换为Bean"><a href="#XML配置如何转换为Bean" class="headerlink" title="XML配置如何转换为Bean"></a>XML配置如何转换为Bean</h3><ul><li><a href="https://blog.csdn.net/liu20111590/article/details/89857660">spring之xml文件转换为BeanDefinition</a></li></ul><h3 id="Bean的实例化过程"><a href="#Bean的实例化过程" class="headerlink" title="Bean的实例化过程"></a>Bean的实例化过程</h3><ul><li><a href="../../../md/spring/Spring%E4%B8%ADBean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B">Spring中Bean的实例化过程</a></li></ul><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/gmkoub">spring中循环依赖的处理</a></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="redis分布式锁是怎么实现的？"><a href="#redis分布式锁是怎么实现的？" class="headerlink" title="redis分布式锁是怎么实现的？"></a>redis分布式锁是怎么实现的？</h3><ul><li><a href="../../../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">redis分布式锁</a></li></ul><h3 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h3><p>&emsp;&emsp;redis中共有8种数据结构，其中常用的有5种。</p><ul><li><p>字符串 string</p></li><li><p>散列-hash</p></li><li><p>列表-list</p></li><li><p>集合-set</p></li><li><p>有序集合-zset</p></li><li><p>位图-bitmap</p></li><li><p>地理位置-geospatial</p></li><li><p>hyperloglog</p></li><li><p><a href="../../../md/redis/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">redis中的数据结构</a></p></li></ul><h2 id="Rocketmq"><a href="#Rocketmq" class="headerlink" title="Rocketmq"></a>Rocketmq</h2><h3 id="消息消费失败怎么处理？"><a href="#消息消费失败怎么处理？" class="headerlink" title="消息消费失败怎么处理？"></a>消息消费失败怎么处理？</h3><p>&emsp;&emsp;消息消费失败可以分为两种方向，一种是mq进行消息投递失败，另一种是业务系统消费消息失败。<br>&emsp;&emsp;mq消息投递失败会将消息放入定时投递队列中，按照一定的时间间隔后进行消息重投。<br>&emsp;&emsp;业务系统可以将消息存储起来，对于失败的消息，通过定时处理的方式进行恢复。保存起来类似于消息幂等的处理方式。</p><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><h3 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h3><p>&emsp;&emsp;底层采用monitor指令实现，会生成一条moniter enter和二条moniter exit（一条正常退出，另一条异常退出）指令实现。</p><h3 id="Synchronized加在方法上和代码块上的区别？生成的指令的区别？"><a href="#Synchronized加在方法上和代码块上的区别？生成的指令的区别？" class="headerlink" title="Synchronized加在方法上和代码块上的区别？生成的指令的区别？"></a>Synchronized加在方法上和代码块上的区别？生成的指令的区别？</h3><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/rc3ofp">synchronized</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="answer" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/answer/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq和kafka的区别</title>
    <link href="https://linqiankun.github.io/hexoblog/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq%E5%92%8Ckafka%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://linqiankun.github.io/hexoblog/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq%E5%92%8Ckafka%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-06T08:21:57.000Z</published>
    <updated>2021-07-06T11:25:36.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><span id="more"></span><hr><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="数据可靠性"><a href="#数据可靠性" class="headerlink" title="数据可靠性"></a>数据可靠性</h2><ul><li>RocketMQ支持异步实时刷盘，同步刷盘，同步Replication，异步Replication。</li><li>kafka使用异步刷盘模式，异步Replication。</li></ul><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><ul><li>kafka单机TPS约在百万条/秒，消息大小10个字节。</li><li>RocketMQ单机写入TPS单实例约7万条/秒，单机部署3个broker，最高可以跑到12万条/秒，消息大小10个字节。</li></ul><blockquote><p>kafka主要是由于Producer端将多个小消息合并，批量发向Broker。</p></blockquote><h2 id="单机支持的队列数"><a href="#单机支持的队列数" class="headerlink" title="单机支持的队列数"></a>单机支持的队列数</h2><ul><li>kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间边长。</li><li>RocketMQ单机最多支持5万个队列，load不会发生明显变化。</li></ul><h2 id="消息投递实时性"><a href="#消息投递实时性" class="headerlink" title="消息投递实时性"></a>消息投递实时性</h2><ul><li>kafka使用端轮询方式，实时性取决于轮询时间间隔。</li><li>RocketMQ使用长轮询，同Push方式实时性一致，消息的投递延时通常在几个毫秒。</li></ul><h2 id="消费失败重试"><a href="#消费失败重试" class="headerlink" title="消费失败重试"></a>消费失败重试</h2><ul><li>kafka消费失败不支持重试。</li><li>RocketMQ消费失败支持定时重试，每次重试时间间隔依次增大。</li></ul><h2 id="严格的消息顺序"><a href="#严格的消息顺序" class="headerlink" title="严格的消息顺序"></a>严格的消息顺序</h2><ul><li>kafka支持消息顺序，但是一台Broker宕机后，就会产生消息乱序。</li><li>RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机，发送消息会失败，但不会乱序。</li></ul><h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><ul><li>kafka不支持定时消息</li><li>RocketMQ支持定时消息<ul><li>支持定时level，以及指定毫秒级别的延时时间</li></ul></li></ul><h2 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h2><ul><li>kafka不支持分布式事务消息</li><li>RocketMQ支持分布式事务消息，采用半消息实现</li></ul><h2 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h2><ul><li>kafka不支持消息查询</li><li>RocketMQ支持根据Message Id查询消息，也支持根据消息内容查询消息</li></ul><h2 id="消息回溯"><a href="#消息回溯" class="headerlink" title="消息回溯"></a>消息回溯</h2><ul><li>kafka理论上可以按照Offset来回溯消息</li><li>rocketMQ支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息</li></ul><h2 id="消费并行度"><a href="#消费并行度" class="headerlink" title="消费并行度"></a>消费并行度</h2><ul><li>kafka消费的并行度依赖topic配置的分区数，消费并行度和分区数一致。</li><li>RocketMQ消费并行度分两种情况<ul><li>顺序消费方式并行度同Kafka完全一致</li><li>乱序方式并行度取决于Consumer的线程数，如Topic配置10个队列，10台机器消费，每台机器100个线程，那么并行度为1000。</li></ul></li></ul><h2 id="Broker端消息过滤"><a href="#Broker端消息过滤" class="headerlink" title="Broker端消息过滤"></a>Broker端消息过滤</h2><ul><li>kafka不支持broker端消息过滤</li><li>RocketMQ支持两种消息过滤方式<ul><li>根据tag来过滤，相当于子topic</li><li>向服务器上传一段Java代码，可以对消息做任意形式的过滤，甚至可以做Message Body的过滤拆分。</li></ul></li></ul><h2 id="使用区别"><a href="#使用区别" class="headerlink" title="使用区别"></a>使用区别</h2><ul><li>kafka在日志，大数据领域比较成熟</li><li>RocketMQ多用于削峰填谷，多用于业务领域。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    <category term="kafka" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/"/>
    
    
    <category term="消息中间件" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="https://linqiankun.github.io/hexoblog/tags/rocketmq/"/>
    
    <category term="kafka" scheme="https://linqiankun.github.io/hexoblog/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>网易一面（数据中台—java）</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E6%98%93%E4%B8%80%E9%9D%A2%EF%BC%88%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E2%80%94java%EF%BC%89/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E6%98%93%E4%B8%80%E9%9D%A2%EF%BC%88%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E2%80%94java%EF%BC%89/</id>
    <published>2021-07-03T11:55:15.000Z</published>
    <updated>2021-09-18T07:39:00.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>项目介绍</li><li>redis分布式锁怎么实现？</li><li>还有其他的实现思路？具体怎么实现？（数据库，zk）</li><li>redis分布式控制抢单，可不可以用数据库乐观锁？</li><li>数据库乐观锁怎么实现？</li><li>redis哨兵模式讲一下？</li><li>哨兵和机器间如何通信（ping，pong）?</li><li>哨兵如何选举leader?</li><li>mvcc讲一下？</li><li>mvcc的目的？原理？场景？</li><li>数据库隔离级别的作用？场景</li><li>redo log，undo log，bin log分别说一下？</li><li>这些是在什么阶段产生的？</li><li>mysql模块说一下？那些产生什么日志？</li><li>mysql索引讲一下？从你自己知道的角度讲？</li><li>聚簇索引和非聚簇索引的区别？</li><li>shiro讲一下？</li><li>shiro怎么存储session？</li><li>你们用shiro怎么存的（token）？</li><li>rocketmq和kafka的区别？</li><li>rocketmq怎么保证消息只会被一台机器消费？</li><li>jvm调优过没？</li><li>系统优化过没？</li><li>线程之间是如何通信的？</li><li>jvm垃圾回收器有哪些？</li><li>jvm垃圾回收算法有哪些？</li><li>多线程怎么通信的？</li><li>如何3个线程按照指定abc的顺序打印10000万次？</li><li>notify和notifyAll的区别？</li><li>可以指定某个线hex唤醒吗？</li><li>项目中有什么印象深刻的？（异步获取结果）</li><li>用过大数据方面的东西没？（没有）</li><li>最近有在看什么书？</li><li>有什么想了解的？</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="Redis分布式锁怎么实现？"><a href="#Redis分布式锁怎么实现？" class="headerlink" title="Redis分布式锁怎么实现？"></a>Redis分布式锁怎么实现？</h2><ul><li><a href="../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md">redis分布式锁</a></li></ul><h3 id="还有其他的实现思路？具体怎么实现？（数据库，zk）"><a href="#还有其他的实现思路？具体怎么实现？（数据库，zk）" class="headerlink" title="还有其他的实现思路？具体怎么实现？（数据库，zk）"></a>还有其他的实现思路？具体怎么实现？（数据库，zk）</h3><ul><li><a href="../md/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md">分布式锁</a></li><li><a href="../md/zookeeper/zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.md">zookeeper实现分布式锁</a></li></ul><h3 id="redis分布式控制抢单，可不可以用数据库乐观锁？"><a href="#redis分布式控制抢单，可不可以用数据库乐观锁？" class="headerlink" title="redis分布式控制抢单，可不可以用数据库乐观锁？"></a>redis分布式控制抢单，可不可以用数据库乐观锁？</h3><p>&emsp;&emsp;可以，效率并且比分布式锁搞，控制抢单行为本质上数据库的比较并修改操作。</p><h2 id="数据库乐观锁怎么实现？"><a href="#数据库乐观锁怎么实现？" class="headerlink" title="数据库乐观锁怎么实现？"></a>数据库乐观锁怎么实现？</h2><p>&emsp;&emsp;通过增加时间戳字段，或者增加版本号字段实现。在更新数据的时候进行对增加的时间戳字段或版本号字段进行比较，如果相同则进行更新，不同则不更新。一种更大范围的比较并交换思路。</p><h2 id="redis哨兵模式讲一下？"><a href="#redis哨兵模式讲一下？" class="headerlink" title="redis哨兵模式讲一下？"></a>redis哨兵模式讲一下？</h2><h2 id="哨兵和机器间如何通信（ping，pong）"><a href="#哨兵和机器间如何通信（ping，pong）" class="headerlink" title="哨兵和机器间如何通信（ping，pong）?"></a>哨兵和机器间如何通信（ping，pong）?</h2><h2 id="rocketmq和kafka的区别？"><a href="#rocketmq和kafka的区别？" class="headerlink" title="rocketmq和kafka的区别？"></a>rocketmq和kafka的区别？</h2><p>&emsp;&emsp;<a href="../../md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq%E5%92%8Ckafka%E7%9A%84%E5%8C%BA%E5%88%AB">rocketmq和kafka的区别</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>多线程之死锁</title>
    <link href="https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/"/>
    <id>https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/</id>
    <published>2021-07-02T07:46:24.000Z</published>
    <updated>2021-07-06T05:47:29.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;死锁是指两个或两个以上进程（在运行的过程中因争夺资源而造成的一种僵局），若无外力作用，这些线程，进程都将无法向前推进。</p><span id="more"></span><ul><li>参与死锁的进程（线程）至少为2个</li><li>参与死锁的进程（线程）均等待资源</li><li>参与死锁的进程（线程）至少有2个已经占有资源</li><li>死锁进程是系统中当前进程集合的一个子集</li><li>死锁会浪费大量系统资源，甚至导致系统崩溃</li></ul><hr><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>&emsp;&emsp;所有的死锁都是对资源的争夺造成的，资源是一切的罪魁祸首。</p><h2 id="永久资源与临时资源"><a href="#永久资源与临时资源" class="headerlink" title="永久资源与临时资源"></a>永久资源与临时资源</h2><h3 id="永久资源"><a href="#永久资源" class="headerlink" title="永久资源"></a>永久资源</h3><p>&emsp;&emsp;永久资源可以被多次使用，如所有硬件。</p><ul><li>只能分配给一个进程使用，不允许多个进程共享</li><li>进程使用时，需按照请求资源、使用资源、释放资源的顺序</li><li>这种资源的数量是固定的，运行期间，不能创建，也不能销毁</li></ul><h3 id="临时资源"><a href="#临时资源" class="headerlink" title="临时资源"></a>临时资源</h3><p>&emsp;&emsp;是在运行期间动态创建和销毁的资源。</p><ul><li>数量在运行期间是不断变化的，有可能为0</li><li>在运行过程中，可以不断的创建这种资源，将它们放入缓冲区，增加资源数量</li><li>也可以在运行过程中，请求几个临时资源，用于运行中的消耗</li></ul><p>&emsp;&emsp;一般由生产者进程产生，消费者进程消耗，如何用于通信的消息。</p><h2 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h2><h3 id="可抢占资源"><a href="#可抢占资源" class="headerlink" title="可抢占资源"></a>可抢占资源</h3><p>&emsp;&emsp;可抢占资源指某进程在获得这类资源后，该类资源可以被其他进程或系统抢占，也就是大家共享，这类资源不会引起死锁。比如CPU和内存。</p><h3 id="不可抢占资源"><a href="#不可抢占资源" class="headerlink" title="不可抢占资源"></a>不可抢占资源</h3><p>&emsp;&emsp;一旦系统将某资源分配给该进程后，就不能将其强行收回，只能在进程使用完后自己释放。比如打印机。</p><hr><h1 id="死锁原因"><a href="#死锁原因" class="headerlink" title="死锁原因"></a>死锁原因</h1><ul><li>竞争不可抢占资源引起死锁<blockquote><p>通常系统中的不可抢占资源，其数量不足以满足同时运行，使得在运行过程中，会因资源抢占而进入僵局，造成死锁。</p></blockquote></li><li>竞争可消耗资源引起死锁</li><li>进程推进顺序不当引起死锁<blockquote><p>运行过程中，请求和释放资源的顺序不科学，也会造成死锁，我等你，你等我的情况。<br>信号量使用不当也会死锁，进程间彼此相互等待对方发来的消息，结果也会使得这 些进程间无法继续向前推进。</p></blockquote></li></ul><hr><h1 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h1><h2 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h2><p>&emsp;&emsp;运行的进程对它所分配的资源进行排他性控制，在一段时间内某资源仅为一个进程所占用。此时若有其他进程线程来请求资源，则请求的进程线程只能等待。</p><h2 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h2><p>&emsp;&emsp;所获得的资源，已经占用的资源，不能被其他进程强行夺走，只能由自己主动释放。</p><h2 id="请求与保持"><a href="#请求与保持" class="headerlink" title="请求与保持"></a>请求与保持</h2><p>&emsp;&emsp;进程已经保持占用了至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程占有，此时进程请求被阻塞，但对自己已获得资源保持占用。</p><h2 id="循环等待"><a href="#循环等待" class="headerlink" title="循环等待"></a>循环等待</h2><p>&emsp;&emsp;存在进程资源间的循环等待链。</p><hr><h1 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h1><ul><li><strong>预防死锁</strong>：通过设置某些限制条件，去破坏产生死锁的四个条件的一个或几个。</li><li><strong>避免死锁</strong>：在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁发生。</li><li><strong>检测死锁</strong>：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。</li><li><strong>解除死锁</strong>：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。</li></ul><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>&emsp;&emsp;就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。<br>&emsp;&emsp;实际情况中，互斥条件一般不能也无法被破环，否则会造成结果不可再现。</p><h3 id="破环不可抢占条件"><a href="#破环不可抢占条件" class="headerlink" title="破环不可抢占条件"></a>破环不可抢占条件</h3><p>&emsp;&emsp;就是允许对资源实行抢夺。  </p><ul><li>如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。</li><li>如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。</li></ul><h3 id="破环请求与保持条件"><a href="#破环请求与保持条件" class="headerlink" title="破环请求与保持条件"></a>破环请求与保持条件</h3><p>&emsp;&emsp;就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。</p><ul><li>创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。这是所谓的 “ 一次性分配”方案。</li><li>要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。</li></ul><h3 id="破环循环等待条件"><a href="#破环循环等待条件" class="headerlink" title="破环循环等待条件"></a>破环循环等待条件</h3><p>&emsp;&emsp;破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。</p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>&emsp;&emsp;合理规划资源，在系统资源，进程调度等方面，设计让死锁条件无法满足，避免进程永久占据系统资源或在等待条件下占用资源，从而防止死锁。<br>&emsp;&emsp;预防死锁和避免死锁的区别：预防死锁是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现，而避免死锁则不那么严格的限制产生死锁的必要条件的存在。因为即使死锁的必要条件存在，也不一定发生死锁。避免死锁是在系统运行过程中注意避免死锁的最终发生。</p><h3 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h3><ul><li>有序资源分配法</li><li>银行家算法</li></ul><h3 id="避免死锁的技术"><a href="#避免死锁的技术" class="headerlink" title="避免死锁的技术"></a>避免死锁的技术</h3><ul><li>加锁顺序</li><li>加锁时限</li><li>死锁检测</li></ul><h2 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h2><p>&emsp;&emsp;死锁检测与恢复是指系统设有专门的机构，当死锁发生时，该机构能够检测到死锁发生的位置和原因，并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁状态中恢复出来。</p><h2 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h2><p>&emsp;&emsp;死锁解除的方法有：</p><ol><li><strong>资源剥夺法</strong>：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li><li><strong>撤销进程法</strong>：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li><li><strong>进程回退法</strong>：让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://blog.csdn.net/wljliujuan/article/details/79614019">死锁，死锁的四个必要条件以及处理策略</a></li><li><a href="https://blog.csdn.net/wangxj_2017/article/details/116447392">多线程的下的死锁问题排查</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;死锁是指两个或两个以上进程（在运行的过程中因争夺资源而造成的一种僵局），若无外力作用，这些线程，进程都将无法向前推进。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/categories/java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/tags/java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深圳雪球科技（NFC）二面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E6%B7%B1%E5%9C%B3%E9%9B%AA%E7%90%83%E7%A7%91%E6%8A%80%EF%BC%88NFC%EF%BC%89%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E6%B7%B1%E5%9C%B3%E9%9B%AA%E7%90%83%E7%A7%91%E6%8A%80%EF%BC%88NFC%EF%BC%89%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-02T03:16:49.000Z</published>
    <updated>2021-07-25T09:14:58.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>目前情况<ol><li>姓名等个人信息</li><li>在职状态</li><li>薪资</li></ol></li><li>项目介绍<ol><li>业务</li><li>技术栈</li><li>遇到问题</li><li>如何解决</li></ol></li><li>redis分布式锁实现</li><li>redis模板（jedis、redisTemplate）</li><li>多线程<ol><li> 多线程死锁怎么解决</li><li> DeadLock</li><li>多线程线程数量设计<ol><li> 慢IO</li><li> CPU密集</li></ol></li></ol></li><li>项目中的多线程代码是你写的吗</li><li>线程池原理</li><li>后面的规划（技术，管理）</li><li>基建怎么建设（自建机房，阿里云）</li><li>发布流程（有发布系统，用jekins）</li><li>容器化<ol><li> 有没有容器化</li><li> k8s</li><li> docker使用</li><li> 目前是本地虚拟机没有容器化</li></ol></li><li>抗压能力，加班情况</li><li>为什么换工作</li><li>换工作选择什么行业</li></ol><p><img src="https://raw.githubusercontent.com/LinQiankun/picurl/main/java%E5%86%99%E9%9D%A2%E7%BB%8F%EF%BC%8C%E6%94%92%E4%BA%BA%E5%93%81_00.jpg" alt="写面经，攒人品"></p><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="redis分布式锁技术？"><a href="#redis分布式锁技术？" class="headerlink" title="redis分布式锁技术？"></a>redis分布式锁技术？</h2><ul><li><a href="../../../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">redis分布式锁</a></li></ul><h2 id="redis模板？"><a href="#redis模板？" class="headerlink" title="redis模板？"></a>redis模板？</h2><p>&emsp;&emsp;redis用的到模板有jedis，redisTemplate</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程死锁怎么解决？"><a href="#多线程死锁怎么解决？" class="headerlink" title="多线程死锁怎么解决？"></a>多线程死锁怎么解决？</h3><ul><li><a href="../../../md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81">多线程之死锁</a></li></ul><h3 id="多线程线程数量设计？"><a href="#多线程线程数量设计？" class="headerlink" title="多线程线程数量设计？"></a>多线程线程数量设计？</h3><p>&emsp;&emsp;线程池中，线程数量的设计一般分成两大类，IO密集型和CPU密集型。</p><ul><li>IO密集型：CPU*2+1</li><li>CPU密集型：CPU+1</li></ul><p>&emsp;&emsp;实际使用中，则需要在此基础上不断的进行测试，不断地进行优化，直到找到合适的线程数量为止。</p><h2 id="线程池原理？"><a href="#线程池原理？" class="headerlink" title="线程池原理？"></a>线程池原理？</h2><ul><li><a href="../../../md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/threadpool">threadpool</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="answer" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/answer/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>MQ消息幂等</title>
    <link href="https://linqiankun.github.io/hexoblog/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/MQ%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89/"/>
    <id>https://linqiankun.github.io/hexoblog/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/MQ%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89/</id>
    <published>2021-07-01T06:47:42.000Z</published>
    <updated>2021-07-01T08:08:12.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;MQ中的消息可靠性主要靠两个方面实现：</p><ol><li>消息落地</li><li>消息超时，重传，确认</li></ol><span id="more"></span><p>&emsp;&emsp;整个消息体系由<strong>发送端、服务端、存储设施、接收端</strong>四块结构构成。<br>&emsp;&emsp;为保证消息的可达性，超时、重传、确认机制可能导致消息总线、或者业务方 收到重复的消息，从而对业务产生影响。</p><p>&emsp;&emsp;<a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E7%9A%84%E5%AE%9E%E7%8E%B0">幂等介绍</a></p><hr><h1 id="上半场幂等设计"><a href="#上半场幂等设计" class="headerlink" title="上半场幂等设计"></a>上半场幂等设计</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/mq%E4%B8%8A%E5%8D%8A%E5%9C%BA.png" alt="mq结构"></p><p>&emsp;&emsp;消息发送的上半场就是图中的1、2、3过程，表示了消息的发送，保存过程。<br>&emsp;&emsp;如果3丢失，发送端MQ-client超时后会重发消息，可能导致服务端MQ-server收到重复消息。</p><blockquote><p>这里的重新发送方是Client，而不是实际的业务发送方。</p></blockquote><p>&emsp;&emsp;此时重发是MQ-client发起的，消息的处理是MQ-server，为了避免步骤2落地重复的消息，对每条消息， MQ系统内部必须生成一个msgId，作为去重和幂等的依据。<br>&emsp;&emsp;这个msgId的规则必须是：</p><ol><li><p>全局唯一</p></li><li><p>MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽</p><p>&emsp;&emsp;有了这个msgId，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等。<br>&emsp;&emsp;而业务方收到发送失败而重新发送的消息，对mq而言，会被认为是不同的消息（一条新的消息），只是这条重新发送的消息和上一条内容一样而已，这条重新发送的消息，会生成新的msgId。</p></li></ol><hr><h1 id="下半场幂等设计"><a href="#下半场幂等设计" class="headerlink" title="下半场幂等设计"></a>下半场幂等设计</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/mq%E4%B8%8A%E5%8D%8A%E5%9C%BA.png" alt="mq结构"></p><p>&emsp;&emsp;消息消费的下半场就是图中的4、5、6过程，表示消息的投递，消费过程。<br>&emsp;&emsp;接收端MQ-client回ACK给服务端MQ-server，是消息消费业务方的主动调用行为，不能由MQ-client自动发起，因为MQ系统不知道消费方什么时候真正消费成功。<br>&emsp;&emsp;如果5丢失，服务端MQ-server超时后会重发消息，可能导致MQ-client收到重复的消息，这样有可能造成重复消费。<br>&emsp;&emsp;此时重发是MQ-server发起的，消息的处理是消息消费业务方，消息重发势必导致业务方重复消费，为了保证业务幂等性 ，业务消息体中，必须有一个biz-id，作为去重和幂等的依据。<br>&emsp;&emsp;这个biz-id的规则是：</p><ol><li>对于同一个业务场景，全局唯一</li><li>由业务消息发送方生成，业务相关，对MQ透明</li><li>由业务消息消费方负责判重，以保证幂等</li></ol><p>&emsp;&emsp;有了这个业务ID，才能够保证下半场消息消费业务方即使收到重复消息，也只有1条消息被消费，保证了幂等。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="上半场"><a href="#上半场" class="headerlink" title="上半场"></a>上半场</h2><p>&emsp;&emsp;MQ-client生成inner-msg-id，保证上半场幂等。<br>&emsp;&emsp;这个ID全局唯一，业务无关，由MQ保证。</p><h2 id="下半场"><a href="#下半场" class="headerlink" title="下半场"></a>下半场</h2><p>&emsp;&emsp;业务 发送方带入biz-id，业务 接收方去重保证幂等。<br>&emsp;&emsp;这个ID对单业务唯一，业务相关，对MQ透明。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>&emsp;&emsp;幂等性，不仅对MQ有要求，对业务上下游也有要求。<br>&emsp;&emsp;实际上，MQ只实现了自己内部的幂等性，对于业务的幂等性，消息重投之类的，MQ并没有做处理，业务的幂等性，需要自己手动实现。</p><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/chx9832/p/12325871.html">RocketMQ解决幂等性问题</a></li><li><a href="https://blog.csdn.net/gwd1154978352/article/details/80655338">RocketMQ——消息幂等问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;MQ中的消息可靠性主要靠两个方面实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息落地&lt;/li&gt;
&lt;li&gt;消息超时，重传，确认&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="https://linqiankun.github.io/hexoblog/tags/rocketmq/"/>
    
    <category term="幂等" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%B9%82%E7%AD%89/"/>
    
  </entry>
  
</feed>
