<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Study</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="https://linqiankun.github.io/hexoblog/atom.xml" rel="self"/>
  
  <link href="https://linqiankun.github.io/hexoblog/"/>
  <updated>2021-07-20T12:25:16.370Z</updated>
  <id>https://linqiankun.github.io/hexoblog/</id>
  
  <author>
    <name>linqiankun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TODO</title>
    <link href="https://linqiankun.github.io/hexoblog/TODO/"/>
    <id>https://linqiankun.github.io/hexoblog/TODO/</id>
    <published>2022-12-31T15:59:59.000Z</published>
    <updated>2021-07-20T12:25:16.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><span id="more"></span><h2 id="QUEST-TODO"><a href="#QUEST-TODO" class="headerlink" title="QUEST_TODO"></a>QUEST_TODO</h2><ul><li><input disabled="" type="checkbox"> zk同时接收到创建节点请求</li><li><input disabled="" type="checkbox"> mysql分库分表</li></ul><h2 id="POSTS-TODO"><a href="#POSTS-TODO" class="headerlink" title="POSTS_TODO"></a>POSTS_TODO</h2><ul><li><input disabled="" type="checkbox"> rocketmq负载均衡代码</li><li><input disabled="" type="checkbox"> rocketmq消息可靠性消费重试代码</li><li><input disabled="" type="checkbox"> jekins安装和使用<ul><li><input disabled="" type="checkbox"> jekins安装过程</li><li><input disabled="" type="checkbox"> jekins基本使用</li></ul></li><li><input disabled="" type="checkbox"> B+树</li><li><input disabled="" type="checkbox"> deepin安装docker</li><li><input disabled="" type="checkbox"> jvm命令</li><li><input disabled="" type="checkbox"> jvm调优</li><li><input disabled="" type="checkbox"> SpringBean的初始化过程</li><li><input disabled="" type="checkbox"> SpringBean的生命周期</li><li><input disabled="" type="checkbox"> redis底层的8种数据结构</li></ul><h2 id="面经-TODO"><a href="#面经-TODO" class="headerlink" title="面经_TODO"></a>面经_TODO</h2><ul><li><input disabled="" type="checkbox"> 雪球科技一面面经</li><li><input disabled="" type="checkbox"> 雪球科技二面面经</li><li><input disabled="" type="checkbox"> 网易一面面经</li><li><input disabled="" type="checkbox"> 信也科技一面面经</li><li><input disabled="" type="checkbox"> 禾连科技一面面经</li><li><input disabled="" type="checkbox"> 海康威视一面面经</li><li><input disabled="" type="checkbox"> 同花顺一面面经</li><li><input disabled="" type="checkbox"> 大华一面面经</li></ul><h2 id="DRAFTS-TODO"><a href="#DRAFTS-TODO" class="headerlink" title="DRAFTS_TODO"></a>DRAFTS_TODO</h2><ul><li><input disabled="" type="checkbox"> AIO</li><li><input disabled="" type="checkbox"> kafka简介</li><li><input disabled="" type="checkbox"> rocketmq-Broker启动流程</li></ul><h2 id="OTHER-TODO"><a href="#OTHER-TODO" class="headerlink" title="OTHER_TODO"></a>OTHER_TODO</h2><ul><li><input disabled="" type="checkbox"> shiro</li><li><input disabled="" type="checkbox"> mq消费失败处理</li><li><input disabled="" type="checkbox"> 单例模式</li><li><input disabled="" type="checkbox"> 腾讯烧香问题</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h1&gt;</summary>
    
    
    
    <category term="todo" scheme="https://linqiankun.github.io/hexoblog/categories/todo/"/>
    
    
    <category term="todo" scheme="https://linqiankun.github.io/hexoblog/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>外包公司大汇总</title>
    <link href="https://linqiankun.github.io/hexoblog/%E5%A4%96%E5%8C%85%E5%85%AC%E5%8F%B8%E5%A4%A7%E6%B1%87%E6%80%BB/"/>
    <id>https://linqiankun.github.io/hexoblog/%E5%A4%96%E5%8C%85%E5%85%AC%E5%8F%B8%E5%A4%A7%E6%B1%87%E6%80%BB/</id>
    <published>2022-12-31T15:59:58.000Z</published>
    <updated>2021-07-12T11:38:30.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="外包公司汇总"><a href="#外包公司汇总" class="headerlink" title="外包公司汇总"></a>外包公司汇总</h1><span id="more"></span><ol><li>德科（华为）</li><li>捷程易信（网易）</li><li>恒生（阿里）</li><li><em>乌鸠科技</em>（阿里）</li><li><em>端点</em>（阿里）</li><li>博彦科技</li><li>科蓝软件</li><li>奥解思</li><li>法本</li><li>广讯通信</li><li>京北方</li><li>汉克时代</li><li>华钦软件CLPS</li><li>长亮科技（银行）</li><li>信雅达科技</li><li>网达软件（咪咕）</li><li>神州信息（银行）</li><li>宇信科技（银行）</li><li>宁波易简电子科技（银行）</li><li>安硕信息技术</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;外包公司汇总&quot;&gt;&lt;a href=&quot;#外包公司汇总&quot; class=&quot;headerlink&quot; title=&quot;外包公司汇总&quot;&gt;&lt;/a&gt;外包公司汇总&lt;/h1&gt;</summary>
    
    
    
    <category term="todo" scheme="https://linqiankun.github.io/hexoblog/categories/todo/"/>
    
    
    <category term="todo" scheme="https://linqiankun.github.io/hexoblog/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>大华一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%A4%A7%E5%8D%8E%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%A4%A7%E5%8D%8E%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-21T01:52:29.000Z</published>
    <updated>2021-07-21T05:40:51.968Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>jvm类的加载过程？</li><li>dubbo如何做选举的？</li><li>了解的设计模式，spring用的设计模式？</li><li>还了解那些设计模式？</li><li>springboot里面的listener？</li><li>代理模式与AOP？</li><li>redis主从复制与哨兵模式？</li><li>分布式事务实现？</li><li>syncnorized和ReentrantLock的区别？</li><li>反问</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="jvm类的加载过程"><a href="#jvm类的加载过程" class="headerlink" title="jvm类的加载过程"></a>jvm类的加载过程</h2><ul><li><a href="../../../md/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">类加载机制</a>  </li><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/dvd9gz">类加载机制</a></li></ul><h2 id="dubbo如何做选举的"><a href="#dubbo如何做选举的" class="headerlink" title="dubbo如何做选举的"></a>dubbo如何做选举的</h2><p>&emsp;&emsp;这里的选举并不是zk的选举，而是服务消费方获取到提供方节点后，根据负载均衡算法选择某台机器进行远程调用。常见的负载均衡算法有：  </p><ul><li>轮询</li><li>随机</li><li>一致性Hash</li></ul><h2 id="spring用到的设计模式？"><a href="#spring用到的设计模式？" class="headerlink" title="spring用到的设计模式？"></a>spring用到的设计模式？</h2><ul><li>单例模式</li><li>工厂模式</li><li>代理模式</li><li>等</li></ul><h2 id="还了解那些设计模式？"><a href="#还了解那些设计模式？" class="headerlink" title="还了解那些设计模式？"></a>还了解那些设计模式？</h2><ul><li>模板方法模式</li><li>建造者模式</li><li>策略模式</li></ul><h2 id="springboot里面的listener？"><a href="#springboot里面的listener？" class="headerlink" title="springboot里面的listener？"></a>springboot里面的listener？</h2><h2 id="代理模式与AOP？"><a href="#代理模式与AOP？" class="headerlink" title="代理模式与AOP？"></a>代理模式与AOP？</h2><p>&emsp;&emsp;代理模式分为静态代理，动态代理，动态代理又可分为很多种，jdk，cglib等。<br>&emsp;&emsp;AOP是面向切面编程，其中用到了动态代理。</p><h2 id="redis主从复制与哨兵模式？"><a href="#redis主从复制与哨兵模式？" class="headerlink" title="redis主从复制与哨兵模式？"></a>redis主从复制与哨兵模式？</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/haaf3c">redis的高可用方案</a></li></ul><h2 id="分布式事务的实现"><a href="#分布式事务的实现" class="headerlink" title="分布式事务的实现"></a>分布式事务的实现</h2><ul><li><a href="../../../md/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">分布式事务</a>  </li><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/fwl3rv">分布式事务</a></li></ul><h2 id="syncnorized和ReentrantLock的区别？"><a href="#syncnorized和ReentrantLock的区别？" class="headerlink" title="syncnorized和ReentrantLock的区别？"></a>syncnorized和ReentrantLock的区别？</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/rc3ofp">syncnorized</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>同花顺一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E5%90%8C%E8%8A%B1%E9%A1%BA%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E5%90%8C%E8%8A%B1%E9%A1%BA%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-21T01:49:24.000Z</published>
    <updated>2021-07-21T03:31:43.045Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>jvm<ol><li>堆内存溢出<ol><li>怎么快速的堆内存溢出</li><li>溢出怎么防止</li><li>为什么会堆内存溢出</li><li>不段创建String对象，和不断创建线程造成溢出的区别？</li><li>怎么分析，dump内存文件</li><li>分析hprof文件，有那些内容</li></ol></li><li>栈指针溢出<ol><li>怎么快速的栈指针溢出</li><li>怎么防止</li><li>为什么会栈指针溢出</li></ol></li><li>垃圾回收器<ol><li>你们用的垃圾回收器</li><li>你知道的垃圾回收器</li><li>讲一讲过程，区别（CMS，G1）</li></ol></li></ol></li><li>redis分布式锁实现</li><li>mysql索引，为什么需要索引，自己的理解</li><li>你们数据量级，一次处理的数据量</li><li>线程池，几个核心参数的作用，不背原理</li><li>hashmap和hashtable的区别</li><li>dubbo如何实现高可用的</li><li>反问</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>禾连科技一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E7%A6%BE%E8%BF%9E%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E7%A6%BE%E8%BF%9E%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-15T11:38:41.000Z</published>
    <updated>2021-07-15T11:51:25.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>项目介绍</li><li>用到那些jdk版本？</li><li>1.8有哪些新特性？</li><li>Stream API用到那些方法？</li><li>Stream API并行情况？</li><li>用到那些集合？</li><li>用到那些线程安全的集合？</li><li>threadlocal用在什么场景？</li><li>threadlocal结构？</li><li>子线程能否拿到主线程threadlocal的内容？怎么拿？</li><li>为什么用dubbo？</li><li>dubbo用什么做注册中心？</li><li>还有那些注册中心？</li><li>dubbo启动扫描服务的过程？</li><li>同一个dubbo服务，不同的用户要使用，dubbo怎么做用户区分？</li><li>索引失效的情况？</li><li>like对字段后半截查询（前半截模糊，后半截精确），如何优化？</li><li>为什么有young gc和old gc？</li><li>标记清除算法用在那个阶段？</li><li>反射有那些方法得到一个类？</li><li>Class.forName和ClassLoader.loadclass的区别？</li><li>为什么要用Class.forName？使用场景？</li><li>为什么用rocketmq？</li><li>rocketmq用在什么场景？</li><li>分布式锁怎么实现的？为什么没有用成熟的解决方案？</li><li>反问</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>redis底层采用的数据结构</title>
    <link href="https://linqiankun.github.io/hexoblog/md/redis/redis%E5%BA%95%E5%B1%82%E9%87%87%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://linqiankun.github.io/hexoblog/md/redis/redis%E5%BA%95%E5%B1%82%E9%87%87%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-07-15T10:03:30.000Z</published>
    <updated>2021-07-16T08:53:56.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/categories/redis/"/>
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>spring中bean的生命周期</title>
    <link href="https://linqiankun.github.io/hexoblog/md/spring/spring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://linqiankun.github.io/hexoblog/md/spring/spring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2021-07-14T08:01:10.000Z</published>
    <updated>2021-07-16T08:48:10.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;Spring中Bean的生命周期，大概可以分为四个阶段和多个扩展点：</p><ol><li>实例化</li><li>属性注入</li><li>初始化</li><li>销毁</li></ol><div id="flowchart-0" class="flow-chart"></div><span id="more"></span><hr><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>&emsp;&emsp;生命周期的的主要过程都在doCreate()方法中，在其中顺序的调用实例化，属性赋值，初始化方法。</p><ol><li>createBeanInstance() -&gt; 实例化</li><li>populateBean() -&gt; 属性赋值</li><li>initializeBean() -&gt; 初始化</li></ol><p>&emsp;&emsp;销毁则在容器关闭时调用，详见<code>ConfigurableApplicationContext#close()</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 忽略了无关代码</span><span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">doCreateBean</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">RootBeanDefinition</span> mbd<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>      <span class="token keyword">throws</span> <span class="token class-name">BeanCreationException</span> <span class="token punctuation">&#123;</span>   <span class="token comment">// Instantiate the bean.</span>   <span class="token class-name">BeanWrapper</span> instanceWrapper <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 实例化阶段！</span>      instanceWrapper <span class="token operator">=</span> <span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token comment">// Initialize the bean instance.</span>   <span class="token class-name">Object</span> exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>   <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>       <span class="token comment">// 属性赋值阶段！</span>      <span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// 初始化阶段！</span>      exposedObject <span class="token operator">=</span> <span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.jianshu.com/p/1dec08d290c1">请别再问Spring Bean的生命周期了！</a><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">op1=>operation: 实例化op2=>operation: 属性注入op3=>operation: 初始化op4=>operation: 销毁op1(right)->op2op2(right)->op3op3(right)->op4</textarea><textarea id="flowchart-0-options" style="display: none">{"theme":"simple","scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Spring中Bean的生命周期，大概可以分为四个阶段和多个扩展点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实例化&lt;/li&gt;
&lt;li&gt;属性注入&lt;/li&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;li&gt;销毁&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&quot;flowchart-0&quot; class=&quot;flow-chart&quot;&gt;&lt;/div&gt;</summary>
    
    
    
    <category term="spring" scheme="https://linqiankun.github.io/hexoblog/categories/spring/"/>
    
    
    <category term="spring" scheme="https://linqiankun.github.io/hexoblog/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring中Bean的实例化过程</title>
    <link href="https://linqiankun.github.io/hexoblog/md/spring/Spring%E4%B8%ADBean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <id>https://linqiankun.github.io/hexoblog/md/spring/Spring%E4%B8%ADBean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</id>
    <published>2021-07-14T06:57:04.000Z</published>
    <updated>2021-07-14T11:26:10.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;简要说明Spring什么时候实例化bean。</p><span id="more"></span><hr><h1 id="实例化时间"><a href="#实例化时间" class="headerlink" title="实例化时间"></a>实例化时间</h1><p>&emsp;&emsp;如果你使用BeanFactory作为Spring Bean的工厂类，则所有的bean都是在第一次使用该bean的时候实例化。<br>&emsp;&emsp;如果使用ApplicationContext作为工厂类，则可以分为：</p><ol><li>如果bean的scope是singleton的，并且lazy-init为false（默认是false，所以可以不用设置），则 ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中，下次再使用该Bean的时候， 直接从这个缓存中取。</li><li>如果bean的scope是singleton的，并且lazy-init为true，则该Bean的实例化是在第一次使用该Bean的时候进行实例化。</li><li>如果bean的scope是prototype的，则该Bean的实例化是在第一次使用该Bean的时候进行实例化。</li></ol><hr><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/springbean%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.jpg" alt="bean的实例化过程"></p><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://blog.csdn.net/mawming/article/details/52287786">spring装配Bean过程以及Bean实例化过程</a></li><li><a href="https://www.cnblogs.com/kevin-yuan/p/12157017.html">Spring Bean 的实例化过程</a></li><li><a href="https://blog.csdn.net/shuangyue/article/details/8585736">Spring Bean实例化过程（2）</a></li><li><a href="https://www.jianshu.com/p/1d0fb520e5c0">spring之Bean实例化过程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;简要说明Spring什么时候实例化bean。&lt;/p&gt;</summary>
    
    
    
    <category term="spring" scheme="https://linqiankun.github.io/hexoblog/categories/spring/"/>
    
    
    <category term="spring" scheme="https://linqiankun.github.io/hexoblog/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>redis中的数据结构</title>
    <link href="https://linqiankun.github.io/hexoblog/md/redis/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://linqiankun.github.io/hexoblog/md/redis/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2021-07-14T06:53:44.000Z</published>
    <updated>2021-07-15T10:04:09.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;redis中共有8种数据结构，其中常用的有5种。这些数据结构基本采用了底层的8种数据结构实现。</p><span id="more"></span><h2 id="常用的5种数据结构"><a href="#常用的5种数据结构" class="headerlink" title="常用的5种数据结构"></a>常用的5种数据结构</h2><ul><li>String（字符串）</li><li>Hash（哈希）</li><li>List（链表）</li><li>Set（集合）</li><li>ZSet（有序集合）</li></ul><h2 id="不常用的3种数据结构"><a href="#不常用的3种数据结构" class="headerlink" title="不常用的3种数据结构"></a>不常用的3种数据结构</h2><ul><li>geospatial（地理位置）</li><li>hyperloglog</li><li>Bitmap（位图）</li></ul><h2 id="底层使用的数据结构"><a href="#底层使用的数据结构" class="headerlink" title="底层使用的数据结构"></a>底层使用的数据结构</h2><ul><li>SDS：简单动态字符串，支持动态扩容的字节数组</li><li>list：链表</li><li>dict：使用双哈希表实现的, 支持平滑扩容的字典</li><li>zskiplist：附加了后向指针的跳跃表</li><li>intset：用于存储整数数值集合的自有结构</li><li>ziplist：压缩列表，一种实现上类似于TLV，但比TLV复杂的, 用于存储任意数据的有序序列的数据结构</li><li>quicklist：一种以ziplist作为结点的双链表结构, 实现的非常不错 </li><li>zipmap：一种用于在小规模场合使用的轻量级字典结构</li></ul><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/redis%E7%9A%84%C2%B7%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="redis的五种常用的数据结构"></p><hr><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>&emsp;&emsp;String是redis中最基础的数据类型，普通的kay/value都可以归为此类，value也可以是数字。<br>&emsp;&emsp;redis的String是二进制安全的，可以包含任何数据，如字符串，图片，序列化数据。<br>&emsp;&emsp;使用get、set、del、incr、decr等命令。<br>&emsp;&emsp;String底层采用SDS实现。  </p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>redis为字符串分配空间的次数，是小于等于字符串的长度N，而原C语言中的分配原则必为N。降低了分配次数提高了追加速度，代价就是多占用一些内存空间，且这些空间不会自动释放。</li><li>二进制安全的。</li><li>高效的计算字符串长度。</li><li>高效的追加字符串操作。</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>缓存：经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</li><li>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</li><li>session：常见方案spring session + redis实现session共享。</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>&emsp;&emsp;Lists就是链表，在redis中的List是一个双端链表，是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。<br>&emsp;&emsp;在3.2版本之前，redis中采用ziplist和linkedlist实现，在3.2版本之后采用quicklist实现。<br>&emsp;&emsp;3.2版本之前，列表对象满足如下条件时采用ziplist，否则采用linkedlist。</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节</li><li>列表对象保存的元素数量小于512个</li></ul><h3 id="使用特点"><a href="#使用特点" class="headerlink" title="使用特点"></a>使用特点</h3><ul><li>lpush+lpop=Stack(栈)</li><li>lpush+rpop=Queue（队列）</li><li>lpush+ltrim=Capped Collection（有限集合）</li><li>lpush+brpop=Message Queue（消息队列）</li></ul><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul><li>timeline：时间轴，按时间的顺序。</li><li>消息队列。</li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>&emsp;&emsp;redis的散列可以存储多个键值对之间的映射，散列存储的值既可以是字符串也可以是数字值，并且用户同样可以对散列存储的数字值执行自增操作或者自减操作。散列可以看作是一个文档或关系数据库里的一行。<br>&emsp;&emsp;使用所有hash的命令都是h开头的hget、hset、hdel等。<br>&emsp;&emsp;底层有两种数据结构实现：</p><ul><li>一种是ziplist，当存储的数据超过配置的阀值时就是转用hashtable的结构。使用ziplist的条件是：<ul><li>当键的个数小于hash-max-ziplist-entries（默认512）</li><li>当所有值都小于hash-max-ziplist-value（默认64）</li></ul></li><li>另一种就是hashtable。这种结构的时间复杂度为O(1)，但是会消耗比较多的内存空间。</li></ul><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><ul><li>缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>&emsp;&emsp;集合类型也是用来保存多个字符串的元素。<br>&emsp;&emsp;与列表的不同之处：</p><ul><li>不允许有重复的元素</li><li>集合中的元素是无序的，不能通过索引下标获取元素</li><li>支持集合间的操作，可以取多个集合取交集、并集、差集</li></ul><p>&emsp;&emsp;集合采用HashTable来实现元素不可重复。在hashtable中将set的值作为hashtable的键，而值则为空。<br>&emsp;&emsp;使用命令都是以s开头的sset、srem、scard、smembers、sismember。</p><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><ul><li>标签：给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。</li><li>点赞，或点踩，收藏等，可以放到set中实现。</li></ul><h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p>&emsp;&emsp;有序集合和散列一样，都用于存储键值对：有序集合的键被称为成员（member),每个成员都是各不相同的。有序集合的值则被称为分值（score），分值必须为浮点数，有序集合中根据分数进行排序。<br>&emsp;&emsp;有序集合是redis里面唯一一个既可以根据成员访问元素(这一点和散列一样)，又可以根据分值以及分值的排列顺序访问元素的结构。<br>&emsp;&emsp;使用有序集合的命令都是以z开头zadd、zrange、zscore。<br>&emsp;&emsp;底层有两种数据结构实现：</p><ul><li>第一种是压缩列表，ziplist</li><li>第二种是skiplist和dict的结合</li></ul><h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><ul><li>排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。</li></ul><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/haoprogrammer/p/11065461.html">Redis(一)、Redis五种数据结构</a></li><li><a href="https://blog.csdn.net/xpsallwell/article/details/84030285">redis的五种数据结构原理分析</a></li><li><a href="https://www.cnblogs.com/cnki/p/6113109.html">Redis实战（2）Redis八种数据结构（Windows Server）</a></li><li><a href="https://www.cnblogs.com/knowledgesea/p/4970026.html">Redis数据结构详解(一)</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;redis中共有8种数据结构，其中常用的有5种。这些数据结构基本采用了底层的8种数据结构实现。&lt;/p&gt;</summary>
    
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/categories/redis/"/>
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>信也科技（拍拍贷）一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E4%BF%A1%E4%B9%9F%E7%A7%91%E6%8A%80%EF%BC%88%E6%8B%8D%E6%8B%8D%E8%B4%B7%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E4%BF%A1%E4%B9%9F%E7%A7%91%E6%8A%80%EF%BC%88%E6%8B%8D%E6%8B%8D%E8%B4%B7%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-09T08:49:43.000Z</published>
    <updated>2021-07-12T08:09:35.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>项目介绍</li><li>业务介绍</li><li>dubbo服务调用流程</li><li>redis分布式锁实现</li><li>shiro<ol><li>shiro用到那些表</li><li>登录的实现原理</li></ol></li><li>小项目的介绍</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="dubbo服务调用流程"><a href="#dubbo服务调用流程" class="headerlink" title="dubbo服务调用流程"></a>dubbo服务调用流程</h2><p>&emsp;&emsp;<a href="../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">dubbo服务调用过程</a><br>&emsp;&emsp;<a href="../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%9A%B4%E9%9C%B2%E8%BF%87%E7%A8%8B">dubbo服务启动暴露过程</a><br>&emsp;&emsp;<a href="../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5%E6%B5%81%E7%A8%8B">dubbo服务引入流程</a></p><h2 id="redis分布式锁实现"><a href="#redis分布式锁实现" class="headerlink" title="redis分布式锁实现"></a>redis分布式锁实现</h2><p>&emsp;&emsp;<a href="../../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">redis分布式锁</a></p><h2 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>光云科技一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%85%89%E4%BA%91%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E5%85%89%E4%BA%91%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-08T09:00:25.000Z</published>
    <updated>2021-07-21T05:42:06.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>集合Hashmap<ol><li>底层结构，版本</li><li>1.7与1.8的结构区别，其他区别</li></ol></li><li>ConcurrentHashmap与HashMap<ol><li>结构，区别</li><li>不同版本的区别</li></ol></li><li>CAS是什么？</li><li>常用的jvm虚拟机</li><li>jvm垃圾回收器<ol><li>有那些常用的垃圾回收器</li><li>CMS的垃圾回收过程</li></ol></li><li>单例模式<ol><li>有哪些写法</li><li>区别是什么</li><li>双检锁的优点？是完美的吗？</li></ol></li><li>数据库索引？（聚簇索引、非聚簇索引；hash索引、B+树索引）</li><li> B+树结构？</li><li>事务的隔离级别？作用？</li><li>MVCC<ol><li> MVCC原理</li><li> MVCC在不同的隔离级别的区别</li></ol></li><li>Spring<ol><li> 有什么特点，功能，ioc，aop，DI</li><li> xml配置如何转成Bean</li><li> Bean的实例化过程</li><li> 循环依赖</li></ol></li><li>redis<ol><li> 分布式锁怎么实现的</li><li> 有哪些数据结构</li></ol></li><li>rocketmq<ol><li> 消息消费失败怎么处理的（没处理，使用mq的原生的重发机制）（分为投递失败，业务处理失败）</li></ol></li><li>synchronized<ol><li> synchronized原理？</li><li> synchronized加在方法上和代码块上的区别？生成的指令的区别？</li></ol></li><li>反问</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="集合HashMap？"><a href="#集合HashMap？" class="headerlink" title="集合HashMap？"></a>集合HashMap？</h2><p>&emsp;&emsp;jdk1.8中hashmap底层采用<code>数组+链表+红黑树</code>的结构；jdk1.7中hashmap底层采用<code>数组+链表</code>的结构。采用链地址法解决hashmap中的hash冲突问题，当链表长度达到8时进化为红黑树，节点数小于等于6时退化为链表。<br>&emsp;&emsp;jdk1.7与jdk1.8中，数据结构发生了变化，链表的尾插法改成了头插法，尾插法在hashmap扩容时有可能造成死循环。</p><h2 id="ConcurrentHashmap与Hashmap？"><a href="#ConcurrentHashmap与Hashmap？" class="headerlink" title="ConcurrentHashmap与Hashmap？"></a>ConcurrentHashmap与Hashmap？</h2><p>&emsp;&emsp;ConcurrentHashmap是juc包中的类，是用于在多线程情况下的hashmap，解决了hashmap在多线程情况下并发不安全的问题。<br>&emsp;&emsp;ConcurrentHashmap在1.7和1.8中采用了不同的结构和加锁方式。<br>&emsp;&emsp;jdk1.7中采用了段（Segment）的设计，每一个段中都是一个Hashmap的结构，将很多个段组合起来就是ConcurrentHashmap的结构，1.7中保证并发安全采用了分段锁的机制，就是在段设计的基础上，对每一个段加悲观锁（syncronized）。<br>&emsp;&emsp;jdk1.8中ConcurrentHashmap的数据结构采用了和Hashmap相同的数据结构，通过使用CAS操作来保证并发下的安全性。</p><h2 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h2><p>&emsp;&emsp;CAS就是比较并交换，全称Compare And Set，是一种原子性修改内存数据的一种策略。<br>&emsp;&emsp;CAS操作过程是：会将内存中的数据与一个期望值进行比较，比较结果相等了，才会将内存中的值修改为要改成的值（一般在缓存）。<br>&emsp;&emsp;java中很多地方都用到了CAS，比如AQS中就是用CAS去修改值，ConcurrentHashmap中也用到了。</p><h2 id="常用的JVM虚拟机？"><a href="#常用的JVM虚拟机？" class="headerlink" title="常用的JVM虚拟机？"></a>常用的JVM虚拟机？</h2><p>&emsp;&emsp;主要jvm虚拟机是Hotspot虚拟机，IBM有一款J9 JVM。</p><h2 id="jvm的垃圾回收器？"><a href="#jvm的垃圾回收器？" class="headerlink" title="jvm的垃圾回收器？"></a>jvm的垃圾回收器？</h2><ul><li><a href="../../../md/jvm/JVM%E2%80%94GC">jvm的垃圾回收算法与垃圾回收器</a></li></ul><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>&emsp;&emsp;单例模式共有8种写法。</p><ul><li>饿汉式-静态常量</li><li>饿汉式-静态代码块</li><li>懒汉式（默认线程不安全）</li><li>懒汉式-同步方法</li><li>懒汉式-同步代码块</li><li>双重检查锁</li><li>静态内部类</li><li>枚举</li></ul><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/aoz98d">mysql的索引</a></li></ul><h2 id="B-树结构？"><a href="#B-树结构？" class="headerlink" title="B+树结构？"></a>B+树结构？</h2><ul><li><a href="../../../%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B+%E6%A0%91">数据结构-B+树</a></li></ul><h2 id="事务的隔离级别？作用？"><a href="#事务的隔离级别？作用？" class="headerlink" title="事务的隔离级别？作用？"></a>事务的隔离级别？作用？</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/iarni8">事务的隔离级别</a></li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><ul><li><a href="../../../md/mysql/mysql%E4%B8%AD%E7%9A%84MVCC">mysql中的MVCC</a></li></ul><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring特点，功能"><a href="#Spring特点，功能" class="headerlink" title="Spring特点，功能"></a>Spring特点，功能</h3><ul><li>方便解耦，简化开发</li><li>支持AOP编程，很容易实现权限拦截，运行期监控</li><li>声明式事务支持，spring容器提供的功能</li><li>方便集成各种优秀框架</li><li>提供了众多工具类，简化API使用难度</li><li>的DI机制降低了业务对象替换的复杂性</li></ul><h3 id="XML配置如何转换为Bean"><a href="#XML配置如何转换为Bean" class="headerlink" title="XML配置如何转换为Bean"></a>XML配置如何转换为Bean</h3><ul><li><a href="https://blog.csdn.net/liu20111590/article/details/89857660">spring之xml文件转换为BeanDefinition</a></li></ul><h3 id="Bean的实例化过程"><a href="#Bean的实例化过程" class="headerlink" title="Bean的实例化过程"></a>Bean的实例化过程</h3><ul><li><a href="../../../md/spring/Spring%E4%B8%ADBean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B">Spring中Bean的实例化过程</a></li></ul><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/gmkoub">spring中循环依赖的处理</a></li></ul><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="redis分布式锁是怎么实现的？"><a href="#redis分布式锁是怎么实现的？" class="headerlink" title="redis分布式锁是怎么实现的？"></a>redis分布式锁是怎么实现的？</h3><ul><li><a href="../../../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">redis分布式锁</a></li></ul><h3 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h3><p>&emsp;&emsp;redis中共有8种数据结构，其中常用的有5种。</p><ul><li><p>字符串 string</p></li><li><p>散列-hash</p></li><li><p>列表-list</p></li><li><p>集合-set</p></li><li><p>有序集合-zset</p></li><li><p>位图-bitmap</p></li><li><p>地理位置-geospatial</p></li><li><p>hyperloglog</p></li><li><p><a href="../../../md/redis/redis%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">redis中的数据结构</a></p></li></ul><h2 id="Rocketmq"><a href="#Rocketmq" class="headerlink" title="Rocketmq"></a>Rocketmq</h2><h3 id="消息消费失败怎么处理？"><a href="#消息消费失败怎么处理？" class="headerlink" title="消息消费失败怎么处理？"></a>消息消费失败怎么处理？</h3><p>&emsp;&emsp;消息消费失败可以分为两种方向，一种是mq进行消息投递失败，另一种是业务系统消费消息失败。<br>&emsp;&emsp;mq消息投递失败会将消息放入定时投递队列中，按照一定的时间间隔后进行消息重投。<br>&emsp;&emsp;业务系统可以将消息存储起来，对于失败的消息，通过定时处理的方式进行恢复。保存起来类似于消息幂等的处理方式。</p><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><h3 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h3><p>&emsp;&emsp;底层采用monitor指令实现，会生成一条moniter enter和二条moniter exit（一条正常退出，另一条异常退出）指令实现。</p><h3 id="Synchronized加在方法上和代码块上的区别？生成的指令的区别？"><a href="#Synchronized加在方法上和代码块上的区别？生成的指令的区别？" class="headerlink" title="Synchronized加在方法上和代码块上的区别？生成的指令的区别？"></a>Synchronized加在方法上和代码块上的区别？生成的指令的区别？</h3><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/rc3ofp">synchronized</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="answer" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/answer/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq和kafka的区别</title>
    <link href="https://linqiankun.github.io/hexoblog/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq%E5%92%8Ckafka%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://linqiankun.github.io/hexoblog/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq%E5%92%8Ckafka%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-07-06T08:21:57.000Z</published>
    <updated>2021-07-06T11:25:36.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><span id="more"></span><hr><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="数据可靠性"><a href="#数据可靠性" class="headerlink" title="数据可靠性"></a>数据可靠性</h2><ul><li>RocketMQ支持异步实时刷盘，同步刷盘，同步Replication，异步Replication。</li><li>kafka使用异步刷盘模式，异步Replication。</li></ul><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><ul><li>kafka单机TPS约在百万条/秒，消息大小10个字节。</li><li>RocketMQ单机写入TPS单实例约7万条/秒，单机部署3个broker，最高可以跑到12万条/秒，消息大小10个字节。</li></ul><blockquote><p>kafka主要是由于Producer端将多个小消息合并，批量发向Broker。</p></blockquote><h2 id="单机支持的队列数"><a href="#单机支持的队列数" class="headerlink" title="单机支持的队列数"></a>单机支持的队列数</h2><ul><li>kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间边长。</li><li>RocketMQ单机最多支持5万个队列，load不会发生明显变化。</li></ul><h2 id="消息投递实时性"><a href="#消息投递实时性" class="headerlink" title="消息投递实时性"></a>消息投递实时性</h2><ul><li>kafka使用端轮询方式，实时性取决于轮询时间间隔。</li><li>RocketMQ使用长轮询，同Push方式实时性一致，消息的投递延时通常在几个毫秒。</li></ul><h2 id="消费失败重试"><a href="#消费失败重试" class="headerlink" title="消费失败重试"></a>消费失败重试</h2><ul><li>kafka消费失败不支持重试。</li><li>RocketMQ消费失败支持定时重试，每次重试时间间隔依次增大。</li></ul><h2 id="严格的消息顺序"><a href="#严格的消息顺序" class="headerlink" title="严格的消息顺序"></a>严格的消息顺序</h2><ul><li>kafka支持消息顺序，但是一台Broker宕机后，就会产生消息乱序。</li><li>RocketMQ支持严格的消息顺序，在顺序消息场景下，一台Broker宕机，发送消息会失败，但不会乱序。</li></ul><h2 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h2><ul><li>kafka不支持定时消息</li><li>RocketMQ支持定时消息<ul><li>支持定时level，以及指定毫秒级别的延时时间</li></ul></li></ul><h2 id="分布式事务消息"><a href="#分布式事务消息" class="headerlink" title="分布式事务消息"></a>分布式事务消息</h2><ul><li>kafka不支持分布式事务消息</li><li>RocketMQ支持分布式事务消息，采用半消息实现</li></ul><h2 id="消息查询"><a href="#消息查询" class="headerlink" title="消息查询"></a>消息查询</h2><ul><li>kafka不支持消息查询</li><li>RocketMQ支持根据Message Id查询消息，也支持根据消息内容查询消息</li></ul><h2 id="消息回溯"><a href="#消息回溯" class="headerlink" title="消息回溯"></a>消息回溯</h2><ul><li>kafka理论上可以按照Offset来回溯消息</li><li>rocketMQ支持按照时间来回溯消息，精度毫秒，例如从一天之前的某时某分某秒开始重新消费消息</li></ul><h2 id="消费并行度"><a href="#消费并行度" class="headerlink" title="消费并行度"></a>消费并行度</h2><ul><li>kafka消费的并行度依赖topic配置的分区数，消费并行度和分区数一致。</li><li>RocketMQ消费并行度分两种情况<ul><li>顺序消费方式并行度同Kafka完全一致</li><li>乱序方式并行度取决于Consumer的线程数，如Topic配置10个队列，10台机器消费，每台机器100个线程，那么并行度为1000。</li></ul></li></ul><h2 id="Broker端消息过滤"><a href="#Broker端消息过滤" class="headerlink" title="Broker端消息过滤"></a>Broker端消息过滤</h2><ul><li>kafka不支持broker端消息过滤</li><li>RocketMQ支持两种消息过滤方式<ul><li>根据tag来过滤，相当于子topic</li><li>向服务器上传一段Java代码，可以对消息做任意形式的过滤，甚至可以做Message Body的过滤拆分。</li></ul></li></ul><h2 id="使用区别"><a href="#使用区别" class="headerlink" title="使用区别"></a>使用区别</h2><ul><li>kafka在日志，大数据领域比较成熟</li><li>RocketMQ多用于削峰填谷，多用于业务领域。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="kafka" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/"/>
    
    <category term="rocketmq" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="kafka" scheme="https://linqiankun.github.io/hexoblog/tags/kafka/"/>
    
    <category term="消息中间件" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="https://linqiankun.github.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>网易一面（数据中台—java）</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E6%98%93%E4%B8%80%E9%9D%A2%EF%BC%88%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E2%80%94java%EF%BC%89/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E6%98%93%E4%B8%80%E9%9D%A2%EF%BC%88%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E2%80%94java%EF%BC%89/</id>
    <published>2021-07-03T11:55:15.000Z</published>
    <updated>2021-07-08T11:49:45.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>项目介绍</li><li>redis分布式锁怎么实现？</li><li>还有其他的实现思路？具体怎么实现？（数据库，zk）</li><li>redis分布式控制抢单，可不可以用数据库乐观锁？</li><li>数据库乐观锁怎么实现？</li><li>redis哨兵模式讲一下？</li><li>哨兵和机器间如何通信（ping，pong）?</li><li>哨兵如何选举leader?</li><li>mvcc讲一下？</li><li>mvcc的目的？原理？场景？</li><li>数据库隔离级别的作用？场景</li><li>redo log，undo log，bin log分别说一下？</li><li>这些是在什么阶段产生的？</li><li>mysql模块说一下？那些产生什么日志？</li><li>mysql索引讲一下？从你自己知道的角度讲？</li><li>聚簇索引和非聚簇索引的区别？</li><li>shiro讲一下？</li><li>shiro怎么存储session？</li><li>你们用shiro怎么存的（token）？</li><li>rocketmq和kafka的区别？</li><li>rocketmq怎么保证消息只会被一台机器消费？</li><li>jvm调优过没？</li><li>系统优化过没？</li><li>线程之间是如何通信的？</li><li>jvm垃圾回收器有哪些？</li><li>jvm垃圾回收算法有哪些？</li><li>多线程怎么通信的？</li><li>如何3个线程按照指定abc的顺序打印10000万次？</li><li>notify和notifyAll的区别？</li><li>可以指定某个线hex唤醒吗？</li><li>项目中有什么印象深刻的？（异步获取结果）</li><li>用过大数据方面的东西没？（没有）</li><li>最近有在看什么书？</li><li>有什么想了解的？</li></ol><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="rocketmq和kafka的区别？"><a href="#rocketmq和kafka的区别？" class="headerlink" title="rocketmq和kafka的区别？"></a>rocketmq和kafka的区别？</h2><p>&emsp;&emsp;<a href="../../md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq%E5%92%8Ckafka%E7%9A%84%E5%8C%BA%E5%88%AB">rocketmq和kafka的区别</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>多线程之死锁</title>
    <link href="https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/"/>
    <id>https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/</id>
    <published>2021-07-02T07:46:24.000Z</published>
    <updated>2021-07-06T05:47:29.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;死锁是指两个或两个以上进程（在运行的过程中因争夺资源而造成的一种僵局），若无外力作用，这些线程，进程都将无法向前推进。</p><span id="more"></span><ul><li>参与死锁的进程（线程）至少为2个</li><li>参与死锁的进程（线程）均等待资源</li><li>参与死锁的进程（线程）至少有2个已经占有资源</li><li>死锁进程是系统中当前进程集合的一个子集</li><li>死锁会浪费大量系统资源，甚至导致系统崩溃</li></ul><hr><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>&emsp;&emsp;所有的死锁都是对资源的争夺造成的，资源是一切的罪魁祸首。</p><h2 id="永久资源与临时资源"><a href="#永久资源与临时资源" class="headerlink" title="永久资源与临时资源"></a>永久资源与临时资源</h2><h3 id="永久资源"><a href="#永久资源" class="headerlink" title="永久资源"></a>永久资源</h3><p>&emsp;&emsp;永久资源可以被多次使用，如所有硬件。</p><ul><li>只能分配给一个进程使用，不允许多个进程共享</li><li>进程使用时，需按照请求资源、使用资源、释放资源的顺序</li><li>这种资源的数量是固定的，运行期间，不能创建，也不能销毁</li></ul><h3 id="临时资源"><a href="#临时资源" class="headerlink" title="临时资源"></a>临时资源</h3><p>&emsp;&emsp;是在运行期间动态创建和销毁的资源。</p><ul><li>数量在运行期间是不断变化的，有可能为0</li><li>在运行过程中，可以不断的创建这种资源，将它们放入缓冲区，增加资源数量</li><li>也可以在运行过程中，请求几个临时资源，用于运行中的消耗</li></ul><p>&emsp;&emsp;一般由生产者进程产生，消费者进程消耗，如何用于通信的消息。</p><h2 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h2><h3 id="可抢占资源"><a href="#可抢占资源" class="headerlink" title="可抢占资源"></a>可抢占资源</h3><p>&emsp;&emsp;可抢占资源指某进程在获得这类资源后，该类资源可以被其他进程或系统抢占，也就是大家共享，这类资源不会引起死锁。比如CPU和内存。</p><h3 id="不可抢占资源"><a href="#不可抢占资源" class="headerlink" title="不可抢占资源"></a>不可抢占资源</h3><p>&emsp;&emsp;一旦系统将某资源分配给该进程后，就不能将其强行收回，只能在进程使用完后自己释放。比如打印机。</p><hr><h1 id="死锁原因"><a href="#死锁原因" class="headerlink" title="死锁原因"></a>死锁原因</h1><ul><li>竞争不可抢占资源引起死锁<blockquote><p>通常系统中的不可抢占资源，其数量不足以满足同时运行，使得在运行过程中，会因资源抢占而进入僵局，造成死锁。</p></blockquote></li><li>竞争可消耗资源引起死锁</li><li>进程推进顺序不当引起死锁<blockquote><p>运行过程中，请求和释放资源的顺序不科学，也会造成死锁，我等你，你等我的情况。<br>信号量使用不当也会死锁，进程间彼此相互等待对方发来的消息，结果也会使得这 些进程间无法继续向前推进。</p></blockquote></li></ul><hr><h1 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h1><h2 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h2><p>&emsp;&emsp;运行的进程对它所分配的资源进行排他性控制，在一段时间内某资源仅为一个进程所占用。此时若有其他进程线程来请求资源，则请求的进程线程只能等待。</p><h2 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h2><p>&emsp;&emsp;所获得的资源，已经占用的资源，不能被其他进程强行夺走，只能由自己主动释放。</p><h2 id="请求与保持"><a href="#请求与保持" class="headerlink" title="请求与保持"></a>请求与保持</h2><p>&emsp;&emsp;进程已经保持占用了至少一个资源，但又提出了新的资源请求，而该资源已经被其他进程占有，此时进程请求被阻塞，但对自己已获得资源保持占用。</p><h2 id="循环等待"><a href="#循环等待" class="headerlink" title="循环等待"></a>循环等待</h2><p>&emsp;&emsp;存在进程资源间的循环等待链。</p><hr><h1 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h1><ul><li><strong>预防死锁</strong>：通过设置某些限制条件，去破坏产生死锁的四个条件的一个或几个。</li><li><strong>避免死锁</strong>：在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁发生。</li><li><strong>检测死锁</strong>：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。</li><li><strong>解除死锁</strong>：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。</li></ul><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><h3 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h3><p>&emsp;&emsp;就是在系统里取消互斥。若资源不被一个进程独占使用，那么死锁是肯定不会发生的。<br>&emsp;&emsp;实际情况中，互斥条件一般不能也无法被破环，否则会造成结果不可再现。</p><h3 id="破环不可抢占条件"><a href="#破环不可抢占条件" class="headerlink" title="破环不可抢占条件"></a>破环不可抢占条件</h3><p>&emsp;&emsp;就是允许对资源实行抢夺。  </p><ul><li>如果占有某些资源的一个进程进行进一步资源请求被拒绝，则该进程必须释放它最初占有的资源，如果有必要，可再次请求这些资源和另外的资源。</li><li>如果一个进程请求当前被另一个进程占有的一个资源，则操作系统可以抢占另一个进程，要求它释放资源。只有在任意两个进程的优先级都不相同的条件下，方法二才能预防死锁。</li></ul><h3 id="破环请求与保持条件"><a href="#破环请求与保持条件" class="headerlink" title="破环请求与保持条件"></a>破环请求与保持条件</h3><p>&emsp;&emsp;就是在系统中不允许进程在已获得某种资源的情况下，申请其他资源。即要想出一个办法，阻止进程在持有资源的同时申请其他资源。</p><ul><li>创建进程时，要求它申请所需的全部资源，系统或满足其所有要求，或什么也不给它。这是所谓的 “ 一次性分配”方案。</li><li>要求每个进程提出新的资源申请前，释放它所占有的资源。这样，一个进程在需要资源S时，须先把它先前占有的资源R释放掉，然后才能提出对S的申请，即使它可能很快又要用到资源R。</li></ul><h3 id="破环循环等待条件"><a href="#破环循环等待条件" class="headerlink" title="破环循环等待条件"></a>破环循环等待条件</h3><p>&emsp;&emsp;破坏“循环等待”条件的一种方法，是将系统中的所有资源统一编号，进程可在任何时刻提出资源申请，但所有申请必须按照资源的编号顺序（升序）提出。这样做就能保证系统不出现死锁。</p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>&emsp;&emsp;合理规划资源，在系统资源，进程调度等方面，设计让死锁条件无法满足，避免进程永久占据系统资源或在等待条件下占用资源，从而防止死锁。<br>&emsp;&emsp;预防死锁和避免死锁的区别：预防死锁是设法至少破坏产生死锁的四个必要条件之一，严格的防止死锁的出现，而避免死锁则不那么严格的限制产生死锁的必要条件的存在。因为即使死锁的必要条件存在，也不一定发生死锁。避免死锁是在系统运行过程中注意避免死锁的最终发生。</p><h3 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h3><ul><li>有序资源分配法</li><li>银行家算法</li></ul><h3 id="避免死锁的技术"><a href="#避免死锁的技术" class="headerlink" title="避免死锁的技术"></a>避免死锁的技术</h3><ul><li>加锁顺序</li><li>加锁时限</li><li>死锁检测</li></ul><h2 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h2><p>&emsp;&emsp;死锁检测与恢复是指系统设有专门的机构，当死锁发生时，该机构能够检测到死锁发生的位置和原因，并能通过外力破坏死锁发生的必要条件，从而使得并发进程从死锁状态中恢复出来。</p><h2 id="解除死锁"><a href="#解除死锁" class="headerlink" title="解除死锁"></a>解除死锁</h2><p>&emsp;&emsp;死锁解除的方法有：</p><ol><li><strong>资源剥夺法</strong>：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源，而处于资源匮乏的状态。</li><li><strong>撤销进程法</strong>：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li><li><strong>进程回退法</strong>：让一（多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。</li></ol><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://blog.csdn.net/wljliujuan/article/details/79614019">死锁，死锁的四个必要条件以及处理策略</a></li><li><a href="https://blog.csdn.net/wangxj_2017/article/details/116447392">多线程的下的死锁问题排查</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;死锁是指两个或两个以上进程（在运行的过程中因争夺资源而造成的一种僵局），若无外力作用，这些线程，进程都将无法向前推进。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/categories/java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/tags/java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深圳雪球科技（NFC）二面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E6%B7%B1%E5%9C%B3%E9%9B%AA%E7%90%83%E7%A7%91%E6%8A%80%EF%BC%88NFC%EF%BC%89%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E6%B7%B1%E5%9C%B3%E9%9B%AA%E7%90%83%E7%A7%91%E6%8A%80%EF%BC%88NFC%EF%BC%89%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-02T03:16:49.000Z</published>
    <updated>2021-07-02T07:19:47.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>目前情况<ol><li>姓名等个人信息</li><li>在职状态</li><li>薪资</li></ol></li><li>项目介绍<ol><li>业务</li><li>技术栈</li><li>遇到问题</li><li>如何解决</li></ol></li><li>redis分布式锁实现</li><li>redis模板（jedis、redisTemplate）</li><li>多线程<ol><li> 多线程死锁怎么解决</li><li> DeadLock</li><li>多线程线程数量设计<ol><li> 慢IO</li><li> CPU密集</li></ol></li></ol></li><li>项目中的多线程代码是你写的吗</li><li>线程池原理</li><li>后面的规划（技术，管理）</li><li>基建怎么建设（自建机房，阿里云）</li><li>发布流程（有发布系统，用jekins）</li><li>容器化<ol><li> 有没有容器化</li><li> k8s</li><li> docker使用</li><li> 目前是本地虚拟机没有容器化</li></ol></li><li>抗压能力，加班情况</li><li>为什么换工作</li><li>换工作选择什么行业</li></ol><p><img src="https://raw.githubusercontent.com/LinQiankun/picurl/main/java%E5%86%99%E9%9D%A2%E7%BB%8F%EF%BC%8C%E6%94%92%E4%BA%BA%E5%93%81_00.jpg" alt="写面经，攒人品"></p><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>MQ消息幂等</title>
    <link href="https://linqiankun.github.io/hexoblog/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/MQ%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89/"/>
    <id>https://linqiankun.github.io/hexoblog/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/MQ%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89/</id>
    <published>2021-07-01T06:47:42.000Z</published>
    <updated>2021-07-01T08:08:12.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;MQ中的消息可靠性主要靠两个方面实现：</p><ol><li>消息落地</li><li>消息超时，重传，确认</li></ol><span id="more"></span><p>&emsp;&emsp;整个消息体系由<strong>发送端、服务端、存储设施、接收端</strong>四块结构构成。<br>&emsp;&emsp;为保证消息的可达性，超时、重传、确认机制可能导致消息总线、或者业务方 收到重复的消息，从而对业务产生影响。</p><p>&emsp;&emsp;<a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E7%9A%84%E5%AE%9E%E7%8E%B0">幂等介绍</a></p><hr><h1 id="上半场幂等设计"><a href="#上半场幂等设计" class="headerlink" title="上半场幂等设计"></a>上半场幂等设计</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/mq%E4%B8%8A%E5%8D%8A%E5%9C%BA.png" alt="mq结构"></p><p>&emsp;&emsp;消息发送的上半场就是图中的1、2、3过程，表示了消息的发送，保存过程。<br>&emsp;&emsp;如果3丢失，发送端MQ-client超时后会重发消息，可能导致服务端MQ-server收到重复消息。</p><blockquote><p>这里的重新发送方是Client，而不是实际的业务发送方。</p></blockquote><p>&emsp;&emsp;此时重发是MQ-client发起的，消息的处理是MQ-server，为了避免步骤2落地重复的消息，对每条消息， MQ系统内部必须生成一个msgId，作为去重和幂等的依据。<br>&emsp;&emsp;这个msgId的规则必须是：</p><ol><li><p>全局唯一</p></li><li><p>MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽</p><p>&emsp;&emsp;有了这个msgId，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等。<br>&emsp;&emsp;而业务方收到发送失败而重新发送的消息，对mq而言，会被认为是不同的消息（一条新的消息），只是这条重新发送的消息和上一条内容一样而已，这条重新发送的消息，会生成新的msgId。</p></li></ol><hr><h1 id="下半场幂等设计"><a href="#下半场幂等设计" class="headerlink" title="下半场幂等设计"></a>下半场幂等设计</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/mq%E4%B8%8A%E5%8D%8A%E5%9C%BA.png" alt="mq结构"></p><p>&emsp;&emsp;消息消费的下半场就是图中的4、5、6过程，表示消息的投递，消费过程。<br>&emsp;&emsp;接收端MQ-client回ACK给服务端MQ-server，是消息消费业务方的主动调用行为，不能由MQ-client自动发起，因为MQ系统不知道消费方什么时候真正消费成功。<br>&emsp;&emsp;如果5丢失，服务端MQ-server超时后会重发消息，可能导致MQ-client收到重复的消息，这样有可能造成重复消费。<br>&emsp;&emsp;此时重发是MQ-server发起的，消息的处理是消息消费业务方，消息重发势必导致业务方重复消费，为了保证业务幂等性 ，业务消息体中，必须有一个biz-id，作为去重和幂等的依据。<br>&emsp;&emsp;这个biz-id的规则是：</p><ol><li>对于同一个业务场景，全局唯一</li><li>由业务消息发送方生成，业务相关，对MQ透明</li><li>由业务消息消费方负责判重，以保证幂等</li></ol><p>&emsp;&emsp;有了这个业务ID，才能够保证下半场消息消费业务方即使收到重复消息，也只有1条消息被消费，保证了幂等。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="上半场"><a href="#上半场" class="headerlink" title="上半场"></a>上半场</h2><p>&emsp;&emsp;MQ-client生成inner-msg-id，保证上半场幂等。<br>&emsp;&emsp;这个ID全局唯一，业务无关，由MQ保证。</p><h2 id="下半场"><a href="#下半场" class="headerlink" title="下半场"></a>下半场</h2><p>&emsp;&emsp;业务 发送方带入biz-id，业务 接收方去重保证幂等。<br>&emsp;&emsp;这个ID对单业务唯一，业务相关，对MQ透明。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>&emsp;&emsp;幂等性，不仅对MQ有要求，对业务上下游也有要求。<br>&emsp;&emsp;实际上，MQ只实现了自己内部的幂等性，对于业务的幂等性，消息重投之类的，MQ并没有做处理，业务的幂等性，需要自己手动实现。</p><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/chx9832/p/12325871.html">RocketMQ解决幂等性问题</a></li><li><a href="https://blog.csdn.net/gwd1154978352/article/details/80655338">RocketMQ——消息幂等问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;MQ中的消息可靠性主要靠两个方面实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息落地&lt;/li&gt;
&lt;li&gt;消息超时，重传，确认&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="https://linqiankun.github.io/hexoblog/tags/rocketmq/"/>
    
    <category term="幂等" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%B9%82%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>涂鸦智能一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E6%B6%82%E9%B8%A6%E6%99%BA%E8%83%BD%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E6%B6%82%E9%B8%A6%E6%99%BA%E8%83%BD%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-06-30T12:44:16.000Z</published>
    <updated>2021-07-21T05:43:30.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>项目介绍</li><li>线程创建的几个方式</li><li>callable的使用场景（*）</li><li>多线程情况下的资源安全（锁，*）</li><li>线程池的工作原理</li><li>服务调用的方式</li><li>dubbo的协议（*）</li><li>dubbo的序列化方式（*）</li><li>分布式事务<ol><li> 二阶段提交</li><li> mq事务消息</li></ol></li><li>jvm内存模型</li><li>redis分布式锁的问题（碰到过没有）</li><li>学习的方法</li><li>反问<ol><li> lot为什么需要客户管理系统</li><li> 技术栈</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/LinQiankun/picurl/main/java%E5%86%99%E9%9D%A2%E7%BB%8F%EF%BC%8C%E6%94%92%E4%BA%BA%E5%93%81_00.jpg" alt="写面经，攒人品"></p><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="线程创建的几种方式？"><a href="#线程创建的几种方式？" class="headerlink" title="线程创建的几种方式？"></a>线程创建的几种方式？</h2><p>&emsp;&emsp;线程创建的4种方式：</p><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>时间Callable接口</li><li>使用线程池，使用Executor框架创建线程池</li></ol><h2 id="callable的使用场景？"><a href="#callable的使用场景？" class="headerlink" title="callable的使用场景？"></a>callable的使用场景？</h2><p>&emsp;&emsp;callable有返回值，可以通过Future获取返回值。</p><h2 id="多线程情况下的资源安全？"><a href="#多线程情况下的资源安全？" class="headerlink" title="多线程情况下的资源安全？"></a>多线程情况下的资源安全？</h2><p>&emsp;&emsp;有多种保证线程安全的方式：</p><ol><li>加锁的方式</li><li>并发的工具包</li></ol><h2 id="线程池的工作原理？"><a href="#线程池的工作原理？" class="headerlink" title="线程池的工作原理？"></a>线程池的工作原理？</h2><ul><li><a href="../../../md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/threadpool">threadpool</a></li></ul><h2 id="服务调用的方式？"><a href="#服务调用的方式？" class="headerlink" title="服务调用的方式？"></a>服务调用的方式？</h2><p>&emsp;&emsp;服务调用分为多种方式调用：</p><ol><li>本地service调用</li><li>远程调用<ol><li>rpc调用</li><li>rest（http）调用</li></ol></li></ol><h2 id="dubbo的协议，dubbo的序列化方式？"><a href="#dubbo的协议，dubbo的序列化方式？" class="headerlink" title="dubbo的协议，dubbo的序列化方式？"></a>dubbo的协议，dubbo的序列化方式？</h2><ul><li><a href="../../../md/rpc/dubbo/dubbo%E7%9A%849%E7%A7%8D%E5%8D%8F%E8%AE%AE">dubbo的9种协议</a></li></ul><h2 id="分布式事务？"><a href="#分布式事务？" class="headerlink" title="分布式事务？"></a>分布式事务？</h2><ul><li><a href="../../../md/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1">分布式事务</a><!-- [分布式事务.md](../../md/分布式/分布式事务.md) --></li></ul><h2 id="jvm内存模型？"><a href="#jvm内存模型？" class="headerlink" title="jvm内存模型？"></a>jvm内存模型？</h2><ul><li><a href="../../../md/jvm/jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84">jvm内存结构</a>  </li><li><a href="../../../md/jvm/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5">JVM内存分配策略</a>  </li><li><a href="../../../md/jvm/jvm%E4%B8%AD%E6%96%B9%E6%B3%95%E5%8C%BA-%E6%B0%B8%E4%B9%85%E4%BB%A3-%E5%85%83%E7%A9%BA%E9%97%B4">jvm中方法区-永久代-元空间</a>  </li><li><a href="../../../md/jvm/JVM%E2%80%94GC">JVM—GC</a></li></ul><h2 id="redis分布式锁的问题？"><a href="#redis分布式锁的问题？" class="headerlink" title="redis分布式锁的问题？"></a>redis分布式锁的问题？</h2><ul><li><a href="../../../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">redis分布式锁</a>  </li><li><a href="../../../md/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁</a>  </li><li><a href="../../../md/zookeeper/zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">zookeeper实现分布式锁</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="answer" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/answer/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>接口幂等的实现</title>
    <link href="https://linqiankun.github.io/hexoblog/md/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://linqiankun.github.io/hexoblog/md/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-06-30T08:42:13.000Z</published>
    <updated>2021-07-01T08:00:18.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是幂等"><a href="#什么是幂等" class="headerlink" title="什么是幂等"></a>什么是幂等</h1><p>&emsp;&emsp;接口幂等性的实质就是：<strong>接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的。</strong><br>&emsp;&emsp;有些接口天然支持幂等性，比如查询接口；而增加、更新、删除都要人工保持幂等性。</p><span id="more"></span><hr><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><p>&emsp;&emsp;全局的唯一ID，就是根据业务操作和内容生成一个全局ID，在执行操作之前，先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。<br>&emsp;&emsp;如果不存在则把全局ID，存储到存储系统中，比如Redis、Mysql等。如果存在表示该操作已经执行。  </p><p>&emsp;&emsp;全局唯一IP是一个通用方案，可以支持插入、更新、删除业务操作。</p><h2 id="去重表"><a href="#去重表" class="headerlink" title="去重表"></a>去重表</h2><p>&emsp;&emsp;适用于在业务中有唯一标识的插入场景中，比如一个订单只会支付一次，可以将订单ID作为唯一标识。<br>&emsp;&emsp;这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。</p><h2 id="插入唯一主键"><a href="#插入唯一主键" class="headerlink" title="插入唯一主键"></a>插入唯一主键</h2><p>&emsp;&emsp;这种适用于插入并且有唯一索引的情况，比如我们要关联商品品类，其中商品的ID和品类的ID可以构成唯一索引，并且在数据表中也增加了唯一索引。这时就可以使用InsertOrUpdate操作。</p><h2 id="多版本控制（MVCC）"><a href="#多版本控制（MVCC）" class="headerlink" title="多版本控制（MVCC）"></a>多版本控制（MVCC）</h2><p>&emsp;&emsp;这种适用于更新场景，通过在更新的接口中添加版本号来实现幂等。</p><h2 id="状态机控制"><a href="#状态机控制" class="headerlink" title="状态机控制"></a>状态机控制</h2><p>&emsp;&emsp;这种方法适合在有状态机流转的情况下，通过状态字段的值的大小来做幂等，状态只能顺着一个方向流转。</p><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://blog.csdn.net/yuhaiyang_1/article/details/81040967">什么是幂等，什么情况下需要幂等，如何实现幂等</a></li><li><a href="https://www.jianshu.com/p/22c788a04a95">幂等设计</a></li><li><a href="https://cloud.tencent.com/developer/article/1526642">如何做到接口的幂等性</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是幂等&quot;&gt;&lt;a href=&quot;#什么是幂等&quot; class=&quot;headerlink&quot; title=&quot;什么是幂等&quot;&gt;&lt;/a&gt;什么是幂等&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;接口幂等性的实质就是：&lt;strong&gt;接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的。&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;有些接口天然支持幂等性，比如查询接口；而增加、更新、删除都要人工保持幂等性。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://linqiankun.github.io/hexoblog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="幂等" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%B9%82%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>深圳雪球科技（NFC）一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E6%B7%B1%E5%9C%B3%E9%9B%AA%E7%90%83%E7%A7%91%E6%8A%80%EF%BC%88NFC%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/answer/%E6%B7%B1%E5%9C%B3%E9%9B%AA%E7%90%83%E7%A7%91%E6%8A%80%EF%BC%88NFC%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-06-25T10:20:43.000Z</published>
    <updated>2021-07-21T05:49:13.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>项目介绍</li><li>dubbo中如何找到调用的节点（服务调用过程）</li><li>zookeeper的选举机制</li><li>redis分布式锁原理</li><li>12306设计（自己关注点问题，感觉防止超卖）<ol><li>很多人抢票中的问题</li></ol></li><li>事务的隔离级别</li><li>用过oracle吗（没有）</li><li>你们用的隔离级别</li><li>一个事务读了数据，另一个修改了，再去读会，会不一样，这是那个级别会发生的问题</li><li>反问（公司规模，具体业务）</li></ol><p><img src="https://raw.githubusercontent.com/LinQiankun/picurl/main/java%E5%86%99%E9%9D%A2%E7%BB%8F%EF%BC%8C%E6%94%92%E4%BA%BA%E5%93%81_00.jpg" alt="写面经，攒人品"></p><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="dubbo中如何找到调用的节点"><a href="#dubbo中如何找到调用的节点" class="headerlink" title="dubbo中如何找到调用的节点"></a>dubbo中如何找到调用的节点</h2><p>&emsp;&emsp;这个过程应该分为两步，第一步是服务发现，第二步是负载均衡选取节点。  </p><ul><li><a href="../../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E6%9A%B4%E9%9C%B2%E8%BF%87%E7%A8%8B">dubbo服务启动暴露过程</a>  </li><li><a href="../../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5%E6%B5%81%E7%A8%8B">dubbo服务引入流程</a>  </li><li><a href="../../../md/rpc/dubbo/dubbo%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B">dubbo服务调用过程</a>  </li></ul><p>&emsp;&emsp;服务发现，就是获取到可调用的节点后，负载均衡过程中会根据一些算法去选择某一个节点调用，具体的算法一般有：</p><ul><li>随机</li><li>轮询</li><li>一致性hash</li></ul><h2 id="zookeeper的选举机制"><a href="#zookeeper的选举机制" class="headerlink" title="zookeeper的选举机制"></a>zookeeper的选举机制</h2><ul><li><a href="../../../md/zookeeper/ZAB%E5%8D%8F%E8%AE%AE">ZAB协议</a></li><li><a href="../../../md/zookeeper/zookeeper-leader%E9%80%89%E4%B8%BE">zookeeper-leader选举</a></li></ul><h2 id="redis分布式锁原理"><a href="#redis分布式锁原理" class="headerlink" title="redis分布式锁原理"></a>redis分布式锁原理</h2><ul><li><a href="../../../md/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">redis分布式锁</a></li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul><li><a href="https://www.yuque.com/jiufenshiren/ra5mzi/iarni8">mysql中的事务</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="answer" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/answer/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>B+树</title>
    <link href="https://linqiankun.github.io/hexoblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B+%E6%A0%91/"/>
    <id>https://linqiankun.github.io/hexoblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B+%E6%A0%91/</id>
    <published>2021-06-24T02:09:57.000Z</published>
    <updated>2021-06-24T08:17:38.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据结构" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
