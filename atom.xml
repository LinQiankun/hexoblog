<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Study</title>
  
  <subtitle>杀人放火金腰带，修桥补路无尸骸！</subtitle>
  <link href="http://linqiankun.gitee.io/hexoblog/atom.xml" rel="self"/>
  
  <link href="http://linqiankun.gitee.io/hexoblog/"/>
  <updated>2021-05-31T06:44:29.944Z</updated>
  <id>http://linqiankun.gitee.io/hexoblog/</id>
  
  <author>
    <name>linqiankun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rocketmq集群简介</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/31/md/rocketmq/rocketmq%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/31/md/rocketmq/rocketmq%E9%9B%86%E7%BE%A4%E7%AE%80%E4%BB%8B/</id>
    <published>2021-05-31T06:20:57.000Z</published>
    <updated>2021-05-31T06:44:29.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;Rocketmq的四部分每一部分都可以进行集群部署。<a href="https://www.yuque.com/jiufenshiren/mvgau4/cn_operation#b5212acf">集群搭建</a></p><span id="more"></span><h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><p>&emsp;&emsp;NameServer通常是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知Broker的路由的信息。</p><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>&emsp;&emsp;与NameServer相比，Broker的集群比较复杂些。<br>&emsp;&emsp;Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。<br>&emsp;&emsp;broker集群可以分为：单Master模式，多Master模式，多Master多Slave模式。</p><h3 id="单Master模式"><a href="#单Master模式" class="headerlink" title="单Master模式"></a>单Master模式</h3><p>&emsp;&emsp;这种模式一般用于本地学习，或者测试，不适合线上使用，一旦单个Broker挂掉了，会造成所有通信失败。</p><h3 id="多Master模式"><a href="#多Master模式" class="headerlink" title="多Master模式"></a>多Master模式</h3><p>&emsp;&emsp;全是Master，没有Slave。当然，一个broker宕机了，应用是无影响的，缺点在于宕机的Master上未被消费的消息在Master没有恢复之前不可以订阅。<br>&emsp;&emsp;配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高。<br>&emsp;&emsp;缺点是：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。</p><h3 id="多Master多Slave模式"><a href="#多Master多Slave模式" class="headerlink" title="多Master多Slave模式"></a>多Master多Slave模式</h3><p>&emsp;&emsp;这种又可以分为两种，根据数据同步的时间分为，异步复制，同步双写。</p><h4 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h4><p>&emsp;&emsp;多对Master-Slave，高可用！采用异步复制的方式，主备之间短暂延迟，MS级别。Master宕机，消费者可以从Slave上进行消费，不受影响，但是Master的宕机，会导致丢失掉极少量的消息。<br>&emsp;&emsp;即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样。<br>&emsp;&emsp;缺点在于：Master宕机，磁盘损坏情况下会丢失少量消息。</p><h4 id="同步双写"><a href="#同步双写" class="headerlink" title="同步双写"></a>同步双写</h4><p>&emsp;&emsp;和上面的区别点在于采用的是同步方式，也就是在Master/Slave都写成功的前提下，向应用返回成功，可见不论是数据，还是服务都没有单点，都非常可靠！缺点在于同步的性能比异步稍低。<br>&emsp;&emsp;据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高。<br>&emsp;&emsp;缺点是：性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%90%8C%E6%AD%A5%E5%8F%8C%E5%86%99%E5%92%8C%E5%BC%82%E6%AD%A5%E5%8F%8C%E5%86%99.png" alt="同步双写和异步双写"></p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/mq%E9%9B%86%E7%BE%A4%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94.png" alt="集群方式对比"></p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%B5%8B%E8%AF%95.png" alt="高可用测试"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Rocketmq的四部分每一部分都可以进行集群部署。&lt;a href=&quot;https://www.yuque.com/jiufenshiren/mvgau4/cn_operation#b5212acf&quot;&gt;集群搭建&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
    <category term="分布式" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>TODO</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/28/TODO/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/28/TODO/</id>
    <published>2021-05-28T07:11:21.000Z</published>
    <updated>2021-05-28T07:19:03.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><span id="more"></span><h2 id="POSTS-TODO"><a href="#POSTS-TODO" class="headerlink" title="POSTS_TODO"></a>POSTS_TODO</h2><ul><li><input disabled="" type="checkbox"> rocketmq负载均衡代码</li><li><input disabled="" type="checkbox"> rocketmq消息可靠性消费重试代码</li><li><input disabled="" type="checkbox"> jekins安装和使用<ul><li><input disabled="" type="checkbox"> jekins安装过程</li><li><input disabled="" type="checkbox"> jekins基本使用</li></ul></li></ul><hr><h2 id="DRAFTS-TODO"><a href="#DRAFTS-TODO" class="headerlink" title="DRAFTS_TODO"></a>DRAFTS_TODO</h2><ul><li><input disabled="" type="checkbox"> IO</li><li><input disabled="" type="checkbox"> kafka简介</li><li><input disabled="" type="checkbox"> rocketmq-Broker启动流程</li><li><input disabled="" type="checkbox"> rocketmq-NameServer启动流程</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h1&gt;</summary>
    
    
    
    <category term="todo" scheme="http://linqiankun.gitee.io/hexoblog/categories/todo/"/>
    
    
    <category term="todo" scheme="http://linqiankun.gitee.io/hexoblog/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq消息可靠性</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/28/md/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/28/md/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/</id>
    <published>2021-05-28T02:48:52.000Z</published>
    <updated>2021-05-31T08:32:28.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息重试"><a href="#消息重试" class="headerlink" title="消息重试"></a>消息重试</h1><p>&emsp;&emsp;指的是消费者消费消息失败后，mq需要让消费者重新消费一次。</p><span id="more"></span><p>&emsp;&emsp;只有消费模式处于集群模式下时，才会有重试机制，广播模式下是没有重试机制的。<br>&emsp;&emsp;消费者消费消息失败通常有以下两种情况：</p><ol><li>消息的原因，反序列化失败，消息本身数据无法处理等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li><li>消费者依赖的下游服务不可用，遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li></ol><p>&emsp;&emsp;RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。<br>&emsp;&emsp;考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。<br>&emsp;&emsp;RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p><p>&emsp;&emsp;实际上，以下情况会触发消息重试：</p><ol><li>业务消费方返回ConsumeConcurrentlyStatus.RECONSUME_LATER。</li><li>业务消费方返回null。</li><li>业务消费方抛出异常。</li></ol><p>&emsp;&emsp;对于抛出异常的情况，只要我们在业务逻辑中显式抛出异常或者非显式抛出异常，broker也会重新投递消息，如果业务对异常做了捕获，那么该消息将不会发起重试。因此对于需要重试的业务，消费方在捕获异常时要注意返回ConsumeConcurrentlyStatus.RECONSUME_LATER或null，输出日志并打印当前重试次数。推荐返回ConsumeConcurrentlyStatus.RECONSUME_LATER。</p><p>&emsp;&emsp;RocketMQ可在broker.conf文件中配置Consumer端的重试次数和重试时间间隔，也可以在代码里控制重试次数。</p><h2 id="重试逻辑"><a href="#重试逻辑" class="headerlink" title="重试逻辑"></a>重试逻辑</h2><p>&emsp;&emsp;rocketmq使用时间衰减策略，进行重试。<br>&emsp;&emsp;时间间隔可以为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">messageDelayLevel</span>=<span class="string">1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;重试逻辑：</p><ol><li>首先判断消费端有没有显式设置最大重试次数，如果没有就默认16次。</li><li>当消息发送失败，mq会发起消费重试。</li><li>判断消息当前重试次数是否等于大于最大重试次数，如果达到，或者配置的次数小于0，获取死信队列，将超时的消息投递至死信队列中。</li><li>正常需要重试的消息，将采用延时消息的模式进行重试。将新的延时消息（就是原来的需要重试的消息）重新刷盘。采用定时任务进行投递。</li></ol><p>&emsp;&emsp;对于重试的消息，mq并不会从原队列获取消息，而是创建了一个新的topic进行保存。<br>&emsp;&emsp;对于所有消费者消费失败的消息，rocketMQ都会把重试的消息 重新new出来（即上文提到的MessageExtBrokerInner对象），然后投递到主题SCHEDULE_TOPIC_XXXX下的队列中，然后由定时任务进行调度重试，而重试的周期符合我们在上文中提到的delayLevel周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重试代码还没有搞上来</span><br></pre></td></tr></table></figure><hr><h1 id="消息重投（生产者发送失败，未收到mq的ACK）"><a href="#消息重投（生产者发送失败，未收到mq的ACK）" class="headerlink" title="消息重投（生产者发送失败，未收到mq的ACK）"></a>消息重投（生产者发送失败，未收到mq的ACK）</h1><p>&emsp;&emsp;生产者在发送消息时，同步消息失败则会重投，异步消息失败有重试，oneway没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题。<br>&emsp;&emsp;消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer负载变化也会导致重复消息。<br>&emsp;&emsp;如下方法可以设置消息重试策略：</p><ol><li>retryTimesWhenSendFailed：同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li><li>retryTimesWhenSendAsyncFailed：异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li><li>retryAnotherBrokerWhenNotStoreOK：消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li></ol><hr><h1 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h1><p>&emsp;&emsp;消息重试超过一定次数的消息，将会进入死信队列。<br>&emsp;&emsp;死信队列逻辑：</p><ol><li>首先判断消息当前重试次数是否大于等于16（默认是16），或者消息延迟级别是否小于0。</li><li>只要满足上述的任意一个条件，设置新的topic（死信topic）为：%DLQ%+consumerGroup。</li><li>进行前置属性的添加。<blockquote><p>备份原先topic和队列id等。</p></blockquote></li><li>将死信消息投递到上述步骤2建立的死信topic对应的死信队列中并落盘，使消息持久化。</li></ol><p>&emsp;&emsp;死信队列中的消息需要人工介入处理，在RocketMQ中，可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p><hr><h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><p>&emsp;&emsp;生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。  </p><h2 id="生产者流控"><a href="#生产者流控" class="headerlink" title="生产者流控"></a>生产者流控</h2><p>&emsp;&emsp;生产者流控模式下，不会进行消息重投。  </p><ol><li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。操作系统页缓存繁忙。</li><li>如果开启transientStorePoolEnable == true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</li><li>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</li><li>broker通过拒绝send 请求方式实现流量控制。</li></ol><h2 id="消费者流控"><a href="#消费者流控" class="headerlink" title="消费者流控"></a>消费者流控</h2><p>&emsp;&emsp;消费者流控的结果是降低拉取频率。</p><ol><li>消费者本地缓存消息数量pullThresholdForQueue时，默认1000。</li><li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。</li><li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</li></ol><hr><h1 id="消息堆积"><a href="#消息堆积" class="headerlink" title="消息堆积"></a>消息堆积</h1><p>&emsp;&emsp;个人理解，产生流控时，必定伴随着消息堆积。mq中将消息刷盘，记录消费进度，天然支持消息堆积。</p><hr><h1 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h1><p>&emsp;&emsp;mq支持消息的高可靠，影响可靠性的几种情况：</p><ol><li>Broker非正常关闭</li><li>Broker异常Crash</li><li>OS Crash</li><li>机器掉电，但是能立即恢复供电情况</li><li>机器无法开机（可能是cpu、主板、内存等关键设备损坏）</li><li>磁盘设备损坏</li></ol><p>&emsp;&emsp;1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。<br>&emsp;&emsp;5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。</p><h2 id="消息刷盘"><a href="#消息刷盘" class="headerlink" title="消息刷盘"></a>消息刷盘</h2><p>&emsp;&emsp;消息存储是RocketMQ中最为复杂和最为重要的一部分。</p><p><a href="https://www.yuque.com/jiufenshiren/mvgau4/cn_design#512cc468">消息存储</a></p><h2 id="MessageQuene与ConsumeQuene"><a href="#MessageQuene与ConsumeQuene" class="headerlink" title="MessageQuene与ConsumeQuene"></a>MessageQuene与ConsumeQuene</h2><p>&emsp;&emsp;个人理解，MessageQuene是逻辑上的东西，是将Topic进一步划分之后的字主题，也是消息存储队列。<br>&emsp;&emsp;ConsumeQuene又称为消费逻辑队列，是在文件系统中存在实际的文件的，内存存储者Commitlog中消息的位置（commit offset，消息长度，tag的hashcode值）等相关信息，可以看作是消息的索引文件。<br>&emsp;&emsp;根据ConsumeQuene文件的组织方式，可以看出，相同Topic下相同MessageQuene下的ConsumeQuene文件在相同的位置（相同的文件夹内）。<br>&emsp;&emsp;CommitLog文件存储着所有的消息，名称从0开始，文件名称代表了文件中第一个消息的偏移量，文件名称长度20位，每个大小最大1G。<br>&emsp;&emsp;ConsumeQuene文件，按照topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。这里的queneId就是MessageQuene的id，同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M。可以看作是CommitLog文件按照位置，quene的索引文件。<br>&emsp;&emsp;IndexFile，索引文件，提供了一种按照key或者时间区间查询消息的索引。index文件的存储位置是：$HOME \store\index${fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p><p>&emsp;&emsp;生产者发送消息的过程，会将消息发送到指定的Topic，然后根据负载均衡选择该Topic下的一个MessageQuene，实际上发送消息时，会将消息保存进CommitLog文件，同时会在对应Quene的ConsumeQuene文件中写入索引，也会在Index文件中写入时间索引。<br>&emsp;&emsp;消费者消费时，会根据负载均衡到的MessageQuene定位到具体的文件夹，在根据消息消费进度，确定具体的ConsumeQuene文件，从而在CommitLog文件中查出具体的消息。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;消息重试&quot;&gt;&lt;a href=&quot;#消息重试&quot; class=&quot;headerlink&quot; title=&quot;消息重试&quot;&gt;&lt;/a&gt;消息重试&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;指的是消费者消费消息失败后，mq需要让消费者重新消费一次。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq负载均衡</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/27/md/rocketmq/rocketmq%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/27/md/rocketmq/rocketmq%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</id>
    <published>2021-05-27T09:00:22.000Z</published>
    <updated>2021-05-27T11:46:29.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>&emsp;&emsp;RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。<br>&emsp;&emsp;<a href="https://www.yuque.com/jiufenshiren/mvgau4/cn_design#b59a14cd">官方的解释</a></p><span id="more"></span><h2 id="生产端负载均衡"><a href="#生产端负载均衡" class="headerlink" title="生产端负载均衡"></a>生产端负载均衡</h2><p>&emsp;&emsp;Producer端在发送消息的时候，会先根据Topic找到指定的TopicPublishInfo，在获取了TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列（MessageQueue）进行发送消息。（这里采用轮询）<br>&emsp;&emsp;具体的容错策略均在MQFaultStrategy这个类中定义。这里有一个sendLatencyFaultEnable开关变量，如果开启，在随机递增取模的基础上，再过滤掉not available的Broker代理。<br>&emsp;&emsp;所谓的”latencyFaultTolerance”，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%8F%91%E9%80%81%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="发送端负载均衡"></p><h2 id="消费端负载均衡"><a href="#消费端负载均衡" class="headerlink" title="消费端负载均衡"></a>消费端负载均衡</h2><p>&emsp;&emsp;在RocketMQ中，Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。<br>&emsp;&emsp;在两种基于拉模式的消费方式（Push/Pull）中，均需要Consumer端在知道从Broker端的哪一个消息队列—队列中去获取消息。因此，有必要在Consumer端来做负载均衡，即Broker端中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer消费。<br>&emsp;&emsp;Producer向一些队列轮流发送消息，队列集合称为Topic，Consumer如果做广播消费，则一个consumer实例消费这个Topic对应的所有队列；如果做集群消费，则多个Consumer实例平均消费这个Topic对应的队列集合。<br>&emsp;&emsp;如果有3个队列，2个consumer，那么第一个Consumer消费2个队列，第二consumer消费1个队列。这里采用的就是平均分配策略，它类似于我们的分页，TOPIC下面的所有queue就是记录，Consumer的个数就相当于总的页数，那么每页有多少条记录，就类似于某个Consumer会消费哪些队列。<br>&emsp;&emsp;通过这样的策略来达到大体上的平均消费，这样的设计也可以很方面的水平扩展Consumer来提高消费能力。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E6%B6%88%E8%B4%B9%E7%AB%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.png" alt="消费端负载均衡"></p><h3 id="负载均衡过程"><a href="#负载均衡过程" class="headerlink" title="负载均衡过程"></a>负载均衡过程</h3><p>&emsp;&emsp;客户端负载均衡过程，实际上就是把某个topic下的所有MessageQuene按照一定的算法平均分给各个consunmer的过程。</p><p>//TODO</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码还没搞上来</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;负载均衡&quot;&gt;&lt;a href=&quot;#负载均衡&quot; class=&quot;headerlink&quot; title=&quot;负载均衡&quot;&gt;&lt;/a&gt;负载均衡&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。&lt;br&gt;&amp;emsp;&amp;emsp;&lt;a href=&quot;https://www.yuque.com/jiufenshiren/mvgau4/cn_design#b59a14cd&quot;&gt;官方的解释&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq消息消费</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/27/md/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/27/md/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/</id>
    <published>2021-05-27T07:50:20.000Z</published>
    <updated>2021-05-27T11:32:41.832Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息获取"><a href="#消息获取" class="headerlink" title="消息获取"></a>消息获取</h1><p>&emsp;&emsp;rocketmq中consumer有两种消息获取模式，分别是pull和push。  </p><span id="more"></span><p>&emsp;&emsp;push模式指MQ主动向消费端推送消息。<br>&emsp;&emsp;pull模式指消费端消费时主动到MQ拉取消息。<br>&emsp;&emsp;本质上，两种模式都是消费端主动到MQ拉取消息，push模式只不过是pull模式的封装。其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。<br>&emsp;&emsp;Consumer端每隔一段时间主动向broker发送拉消息请求，broker在收到Pull请求后，如果有消息就立即返回数据，Consumer端收到返回的消息后，再回调消费者设置的Listener方法。如果broker在收到Pull请求时，消息队列里没有数据，broker端会阻塞请求直到有数据传递或超时才返回。<br>&emsp;&emsp;当然，Consumer端是通过一个线程将阻塞队列LinkedBlockingQueue<PullRequest>中的PullRequest发送到broker拉取消息，以防止Consumer一致被阻塞。而Broker端，在接收到Consumer的PullRequest时，如果发现没有消息，就会把PullRequest扔到ConcurrentHashMap中缓存起来。<br>&emsp;&emsp;broker在启动时，会启动一个线程不停的从ConcurrentHashMap取出PullRequest检查，直到有数据返回。</p><hr><h1 id="消息消费模式"><a href="#消息消费模式" class="headerlink" title="消息消费模式"></a>消息消费模式</h1><p>&emsp;&emsp;Consumer端有两种消息消费模式，集群消费模式和广播消费模式。<br>&emsp;&emsp;集群：消费者集群：使用相同Group ID的订阅者属于同一个集群。同一个集群下的订阅者消费逻辑必须完全一致（包括 Tag 的使用），这些订阅者在逻辑上可以认为是一个消费节点，这些属于一个订阅者组。</p><h2 id="集群消费模式"><a href="#集群消费模式" class="headerlink" title="集群消费模式"></a>集群消费模式</h2><p>&emsp;&emsp;当使用集群消费模式时，MQ认为任意一条消息只需要被集群内的任意一台消费者处理即可。<br>&emsp;&emsp;集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E9%9B%86%E7%BE%A4%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F.png" alt="集群模式消费"></p><h2 id="广播消费模式"><a href="#广播消费模式" class="headerlink" title="广播消费模式"></a>广播消费模式</h2><p>&emsp;&emsp;广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。<br>&emsp;&emsp;当使用广播消费模式时，MQ会每条消息推送给集群内所有注册过的机器消费，保证每台机器至少消费一次。<br>&emsp;&emsp;一条消息被多个Consumer消费，即使这些Consumer属于同一个Consumer Group，消息也会被Consumer Group中的每个Consumer都消费一次。在广播消费中的Consumer Group概念可以认为在消息划分方面无意义。　</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%BC%8F.png" alt="广播模式消费"></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><ol><li>消费端集群化部署，每条消息只消费一次。</li><li>消费进度维护再MQ中，更加可靠。</li><li>每一条消息都只会被分发到一台机器上处理。如果需要被集群下的每一台机器都处理，请使用广播模式。</li><li>不保证每一次失败重试的消息路由到同一台机器上，因此处理消息时不应该做任何确定性假设。</li></ol><h3 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h3><ol><li>广播模式下不支持顺序消息。</li><li>广播模式下不支持重置消费位点。</li><li>每条消息都需要被相同逻辑的多台机器处理。</li><li>消费进度在客户端维护，出现重复的概率稍大于集群模式。</li><li>消息队列RocketMQ保证每条消息至少被每台客户端消费一次，但是并不会对消费失败的消息进行失败重投，因此业务方需要关注消费失败的情况。</li><li>客户端每一次重启都会从最新消息消费。客户端在被停止期间发送至服务端的消息将会被自动跳过，请谨慎选择。</li><li>每条消息都会被大量的客户端重复处理，因此推荐尽可能使用集群模式。</li><li>目前仅 Java 客户端支持广播模式。</li><li>广播模式下MQ不维护消费进度，所以消息队列 RocketMQ 控制台不支持消息堆积查询、消息堆积报警和订阅关系查询功能。</li></ol><h3 id="使用集群模式模拟广播模式"><a href="#使用集群模式模拟广播模式" class="headerlink" title="使用集群模式模拟广播模式"></a>使用集群模式模拟广播模式</h3><p>&emsp;&emsp;将原来同一个消费者组的下消费者，拆分成每个消费者一个消费者组，这样就有很多个消费者组。<br>&emsp;&emsp;每个消费者组都订阅需要发送的消息，这样消息会发给每个消费者组，发给了每台机器，都可以消费。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E5%B9%BF%E6%92%AD.png" alt="集群模式模拟广播模式"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;消息获取&quot;&gt;&lt;a href=&quot;#消息获取&quot; class=&quot;headerlink&quot; title=&quot;消息获取&quot;&gt;&lt;/a&gt;消息获取&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;rocketmq中consumer有两种消息获取模式，分别是pull和push。  &lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq消息分类</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/26/md/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E5%88%86%E7%B1%BB/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/26/md/rocketmq/rocketmq%E6%B6%88%E6%81%AF%E5%88%86%E7%B1%BB/</id>
    <published>2021-05-26T11:17:11.000Z</published>
    <updated>2021-05-27T08:32:37.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h1><p>&emsp;&emsp;message就是要传输的信息，一条消息必须有一个主题（Topic）。</p><span id="more"></span><h2 id="从特点区分"><a href="#从特点区分" class="headerlink" title="从特点区分"></a>从特点区分</h2><p>&emsp;&emsp;mq中的消息从特点区分可以分为三类：同步消息，异步消息，单向消息。</p><h3 id="同步消息"><a href="#同步消息" class="headerlink" title="同步消息"></a>同步消息</h3><p>&emsp;&emsp;同步发送是指消息发送方发出数据后，会阻塞直到MQ服务方发回响应消息。  </p><h3 id="异步消息"><a href="#异步消息" class="headerlink" title="异步消息"></a>异步消息</h3><p>&emsp;&emsp;异步发送是指发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。<br>&emsp;&emsp;MQ 的异步发送，需要用户实现异步发送回调接口（SendCallback），在执行消息的异步发送时，应用不需要等待服务器响应即可直接返回，通过回调接口接收服务器响应，并对服务器的响应结果进行处理。</p><h3 id="单向消息"><a href="#单向消息" class="headerlink" title="单向消息"></a>单向消息</h3><p>&emsp;&emsp;单向（Oneway）发送特点为只负责发送消息，不等待服务器回应且没有回调函数触发，即只发送请求不等待应答。此方式发送消息的过程耗时非常短，一般在微秒级别。这种消息常用于日志收集。</p><h2 id="从共功能分"><a href="#从共功能分" class="headerlink" title="从共功能分"></a>从共功能分</h2><p>&emsp;&emsp;从使用功能也可以分为多种消息，最广为人知的就是事务消息。<br>&emsp;&emsp;消息共有以下分类：</p><ol><li>普通消息</li><li>顺序消息</li><li>广播消息</li><li>延时消息</li><li>批量消息</li><li>事务消息</li></ol><h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>&emsp;&emsp;消息有序指的是一类消息消费时，能按照发送的顺序来消费。</p><h3 id="广播消息"><a href="#广播消息" class="headerlink" title="广播消息"></a>广播消息</h3><p>&emsp;&emsp;广播消息与普通消息不同的是，普通消息只会由消费者组中负载均衡到消息所在MessageQuene的消费者消费，而广播消息由消费者组中的所有消费者消费。</p><h3 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h3><p>&emsp;&emsp;<a href="https://www.yuque.com/jiufenshiren/mvgau4/cn_features#19cff416">定时消息</a><br>&emsp;&emsp;定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。<br>&emsp;&emsp;broker有配置项messageDelayLevel，可以配置不同的DelayLevel延迟不同的时间。<br>&emsp;&emsp;定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。<br>&emsp;&emsp;需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p><h3 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h3><p>&emsp;&emsp;<a href="https://www.yuque.com/jiufenshiren/mvgau4/cn_design#dc145683">官方的事务消息解释</a><br>&emsp;&emsp;RocketMQ事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ的事务消息提供类似X/Open XA的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/rocketmq_design_10.png" alt="事务消息大概流程"></p><p>&emsp;&emsp;事务消息的大概流程：</p><ol><li>发送一个事务的半消息。</li><li>服务端将消息持久化成功之后，向发送方ACK确认消息已经发送成功，此时消息为半消息。</li><li>开始执行本地事务，如果发送消息失败，本地事务不执行。</li><li>根据本地事务向mq进行二次提交，Commit或rollback，commit会生成消息索引，mq收到Commit状态则将半消息标记为可投递，订阅方最终将收到该消息；服务端收到Rollback状态则删除半消息，订阅方将不会接受该消息。</li></ol><p>&emsp;&emsp;补偿流程：补偿流程用于mq没有收到发送者二次提交的情况下：</p><ol><li>对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”。（最大回查15次）</li><li>Producer收到回查消息，检查回查消息对应的本地事务的状态。</li><li>根据本地事务状态，重新Commit或者Rollback。</li></ol><p>&emsp;&emsp;注意：</p><ol><li>需要消息回查接口。</li><li>不能保证消息幂等，需要消费方手动控制，在消费者未ack情况下，可能重复消费。</li></ol><hr><h1 id="消息问题"><a href="#消息问题" class="headerlink" title="消息问题"></a>消息问题</h1><p><a href="https://www.cnblogs.com/duanxz/p/6053598.html">RocketMQ之二：分布式开放消息系统RocketMQ的原理与实践（消息的顺序问题、重复问题、可靠消息/事务消息）</a></p><h2 id="消息顺序问题"><a href="#消息顺序问题" class="headerlink" title="消息顺序问题"></a>消息顺序问题</h2><p>&emsp;&emsp;有着一定顺序的消息，一般需要发送到同一个MessageQuene，因为MessageQuene采用先进先出队列，消费方就可以按照发送的顺序进行消费。<br>&emsp;&emsp;可以自定义MessageQueueSelector实现的算法来选择一个队列。<br>&emsp;&emsp;mq顺序消息中，mq需要收到消费方对上一个消息的确认ACK后才能投递下一个消息，这个会带来上一个消息ack收不到的情况下，会造成重复消费。</p><h2 id="消息重复问题"><a href="#消息重复问题" class="headerlink" title="消息重复问题"></a>消息重复问题</h2><p>&emsp;&emsp;mq中并没有处理消息的重复问题，需要消费方自己实现幂等，解决消息重复消费的问题。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;消息&quot;&gt;&lt;a href=&quot;#消息&quot; class=&quot;headerlink&quot; title=&quot;消息&quot;&gt;&lt;/a&gt;消息&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;message就是要传输的信息，一条消息必须有一个主题（Topic）。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq生产消费流程</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/26/md/rocketmq/rocketmq%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/26/md/rocketmq/rocketmq%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E6%B5%81%E7%A8%8B/</id>
    <published>2021-05-26T06:07:32.000Z</published>
    <updated>2021-05-31T06:32:09.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rocketmq工作流程"><a href="#Rocketmq工作流程" class="headerlink" title="Rocketmq工作流程"></a>Rocketmq工作流程</h1><p>&emsp;&emsp;rocketmq中几乎每个节点都可以集群部署，namesrv，broker，producer，consumer。</p><span id="more"></span><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/rocketmq_architecture_3.png" alt="部署结构"></p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/mq%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2%E4%BF%A1%E6%81%AF.png" alt="部署后节点保存的信息"></p><h2 id="网络部署特点"><a href="#网络部署特点" class="headerlink" title="网络部署特点"></a>网络部署特点</h2><ol><li>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</li><li>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。</li><li>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</li><li>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。</li></ol><h2 id="集群工作流程"><a href="#集群工作流程" class="headerlink" title="集群工作流程"></a>集群工作流程</h2><ol><li>启动NameServer，NameServer启动后会监听端口，等待Broker，Producer，Consumer连上来，相当于一个路由控制中心，类似于dubbo中zk发挥的作用。</li><li>Broker启动，跟所有NameServer保持长连接，定时发送心跳包。心跳包包含当前Broker信息，以及存储所有Topic的信息。注册成功后，NameServer集群中就有Topic和Broker的映射关系。</li><li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li><li>Producer发送消息，启动时先跟NameServer中的一台建立长连接，并从其中获取当前发送的Topic存在那些Broker上，从Topic中的MessageQuene中选取一个（采用轮询），然后与队列所在Broker建立长连接从而向Broker发送消息。</li><li>Consumer跟Producer一样，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。只由BrokerId=1的Slave Broker才会提供读服务。<blockquote><p>一个Topic下的所有MessageQuene会负载均衡到消费者组中的每一台机器，每一台机器负责几个队列，保证均衡，这里要求，消费者组中的机器数少于队列数。</p></blockquote></li></ol><h2 id="Recketmq完整通信流程"><a href="#Recketmq完整通信流程" class="headerlink" title="Recketmq完整通信流程"></a>Recketmq完整通信流程</h2><p>&emsp;&emsp;Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master建立长连接，且定时向Broker发送心跳。<br>&emsp;&emsp;Producer只能将消息发送到Broker master，但是Consumer则不一样，它同时和提供Topic服务的Master和Slave建立长连接，既可以从Broker Master订阅消息，也可以从Broker Slave订阅消息。</p><p><a href="https://juejin.cn/post/6844904008629354504#heading-25">《浅入浅出》-RocketMQ</a></p><ol><li>Broker启动后需要完成一次将自己注册至NameServer的操作；随后每隔30s时间定时向NameServer上报Topic路由信息。</li><li>消息生产者Producer作为客户端发送消息时候，需要根据消息的Topic从本地缓存的TopicPublishInfoTable获取路由信息。如果没有则更新路由信息会从NameServer上重新拉取，同时Producer会默认每隔30s向NameServer拉取一次路由信息。</li><li>消息生产者Producer根据2）中获取的路由信息选择一个队列（MessageQueue）进行消息发送；Broker作为消息的接收者接收消息并落盘存储。</li><li>消息消费者Consumer根据2）中获取的路由信息，并再完成客户端的负载均衡后，选择其中的某一个或者某几个消息队列来拉取消息并进行消费。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Rocketmq工作流程&quot;&gt;&lt;a href=&quot;#Rocketmq工作流程&quot; class=&quot;headerlink&quot; title=&quot;Rocketmq工作流程&quot;&gt;&lt;/a&gt;Rocketmq工作流程&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;rocketmq中几乎每个节点都可以集群部署，namesrv，broker，producer，consumer。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
    <category term="分布式" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq概念总结</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/25/md/rocketmq/rocketmq%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/25/md/rocketmq/rocketmq%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/</id>
    <published>2021-05-25T11:20:54.000Z</published>
    <updated>2021-05-26T11:50:32.781Z</updated>
    
    <content type="html"><![CDATA[<h1 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h1><p><a href="https://github.com/apache/rocketmq/tree/master/docs/cn">官方文档看看挺好的</a><br>&emsp;&emsp;rocketmq主要有四大核心组成部分：NameServer，Broker，Producer，Consumer四部分。  </p><span id="more"></span><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/rocketmq_architecture_1.jpg" alt="架构设计"></p><h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><p>&emsp;&emsp;主要负责对源数据的管理，包括了对于Topic和路由信息的管理。  </p><blockquote><p>&emsp;&emsp;NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。<br>&emsp;&emsp;NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer，Consumer仍然可以动态感知Broker的路由的信息。 </p></blockquote><p>&emsp;&emsp;NameServer是一个功能齐全的服务器，其角色类似Dubbo中的Zookeeper，但NameServer与Zookeeper相比更轻量。主要是因为每个NameServer节点互相之间是独立的，没有任何信息交互。<br>&emsp;&emsp;NameServer压力不会太大，平时主要开销是在维持心跳和提供Topic-Broker的关系数据。<br>&emsp;&emsp;Broker向NameServer发心跳时，会带上当前自己所负责的所有Topic信息，如果Topic个数太多（万级别），会导致一次心跳中，就Topic的数据就几十M，网络情况差的话， 网络传输失败，心跳失败，导致NameServer误认为Broker心跳失败。<br>&emsp;&emsp;NameServer被设计成几乎无状态的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是一个伪集群。<br>&emsp;&emsp;每个 Broker 在启动的时候会到 NameServer 注册，Producer 在发送消息前会根据 Topic 到 NameServer 获取到 Broker 的路由信息，Consumer 也会定时获取 Topic 的路由信息。</p><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><p>&emsp;&emsp;消息中转角色，负责存储消息，转发消息。  </p><blockquote><p>Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker包含了以下几个重要子模块。</p><ol><li>Remoting Module：整个Broker的实体，负责处理clients端的请求。</li><li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息。</li><li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</li><li>HA service：高可用服务，提供Master Broker和Slave Broker之间的数据同步功能。</li><li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li></ol></blockquote><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/broker.png" alt="Broker结构"></p><p>&emsp;&emsp;Broker是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接和心跳，并会定时将topic的信息注册到NameServer，底层的通信和连接都是通过Netty实现的。<br>&emsp;&emsp;Broker负责消息存储，以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。<br>&emsp;&emsp;支持上亿的消息堆积能力，同时可以严格保证消息的有序性。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/topic%E4%B8%8Ebroker.png" alt="Topic与Broker关系"></p><h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><p>&emsp;&emsp;消息生产者，负责产生消息。</p><blockquote><p>消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p></blockquote><p>&emsp;&emsp;Producer由用户进行分布式部署，消息由Producer通过多种负载均衡模式发送到Broker集群，发送低延时，支持快速失败。  </p><p>&emsp;&emsp;rocketmq提供了三种消息发送方式：<strong>同步，异步，单向</strong>。</p><ol><li>同步发送：同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。一般用于重要通知消息，例如重要通知邮件、营销短信。</li><li>异步发送：异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包，一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。</li><li>单向发送：单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发，适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。</li></ol><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>&emsp;消息消费者，负责消费消息，一般时下游业务系统。  </p><blockquote><p>消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</p></blockquote><p>&emsp;&emsp;Consumer也由用户部署，支持PUSH和PULL两种消费模式，支持集群消费和广播消息，提供实时的消息订阅机制。</p><ol><li>PUSH：推送型消费者（Push Consumer）封装了消息的拉取、消费进度和其他的内部维护工作，将消息到达时执行的回调接口留给用户应用程序来实现。所以 Push 称为被动消费类型，但从实现上看还是从消息服务器中拉取消息，不同于 Pull 的是 Push 首先要注册消费监听器，当监听器处触发后才开始消费消息。</li><li>PULL：拉取型消费者（Pull Consumer）主动从消息服务器拉取信息，只要批量拉取到消息，用户应用就会启动消费过程，所以 Pull 称为主动消费型。</li></ol><hr><h1 id="消息相关概念"><a href="#消息相关概念" class="headerlink" title="消息相关概念"></a>消息相关概念</h1><h2 id="Message（消息）"><a href="#Message（消息）" class="headerlink" title="Message（消息）"></a>Message（消息）</h2><p>&emsp;&emsp;message就是要传输的信息，一条消息必须有一个主题（Topic）。<br>&emsp;&emsp;一条消息也可以拥有一个可选的标签（Tag）和额处的键值对，它们可以用于设置一个业务Key并在Broker上查找此消息以便在开发期间查找问题。<br>&emsp;&emsp;一个Topic可以分散在多个Broker上，也可以在一个Broker上。<br>&emsp;&emsp;消息分为三种：同步消息，异步消息，单向消息。</p><h2 id="Topic（主题）"><a href="#Topic（主题）" class="headerlink" title="Topic（主题）"></a>Topic（主题）</h2><p>&emsp;&emsp;可以看做消息的分类，它是消息的第一级类型。<br>&emsp;&emsp;Topic与生产者和消费者的关系非常松散，一个Topic可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的Topic发送消息。一个Topic也可以被多个或者1个消费者订阅。</p><h2 id="Tag（标签）"><a href="#Tag（标签）" class="headerlink" title="Tag（标签）"></a>Tag（标签）</h2><p>&emsp;&emsp;以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。<br>&emsp;&emsp;使用标签，同一业务模块不同目的的消息就可以用相同Topic而不同的Tag来标识，一条消息可以没有Tag。</p><h2 id="Group（分组）"><a href="#Group（分组）" class="headerlink" title="Group（分组）"></a>Group（分组）</h2><p>&emsp;&emsp;一个分组可以订阅多个Topic。<br>&emsp;&emsp;分组分为生产者分组和消费者分组，一般同一个服务作为一个组，一个组生产或消费的消息都是一致的。</p><h2 id="Quene（队列）"><a href="#Quene（队列）" class="headerlink" title="Quene（队列）"></a>Quene（队列）</h2><p>&emsp;&emsp;每个Queue内部是有序的，在RocketMQ中分为读和写两种队列，一般来说读写队列数量一致，如果不一致就会出现很多问题。</p><h2 id="MessageQuene（消息队列）"><a href="#MessageQuene（消息队列）" class="headerlink" title="MessageQuene（消息队列）"></a>MessageQuene（消息队列）</h2><p>&emsp;&emsp;一个主题被划分为多个子主题，就是消息队列。<br>&emsp;&emsp;一个Topic下可以设置多个消息队列，发送消息时执行该消息的Topic，RocketMQ会轮询该Topic下的所有队列将消息发出去，只会发送到一个MessageQuene中。<br>&emsp;&emsp;消息的物理管理单位。一个Topic下可以有多个Queue，Queue的引入使得消息的存储可以分布式集群化，具有了水平扩展能力。</p><h2 id="Offset"><a href="#Offset" class="headerlink" title="Offset"></a>Offset</h2><p>&emsp;&emsp;在RocketMQ中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用Offset来访问，Offset为long类型，64位，理论上在100年内不会溢出，所以认为是长度无限。<br>&emsp;&emsp;也可以认为Message Queue是一个长度无限的数组，Offset就是下标。</p><h2 id="消息消费模式"><a href="#消息消费模式" class="headerlink" title="消息消费模式"></a>消息消费模式</h2><p>&emsp;&emsp;分为两种，集群消费模式，广播消费模式。  </p><h3 id="集群消费模式"><a href="#集群消费模式" class="headerlink" title="集群消费模式"></a>集群消费模式</h3><p>&emsp;&emsp;默认情况下就是集群消费，该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。</p><h3 id="广播消费模式"><a href="#广播消费模式" class="headerlink" title="广播消费模式"></a>广播消费模式</h3><p>&emsp;&emsp;而广播消费消息会发给消费者组中的每一个消费者进行消费，一个消息会被多次消费。</p><h2 id="Message-Order"><a href="#Message-Order" class="headerlink" title="Message Order"></a>Message Order</h2><p>&emsp;&emsp;消息消费顺序，也有两种：顺序消费，并行消费。</p><h3 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h3><p>&emsp;&emsp;顺序消费表示消息消费的顺序同生产者为每个消息队列发送的顺序一致，所以如果正在处理全局顺序是强制性的场景，需要确保使用的主题只有一个消息队列。</p><h3 id="并行消费"><a href="#并行消费" class="headerlink" title="并行消费"></a>并行消费</h3><p>&emsp;&emsp;并行消费不再保证消息顺序，消费的最大并行数量受每个消费者客户端指定的线程池限制。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;核心组成&quot;&gt;&lt;a href=&quot;#核心组成&quot; class=&quot;headerlink&quot; title=&quot;核心组成&quot;&gt;&lt;/a&gt;核心组成&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/apache/rocketmq/tree/master/docs/cn&quot;&gt;官方文档看看挺好的&lt;/a&gt;&lt;br&gt;&amp;emsp;&amp;emsp;rocketmq主要有四大核心组成部分：NameServer，Broker，Producer，Consumer四部分。  &lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
  </entry>
  
  <entry>
    <title>异常的三次握手四次挥手</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/21/md/internet/%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/21/md/internet/%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</id>
    <published>2021-05-21T10:43:17.000Z</published>
    <updated>2021-05-24T08:09:40.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;TCP作为一个靠谱的协议，在传输数据的前后，需要在双端之间建立连接，并在双端各自维护连接的状态。<br>&emsp;&emsp;建立连接前，TCP会通过三次握手来保证双端状态正确，然后就可以正常传输数据了。当数据传输完成，需要断开连接的时候，TCP会通过四次握手来完成双端的断连，并回收各自的资源。<br>&emsp;&emsp;这个过程中也会产生各种问题，有因网络原因造成的也有其他原因造成的。一般来说主要就是丢包的问题，基本就是超时重传等来保证TCP的可靠性。</p><span id="more"></span><p><a href="https://network.51cto.com/art/202002/610542.htm">TCP异常</a></p><hr><h1 id="三次握手中的问题"><a href="#三次握手中的问题" class="headerlink" title="三次握手中的问题"></a>三次握手中的问题</h1><h2 id="客户端第一个SYN包丢失"><a href="#客户端第一个SYN包丢失" class="headerlink" title="客户端第一个SYN包丢失"></a>客户端第一个SYN包丢失</h2><p>&emsp;&emsp;如果客户端的第一个ACK包丢失，服务器无法收到这个包，不会做任何事情。<br>&emsp;&emsp;而在TCP协议中，某端的一组「请求-应答」中，在一定时间范围内，只要没有收到应答的「ACK」包，无论是请求包对方没有收到，还是对方的应答包自己没有收到，均认为是丢包了，都会触发超时重传机制。<br>&emsp;&emsp;此时客户端会重传丢失的SYN包。</p><h2 id="服务端收到SYNd返回的SYN-ACK包丢失"><a href="#服务端收到SYNd返回的SYN-ACK包丢失" class="headerlink" title="服务端收到SYNd返回的SYN+ACK包丢失"></a>服务端收到SYNd返回的SYN+ACK包丢失</h2><p>&emsp;&emsp;此时服务端已经收到客户端的数据，并且发出了对于改信息的回复。<br>&emsp;&emsp;这个问题站在客户端而言，无法区分是服务端没有收到第一次的SYN包，还是自己没有收到回复信息，只能等待一段时间后重新发送SYN包，这和上面的情况就一样了。<br>&emsp;&emsp;对于服务端，发送了SYN+ACK包后，无法等到对方的确认ACK信息，也只能对这个SYN+ACK包进行重传。<br>&emsp;&emsp;由于客户端的重传，服务端会收到这个重传的SYN包，此时会针对这个新的SYN包立即发送SYN+ACK信息。</p><h2 id="客户端收到SYN-ACK返回的ACK包丢失"><a href="#客户端收到SYN-ACK返回的ACK包丢失" class="headerlink" title="客户端收到SYN+ACK返回的ACK包丢失"></a>客户端收到SYN+ACK返回的ACK包丢失</h2><p>&emsp;&emsp;如果最后一个ACK包丢了，服务端因为收不到ACK会走重传机制，而客户端此时进入ESTABLISHED状态。<br>&emsp;&emsp;多数情况下，客户端进入ESTABLISHED状态后，则认为连接已建立，会立即发送数据。但是服务端因为没有收到最后一个ACK包，依然处于SYN-RCVD状态。<br>&emsp;&emsp;所以当服务端处于SYN-RCVD状态下时，接收到客户端真实发送来的数据包时，会认为连接已建立，并进入ESTABLISHED状态。<br>&emsp;&emsp;也有地方认为当服务端处于SYN-RCVD状态下，收到客户端的数据包后，会直接回复RST包响应，表示服务端错误，并进入CLOSE状态。<br>&emsp;&emsp;实际情况下，当客户端在ESTABLISHED状态下，开始发送数据包时，会携带上一个ACK的确认序号，所以哪怕客户端响应的ACK包丢了，服务端在收到这个数据包时，能够通过包内ACK的确认序号，正常进入ESTABLISHED状态。</p><h2 id="客户端故意不发最后一次ACK包"><a href="#客户端故意不发最后一次ACK包" class="headerlink" title="客户端故意不发最后一次ACK包"></a>客户端故意不发最后一次ACK包</h2><p>-0<br>&emsp;&emsp;如果客户端是恶意的，在发送SYN包后，并收到SYN+ACK后就不回复了，那么服务端此时处于一种半连接的状态，虽然服务端会通过tcp_synack_retries配置重试的次数，不会无限等待下去，但是这也是有一个时间周期的。<br>&emsp;&emsp;如果短时间内存在大量的这种恶意连接，对服务端来说压力就会很大，这就是所谓的SYN FLOOD攻击。</p><hr><h1 id="四次挥手中的问题"><a href="#四次挥手中的问题" class="headerlink" title="四次挥手中的问题"></a>四次挥手中的问题</h1><h2 id="客户端断开连接的FIN包丢失"><a href="#客户端断开连接的FIN包丢失" class="headerlink" title="客户端断开连接的FIN包丢失"></a>客户端断开连接的FIN包丢失</h2><p>&emsp;&emsp;这种情况下，会触发超时重传机制，不会去考虑是自己发出的包丢失，还是无法收到对方发来的恢复，直到关闭连接。</p><h2 id="服务端第一次返回的ACK包丢失"><a href="#服务端第一次返回的ACK包丢失" class="headerlink" title="服务端第一次返回的ACK包丢失"></a>服务端第一次返回的ACK包丢失</h2><p>&emsp;&emsp;这种情况下，客户端无法收到服务端返回的ACK包，会触发重传机制，重传FIN包。<br>&emsp;&emsp;而服务器收到重传的FIN包后，会立即在重传对FIN包的ACK包。<br>&emsp;&emsp;而此时服务器已经进入CLOSED-WAIT状态，开始做断开连接前的准备工作。当准备好之后，会回复FIN+ACK，这个消息是携带了之前ACK的响应序号的，这就是第三次挥手的包。</p><h2 id="服务器发送的FIN-ACK包丢失"><a href="#服务器发送的FIN-ACK包丢失" class="headerlink" title="服务器发送的FIN+ACK包丢失"></a>服务器发送的FIN+ACK包丢失</h2><p>&emsp;&emsp;这是第三次挥手的包丢失了，此时客户端有两种情况，要么处于FIN-WAIT-2状态(之前的 ACK 也丢了)，会一直等待；要么处于TIME-WAIT状态，会等待 2MSL 时间。<br>&emsp;&emsp;而服务端则收不到对应的ACK确认包，则会进行超时重传。</p><h2 id="客户端最后返回的ACK包丢失"><a href="#客户端最后返回的ACK包丢失" class="headerlink" title="客户端最后返回的ACK包丢失"></a>客户端最后返回的ACK包丢失</h2><p>&emsp;&emsp;客户端在回复ACK后，会进入TIME-WAIT状态，开始长达2MSL的等待，服务端因为没有收到ACK的回复，会重试一段时间，直到服务端重试超时后主动断开。<br>&emsp;&emsp;或者等待新的客户端接入后，收到服务端重试的FIN消息后，回复RST消息，在收到RST消息后，复位服务端的状态。</p><h2 id="客户端收到ACK后服务端跑路"><a href="#客户端收到ACK后服务端跑路" class="headerlink" title="客户端收到ACK后服务端跑路"></a>客户端收到ACK后服务端跑路</h2><p>&emsp;&emsp;客户端在收到ACK后，进入了FIN-WAIT-2状态，等待服务端发来的FIN包，而如果服务端跑路了，这个包永远都等不到。<br>&emsp;&emsp;在TCP协议中，是没有对这个状态的处理机制的。但是协议不管，系统来凑，操作系统会接管这个状态，在一段时间后，直接进行客户端关闭，这中间会用心跳等进行检测。</p><h2 id="客户端收到ACK后客户端跑路"><a href="#客户端收到ACK后客户端跑路" class="headerlink" title="客户端收到ACK后客户端跑路"></a>客户端收到ACK后客户端跑路</h2><p>&emsp;&emsp;客户端收到ACK后直接跑路，服务端后续在发送的FIN+ACK就没有接收端，也就不会得到回复，会不断的走TCP的超时重试的机制，此时服务端处于LAST-ACK状态。<br>&emsp;&emsp;这种情况下，有两种情况：在超过一定时间后，服务器直接进行关闭，这种类似于客户端的关闭；另一种情况则是收到客户端的RST消息，关闭连接。<br>&emsp;&emsp;RST消息是一种重置消息，表示当前错误了，应该回到初始的状态。如果客户端跑路后有新的客户端接入，会在此发送SYN以期望建立连接，此时这个SYN将被忽略，并直接回复FIN+ACK消息，新客户端在收到FIN消息后是不会认的，并且会回复一个RST消息。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;TCP作为一个靠谱的协议，在传输数据的前后，需要在双端之间建立连接，并在双端各自维护连接的状态。&lt;br&gt;&amp;emsp;&amp;emsp;建立连接前，TCP会通过三次握手来保证双端状态正确，然后就可以正常传输数据了。当数据传输完成，需要断开连接的时候，TCP会通过四次握手来完成双端的断连，并回收各自的资源。&lt;br&gt;&amp;emsp;&amp;emsp;这个过程中也会产生各种问题，有因网络原因造成的也有其他原因造成的。一般来说主要就是丢包的问题，基本就是超时重传等来保证TCP的可靠性。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="TCP" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E7%BD%91%E7%BB%9C/TCP/"/>
    
    
    <category term="网络" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="TCP" scheme="http://linqiankun.gitee.io/hexoblog/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>nginx基础安装及使用</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/20/md/nginx/nginx%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/20/md/nginx/nginx%E5%9F%BA%E7%A1%80%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-20T07:11:44.000Z</published>
    <updated>2021-05-20T08:31:21.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&emsp;&emsp;Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><span id="more"></span><p>&emsp;&emsp;nginx可以用来做：反向代理服务器，静态Http服务器，负载均衡，虚拟主机。</p><hr><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>&emsp;&emsp;这里的安装目前是在windows环境下，傻瓜式安装即可。  </p><h2 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h2><p>&emsp;&emsp;nginx在windows安装很简单，下载后解压就好，纯绿色安装。<br>&emsp;&emsp;在官方地址下载nginx，解压后放在想要放的文件夹。<br>&emsp;&emsp;下载地址：<a href="http://nginx.org/en/download.html">下载地址</a>。</p><hr><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><p>&emsp;&emsp;启动，关机，重新加载等基础操作。<br>&emsp;&emsp;如果没有配置环境变量，启动前请进入nginx安装目录，如果有配置可以不进入。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入解压后的nginx</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.18.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动nginx（windows下）</span></span><br><span class="line">start nginx</span><br><span class="line">./nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止nginx</span></span><br><span class="line"><span class="comment"># stop是快速停止nginx，quit是有序停止nginx。</span></span><br><span class="line">./nginx -s stop</span><br><span class="line">./nginx -s quit</span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">./nginx -s reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 校验配置</span></span><br><span class="line">./nginx -t</span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">./nginx -v</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。&lt;/p&gt;</summary>
    
    
    
    <category term="nginx" scheme="http://linqiankun.gitee.io/hexoblog/categories/nginx/"/>
    
    
    <category term="linux" scheme="http://linqiankun.gitee.io/hexoblog/tags/linux/"/>
    
    <category term="nginx" scheme="http://linqiankun.gitee.io/hexoblog/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>消息中间件简介</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/19/md/rocketmq/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E4%BB%8B/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/19/md/rocketmq/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%AE%80%E4%BB%8B/</id>
    <published>2021-05-19T11:28:22.000Z</published>
    <updated>2021-05-26T08:45:33.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>&emsp;&emsp;消息中间件主要用于异步，削峰，解耦这几大典型场景。</p><span id="more"></span><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>&emsp;&emsp;对于没有强制顺序的任务，可以并行接受消息队列，并行对不同的业务逻辑进行异步处理，比如优惠卷，积分业务。</p><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>&emsp;&emsp;对于高并发业务，可以将请求放入消息队列中，消费方按照比较稳定的消费速度，对请求进行处理，从而起到削峰作用。</p><h3 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h3><p>&emsp;&emsp;将不同的业务模块，分离出来，每个单独部署，单独维护，互相之间采用消息队列进行通信，从而起到解耦作用。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="系统复杂性"><a href="#系统复杂性" class="headerlink" title="系统复杂性"></a>系统复杂性</h3><p>&emsp;&emsp;使用消息队列，会增加系统维护成本，不仅要维护原来的系统，还要对消息队列进行维护。<br>&emsp;&emsp;与此同时，还需要考虑对消息的正常处理，异常处理（重复消费，消息丢失，消息的顺序消费）。</p><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><p>&emsp;&emsp;这是分布式系统中的一个问题，在使用了消息中间件的系统中，消息发送方无法保证消费方是否正确的消费了消息，如果是异常的消费消息，就有可能造成，发送方与接收方的数据不一致。<br>&emsp;&emsp;这里就需要分布式事务来保证数据的一致性，将消费方，发送方的业务逻辑放在一个事务里面提交，一起成功，一起失败，保证数据的一致性。</p><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>&emsp;&emsp;MQ自己的可靠性，同样需要开发者进行维护。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;h2 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;消息中间件主要用于异步，削峰，解耦这几大典型场景。&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>rocketmq简介</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/19/md/rocketmq/rocketmq%E7%AE%80%E4%BB%8B/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/19/md/rocketmq/rocketmq%E7%AE%80%E4%BB%8B/</id>
    <published>2021-05-19T11:27:53.000Z</published>
    <updated>2021-05-25T11:58:18.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;rocketmq是一个纯java，分布式，队列模型的开源消息中间件，前身是MetaQ，是阿里参考Kafka特点研发的一个队列模型的消息中间件，后开源给apache基金会成为了apache的顶级开源项目，具有高性能、高可靠、高实时、分布式特点。<br><a href="https://rocketmq.apache.org/docs/quick-start/">rocketmq</a></p><span id="more"></span><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>&emsp;&emsp;官方表示能做的有很多：也是特点吧：</p><ol><li>发布订阅消息队列</li><li>财务级交易消息</li><li>各种跨语言客户端，java，C++，python，go</li><li>可插拔传输协议，TCP，SSL，AIO</li><li>内置的消息跟踪功能，支持开放式跟踪</li><li>多功能的大数据和流生态系统集成</li><li>按时间或偏移量追溯消息</li><li>可靠的FIFO和严格的有序消息传递在同一队列中</li><li>搞笑的推拉消费模型</li><li>单个队列中的百万级消息累积容量</li><li>多种消息传递协议</li><li>灵活的分布式横向扩展部署架构</li><li>快如闪电的批量消息交换系统</li><li>各种消息过滤机制</li><li>用于隔离测试和云隔离群集的Dcoker映像</li><li>功能丰富的管理仪表板，用于配置，指标和监视</li><li>认证与授权</li></ol><h2 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h2><ol><li>rocketmq-broker：接受生产者发来的消息并存储（通过调用rocketmq-store），消费者从这里取得消息。</li><li>rocketmq-client：提供发送、接受消息的客户端API。</li><li>rocketmq-namesrv：nameserver，类似于Zookeeper，这里保存着消息的TopicName，队列等运行时的元信息。</li><li>rocketmq-common：通用的一些类，方法，数据结构等。</li><li>rocketmq-remoting：基于Netty4的client/server+fastjson序列化+自定义二进制协议。</li><li>rocketmq-store：消息、索引存储等。</li><li>rocketmq-filtersrv：消息过滤器Server，需要注意的是，要实现这种过滤，需要上传代码到MQ！（一般而言，我们利用Tag足以满足大部分的过滤需求，如果更灵活更复杂的过滤需求，可以考虑filtersrv组件）。</li><li>rocketmq-tools：命令行工具。</li></ol><hr><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>&emsp;这里再windows环境下进行安装。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>&emsp;&emsp;在官网下载需要版本的rocketmq的包，需要下载bin包，source包是源码。<br>&emsp;&emsp;下载之后解压到指定的文佳夹。<br><a href="https://rocketmq.apache.org/dowloading/releases/">release版下载</a></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>&emsp;&emsp;解压完成后，需要将解压的文件夹配置进系统的环境变量。<br>&emsp;&emsp;这里的变量值为rocketmq解压后的目录。<br>&emsp;&emsp;rocketmq的启动需要java的环境，请在此之前配置好jdk环境，4.2版本的rocketmq需要1.8的jdk，版本需要对应。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROCKETMQ_HOME=C:\Program1\rocketmq-all-4.2.0-bin-release</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>&emsp;&emsp;rocketmq启动需要同时启动mqnamesrv和mqbroker。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入安装文件夹中的bin目录，这里存放了启动命令</span></span><br><span class="line"><span class="built_in">cd</span> C:\Program1\rocketmq-all-4.2.0-bin-release\bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows需要进入cmd命令窗口，powershell不可以的哦</span></span><br><span class="line"><span class="comment"># 启动mqnamesrv</span></span><br><span class="line">start mqnamesrv.cmd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动broker</span></span><br><span class="line">start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E9%80%89%E6%8B%A9C__WINDOWS_system32_cmd.exe%20-%20mqnamesrv.cmd%202021_5_24%2015_40_24.png" alt="namesrv启动成功"></p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/C__WINDOWS_system32_cmd.exe%20-%20mqbroker.cmd%20%20%20-n%20127.0.0.1_9876%20autoCreateTopicEnable=true%202021_5_24%2015_46_27.png" alt="broker启动成功，乌漆嘛黑一大片"></p><h2 id="启动Rocket-Console"><a href="#启动Rocket-Console" class="headerlink" title="启动Rocket-Console"></a>启动Rocket-Console</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>&emsp;&emsp;从官方github下载控制台，<a href="https://github.com/apache/rocketmq-externals.git">rocketmq-externals</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /你安装的文件夹</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/apache/rocketmq-externals.git</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>&emsp;&emsp;下载后可以看到有很多模块，这里需要的是rocketmq-console模块，需要对其进行配置。<br>&emsp;&emsp;配置需要修改自己的应用端口和rocketmq的地址端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server.contextPath=</span><br><span class="line"><span class="comment"># 配置本机地址</span></span><br><span class="line">server.port=8082</span><br><span class="line"></span><br><span class="line"><span class="comment">### SSL setting</span></span><br><span class="line"><span class="comment">#server.ssl.key-store=classpath:rmqcngkeystore.jks</span></span><br><span class="line"><span class="comment">#server.ssl.key-store-password=rocketmq</span></span><br><span class="line"><span class="comment">#server.ssl.keyStoreType=PKCS12</span></span><br><span class="line"><span class="comment">#server.ssl.keyAlias=rmqcngkey</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#spring.application.index=true</span></span><br><span class="line">spring.application.name=rocketmq-console</span><br><span class="line">spring.http.encoding.charset=UTF-8</span><br><span class="line">spring.http.encoding.enabled=<span class="literal">true</span></span><br><span class="line">spring.http.encoding.force=<span class="literal">true</span></span><br><span class="line">logging.config=classpath:logback.xml</span><br><span class="line"><span class="comment">#if this value is empty,use env value rocketmq.config.namesrvAddr  NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置rocketmq地址</span></span><br><span class="line">rocketmq.config.namesrvAddr=localhost:9876</span><br><span class="line"><span class="comment">#if you use rocketmq version &lt; 3.5.8, rocketmq.config.isVIPChannel should be false.default true</span></span><br><span class="line">rocketmq.config.isVIPChannel=</span><br><span class="line"><span class="comment">#rocketmq-console&#x27;s data path:dashboard/monitor</span></span><br><span class="line">rocketmq.config.dataPath=/tmp/rocketmq-console/data</span><br><span class="line"><span class="comment">#set it false if you don&#x27;t want use dashboard.default true</span></span><br><span class="line">rocketmq.config.enableDashBoardCollect=<span class="literal">true</span></span><br><span class="line"><span class="comment">#set the message track trace topic if you don&#x27;t want use the default one</span></span><br><span class="line">rocketmq.config.msgTrackTopicName=</span><br><span class="line">rocketmq.config.ticketKey=ticket</span><br><span class="line"></span><br><span class="line"><span class="comment">#Must create userInfo file: $&#123;rocketmq.config.dataPath&#125;/users.properties if the login is required</span></span><br><span class="line">rocketmq.config.loginRequired=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><p>&emsp;&emsp;配置完成后就可以进行启动了。<br>&emsp;&emsp;需要将rocketmq—console模块打jar包后以jar包模式运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里是进入你的该模块的目录</span></span><br><span class="line"><span class="built_in">cd</span> /rocketmq-console</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译打包</span></span><br><span class="line">mvn clean package -Dmaven.test.skip=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动运行</span></span><br><span class="line"><span class="built_in">cd</span> target</span><br><span class="line">java -jar rocketmq-console-ng-1.0.1.jar</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;启动成功就可以进入控制台查看消息了。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/RocketMq-console-ng%20%E5%92%8C%E5%8F%A6%E5%A4%96%201%20%E4%B8%AA%E9%A1%B5%E9%9D%A2%20-%20%E4%B8%AA%E4%BA%BA%20-%20Microsoft%E2%80%8B%20Edge%202021_5_24%2016_02_24.png" alt="rocketmq控制台"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;rocketmq是一个纯java，分布式，队列模型的开源消息中间件，前身是MetaQ，是阿里参考Kafka特点研发的一个队列模型的消息中间件，后开源给apache基金会成为了apache的顶级开源项目，具有高性能、高可靠、高实时、分布式特点。&lt;br&gt;&lt;a href=&quot;https://rocketmq.apache.org/docs/quick-start/&quot;&gt;rocketmq&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="http://linqiankun.gitee.io/hexoblog/tags/rocketmq/"/>
    
    <category term="tool" scheme="http://linqiankun.gitee.io/hexoblog/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper实现分布式锁</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/18/md/zookeeper/zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/18/md/zookeeper/zookeeper%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</id>
    <published>2021-05-18T07:49:08.000Z</published>
    <updated>2021-05-18T11:33:13.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;分布式锁的作用：<strong>在整个系统提供一个全局、唯一的锁，在分布式系统中每个系统在进行相关操作的时候需要获取到该锁，才能执行相应操作</strong>。  </p><span id="more"></span><p>&emsp;&emsp;大致思想为：<strong>每个客户端对每个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生死锁的问题</strong>。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol><li>利用Zookeeper可以创建临时有序节点的特性创建一个分布式锁。</li><li>多个系统的多个线程都要在此目录下创建临时有序节点，因为Zookeeper会为我们保证节点的有序性，所以可以利用节点的顺序性来对不同线程的先来后到进行判断。此时，在分布式下应该添加锁的线程就是zk指定目录下序号最小的临时序列节点所代表的线程。</li><li>当每个线程请求对应资源时，都需要现在zk指定目录下创建临时有序节点，然后获取当前目录下最小的节点序号（加锁的线程），判断最小节点是不是当前节点（是不是自己），如果是那么获取锁成功，如果不是获取锁失败。</li><li>获取锁失败的线程获取当前节点上一个临时有序节点，并对此节点进行监听。当该节点删除的时候（执行结束或者掉线，释放锁）这个线程会获取到通知，代表获取到了锁。这里的每一个节点都只是监听它的上一个节点，而不是监听最小的节点。因为临时节点都是有序号的，而且序号不会回退，所以只需要监听比其小1的节点。只要比它小1的节点被删除，则它就可以拿到资源去操作。</li></ol><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/zk%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.jpg" alt="分布式锁流程"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;分布式锁的作用：&lt;strong&gt;在整个系统提供一个全局、唯一的锁，在分布式系统中每个系统在进行相关操作的时候需要获取到该锁，才能执行相应操作&lt;/strong&gt;。  &lt;/p&gt;</summary>
    
    
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/categories/zookeeper/"/>
    
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/tags/zookeeper/"/>
    
    <category term="分布式锁" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>ZAB协议</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/13/md/zookeeper/ZAB%E5%8D%8F%E8%AE%AE/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/13/md/zookeeper/ZAB%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-05-13T12:10:42.000Z</published>
    <updated>2021-05-17T10:52:09.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;ZAB协议的全称是Zookeeper Atomic Broadcast（Zookeeper）原子广播。<br>&emsp;&emsp;Zookeeper是通过 Zab 协议来保证分布式事务的最终一致性。</p><span id="more"></span><ol><li>ZAB协议是为分布式协调服务Zookeeper专门设计的一种<strong>支持崩溃恢复</strong>的<strong>原子广播协议</strong>，是Zookeeper保证数据一致性的核心算法。Zab借鉴了Paxos算法，但又不想Paxos是一种通用的分布式一致性算法。他是为Zookeeper专门设计的。</li><li>在Zookeeper中主要依赖ZAB协议来实现数据一致性，基于该协议，zk实现了一种主备模型的系统架构来保证集群中各个副本之间的数据一致性。</li><li>Zookeeper使用一个<strong>单一的主进程来接收并处理客户端的所有事务请求</strong>，并通过ZAB协议，将服务器数据的状态变更以事务Proposal的形式广播到所有副本进程上去。ZAB协议的这个主备架构模型保证了同一时刻集群中只能有一个主进程来广播服务器的状态变更，因此能够很好地处理客户端的并发请求。</li><li>ZAB协议通过一个**全局递增的事务id(Zxid)**，来保证状态变更的顺序性，也就是说，ZAB保证了一个状态变更的请求如果已经被处理，那么所有该变更所依赖的状态变更都已经被处理过了。创建节点的顺序，/a与/a/b。</li><li>考虑到主进程在任何时刻都可能出现宕机的情况，ZAB协议还保证了即使主进程出现异常，只要集群中有<strong>半数以上节点存活</strong>，就仍然可以正常提供服务。</li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>ZAB协议需要确保那些已经在Leader服务器上提交的事务最终被所有的服务器提交。</li><li>ZAB协议需要确保丢弃那些只在Leader上被提出而没有被提交的事务。</li><li>ZAB算法设计为新被选举出来的Leader拥有集群中ZXID最大的事务Proposal。这样就可以保证新的Leader一定具有所有已经提交的Proposal。更为重要的是，如果让ZXID最大的节点成为Leader，就可以省去Leader节点检查Proposal的提交和丢弃的工作了。</li></ol><hr><h1 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h1><p>&emsp;&emsp;ZAB协议的核心是，<strong>定义了如何处理那些会改变Zookeeper服务器数据状态的事务请求。</strong></p><ol><li>所有的事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被叫做Leader服务器。其他剩余的服务器则是Follower服务器。</li><li>Leader服务器负责将一个客户端事务请求，转换成一个事务Proposal，并将该Proposal分发给集群中所有的Follower服务器，也就是向所有Follower节点发送数据广播请求（或数据复制）。</li><li>分发之后Leader服务器需要等待所有Follower服务器的反馈（Ack请求），在Zab协议中，只要超过半数的Follower服务器进行了正确的反馈后（也就是收到半数以上的Follower的Ack请求），那么Leader就会再次向所有的Follower服务器发送Commit消息，要求其将上一个事务Proposal进行提交。</li></ol><hr><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><p>&emsp;&emsp;ZAB协议包含两种基本的模式：<strong>崩溃恢复</strong>，<strong>消息广播</strong>。</p><p>&emsp;&emsp;<strong>协议过程</strong>：</p><ol><li>当整个集群启动过程中，或者当 Leader 服务器出现网络中弄断、崩溃退出或重启等异常时，Zab协议就会进入崩溃恢复模式，选举产生新的Leader。</li><li>当选举产生了新的Leader，同时集群中有过半的机器与该Leader服务器完成了状态同步（即数据同步）之后，Zab协议就会退出崩溃恢复模式，进入消息广播模式。</li><li>这时，如果有一台遵守Zab协议的服务器加入集群，因为此时集群中已经存在一个Leader服务器在广播消息，那么该新加入的服务器自动进入恢复模式：找到Leader服务器，并且完成数据同步。同步完成后，作为新的Follower一起参与到消息广播流程中。</li></ol><p>&emsp;&emsp;<strong>协议状态切换</strong>：</p><p>&emsp;&emsp;当Leader出现崩溃退出或者机器重启，亦或是集群中不存在超过半数的服务器与Leader保存正常通信，Zab就会再一次进入崩溃恢复，发起新一轮Leader选举并实现数据同步。同步完成后又会进入消息广播模式，接收事务请求。</p><p>&emsp;&emsp;<strong>保证消息有序</strong>：</p><p>&emsp;&emsp;在整个消息广播中，Leader会将每一个事务请求转换成对应的Proposal来进行广播，并且在广播事务Proposal之前，Leader服务器会首先为这个事务Proposal分配一个全局单递增的唯一ID，称之为事务ID（即zxid），由于Zab协议需要保证每一个消息的严格的顺序关系，因此必须将每一个Proposal按照其zxid的先后顺序进行排序和处理。</p><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p>&emsp;&emsp;<strong>当Zookeeper集群初始化时，或Leader故障宕机时，ZAB协议就会进入崩溃恢复模式，并选举出新的Leader</strong>。当新的Leader选举出来后，并且集群中已经有过半的节点与Leader完成了数据同步，ZAB协议就会退出崩溃恢复模式，转而进入消息广播模式。一个节点要想成为Leader，必须获得集群中过半节点的支持。<br>&emsp;&emsp;在ZAB协议中，为了保证程序的正确运行，整个恢复过程结束后需要选举出一个新的Leader服务器。因此ZAB协议需要一个高效且可靠的Leader选举算法，从而确保能够快速选举出新的Leader。<br>&emsp;&emsp;Leader选举算法不仅仅需要让Leader自己知道自己已经被选举为Leader ，同时还需要让集群中的所有其他机器也能够快速感知到选举产生的新Leader服务器。   </p><p>&emsp;&emsp;当新的机器加入到集群中的时候，如果已经存在leader服务器，那么新加入的服务器就会自觉进入崩溃恢复模式，找到leader进行数据同步。<br>&emsp;&emsp;崩溃恢复主要包括两部分：Leader选举和数据恢复。</p><h2 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h2><p>&emsp;&emsp;ZAB的正常工作模式。</p><blockquote><p>&emsp;&emsp;Zookeeper设计成只允许唯一的一个Leader节点负责处理客户端的事务请求，当Leader接收到事务请求后，会生成相应的事务Proposal并发起一轮消息广播。如果集群中的非Leader节点(Follower或Observer)接收到了事务请求，会将请求转发给Leader处理。当Leader宕机，或者是集群中已经不存在超过半数的节点与Leader保持正常通信，那么集群就会进入崩溃恢复模式。</p></blockquote><p>&emsp;&emsp;在zookeeper集群中，数据副本的传递策略就是采用消息广播模式。<br>&emsp;&emsp;ZAB协议的消息广播模式采用的是原子消息广播，类似于一个两阶段提交，Leader接收客户端的事务请求，为其生成对应的Proposal，并广播给集群中所有其他的服务器，然后分别收集每个服务器的选票，最后进行事务提交。  </p><blockquote><p>&emsp;&emsp;Zookeeper中农数据副本的同步方式与二段提交相似，但是却又不同。二段提交要求协调者必须等到所有的参与者全部反馈ACK确认消息后，再发送commit消息。要求所有的参与者要么全部成功，要么全部失败。二段提交会产生严重的阻塞问题。<br>&emsp;&emsp;Zab协议中 Leader 等待 Follower 的ACK反馈消息是指“<strong>只要半数以上的Follower成功反馈即可，不需要收到全部Follower反馈</strong>”。</p></blockquote><p>&emsp;&emsp; 在整个消息广播的过程中，Leader会为每个事务请求生成Proposal并进行广播。此外，在广播Proposal之前，Leader会首先为这个Proposal生成全局单调递增的唯一ID，称为事务ID，也即ZXID。ZAB协议会严格按照ZXID的顺序处理每个Proposal，保证了消息的顺序性。<br>&emsp;&emsp;在消息广播过程中，Leader会在Leader侧为每个Follower都<strong>各自分配一个单独的队列</strong>，然后将需要广播的Proposal依次放入这些队列中，按照FIFO的原则进行发送。Follower在接收到Proposal后，会首先将其以事务日志的形式写入磁盘中，写入成功后给Leader响应ACK。当Leader收到超过半数的Follower的ACK后，会广播一个Commit消息通知所有Follower进行事务提交，同时Leader自身也会提交事务。Follower在收到Commit消息后，就会完成对事务的提交。</p><p>&emsp;&emsp;Zookeeper采用Zab协议的核心，就是只要有一台服务器提交了Proposal，就要确保所有的服务器最终都能正确提交Proposal。这也是CAP/BASE实现最终一致性的一个体现。<br>&emsp;&emsp;Leader服务器与每一个Follower服务器之间都维护了一个单独的FIFO消息队列进行收发消息，使用队列消息可以做到异步解耦。 Leader和Follower之间只需要往队列中发消息即可。如果使用同步的方式会引起阻塞，性能要下降很多。</p><p>&emsp;&emsp;消息广播过程：</p><ol><li>客户端发起一个写请求。</li><li>Leader服务器将客户端的请求转化为事务Proposal提案，同时为每个Proposal分配一个全局的ID，即Zxid。</li><li>Leader服务器为每个Follower服务器分配一个单独的队列，然后将需要广播的Proposal依次放到队列中取，并且根据FIFO策略进行消息发送。</li><li>Follower接收到Proposal后，会首先将其以事务日志的方式写入本地磁盘中，写入成功后向Leader反馈一个Ack响应消息。</li><li>Leader接收到超过半数以上Follower的Ack响应消息后，即认为消息发送成功，可以发送commit消息。</li><li>Leader向所有Follower广播commit消息，同时自身也会完成事务提交。Follower接收到commit消息后，会将上一条事务提交。</li></ol><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;ZAB协议要求每个Leader都要经历三个阶段：发现，同步，广播。</p><ol><li>发现：要求Zookeeper集群必须选举出一个Leader进程，同时Leader会维护一个Follower可用列表。将来客户端可以和Follower节点进行通信。</li><li>同步：Leader要负责将本身的数据与Follower完成同步，做到多副本存储。这样也是提现了CAP中的高可用和分区容错。Follower将队列中未处理完的请求消费完成后，写入本地事务日志中。</li><li>广播：Leader可以接受客户端新的事务Proposal请求，将新的Proposal请求广播给所有的Follower。</li></ol><p>&emsp;&emsp; 在正常运行的情况下，ZAB协议会一直处于阶段三来反复地进行消息广播流程。如果出现Leader崩溃或者其他原因导致Leader缺失，ZAB协议就会再次进入阶段一，重新选举新的Leader。</p><hr><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>&emsp;&emsp;Zookeeper节点有三种状态：</p><ol><li>Following：当前节点是跟随着，服从Leader的命令。</li><li>Leading：当前节点是Leader，负责协调事务。</li><li>Looking：节点处于选举状态，正在寻找Leader。</li></ol><p>&emsp;&emsp; 当ZAB协议的进程刚开始启动时，所有进程都处于Looking的初始化状态，此时集群中并不存在Leader。接下来，所有处于Looking状态的进程都会试图去选举出一个Leader。如果某个进程发现已经选举出了Leader，那么它会马上切换到Following，开始和Leader保存同步。此时，我们将处于Following状态的进程称为Follower，处于Leading状态的进程称为Leader。<br>&emsp;&emsp;考虑到Leader进程随时可能挂掉，当检测出Leader已经崩溃或放弃领导地位时，其余的Following状态的进程就会重新进入Looking状态，并开始进行新一轮的Leader选举。因此在ZAB协议中，每个进程的状态都在Looking、Following和Leading之间不断转换。<br>&emsp;&emsp;在进程完成Leader选举和数据同步之后，ZAB协议就进入了广播阶段。在这个阶段中，Leader会为每一个与自己保持同步的Follower创建一个操作队列。同一时刻，一个Follower只能与一个Leader保持同步。<br>&emsp;&emsp;Leader进程与所有的Follower进程之间通过心跳检测机制来感知彼此的状态。如果Leader能在超时时间内收到Follower的心跳，则Follower就会一直与Leader保持同步。而一旦在超时时间内Leader无法收到过半的Follower的心跳信息，或者TCP连接本身断开了，那么Leader就会停止对当前周期的领导，并转换到Looking状态。同时，所有Follower也会放弃这个Leader，进入Looking状态。之后，所有进程就会开启新一轮的Leader选举。</p><p><a href="https://blog.csdn.net/liuchang19950703/article/details/111406622">Zab协议详解</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;ZAB协议的全称是Zookeeper Atomic Broadcast（Zookeeper）原子广播。&lt;br&gt;&amp;emsp;&amp;emsp;Zookeeper是通过 Zab 协议来保证分布式事务的最终一致性。&lt;/p&gt;</summary>
    
    
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/categories/zookeeper/"/>
    
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper集群及ZAB简介</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/12/md/zookeeper/zookeeper%E9%9B%86%E7%BE%A4%E5%8F%8AZAB/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/12/md/zookeeper/zookeeper%E9%9B%86%E7%BE%A4%E5%8F%8AZAB/</id>
    <published>2021-05-12T11:43:34.000Z</published>
    <updated>2021-05-19T07:26:02.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>&emsp;&emsp;普通的集群模式一般是主备模式（Master/Slave模式），Master作为主服务器提供写服务，Slave作为从服务器，一般采用异步复制的方式获取Master的数据提供读服务。  </p><span id="more"></span><p>&emsp;&emsp;在Zookeeper中，没有使用传统模式，而是引入了Leader，Follower，Observer三种角色。<br>&emsp;&emsp;ZooKeeper集群中的所有机器通过一个Leader选举算法来选定一台称为 “Leader” 的机器，Leader既可以为客户端提供写服务又能提供读服务。除了Leader外，Follower和Observer都只能提供读服务。<br>&emsp;&emsp;Follower和Observer唯一的区别在于Observer机器不参与Leader的选举过程，也不参与写操作的“过半写成功”策略，因此Observer机器可以在不影响写性能的情况下提升集群的读性能。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/zookeeper.jpg" alt="zookeeper角色"></p><hr><h1 id="ZAB简介"><a href="#ZAB简介" class="headerlink" title="ZAB简介"></a>ZAB简介</h1><p>&emsp;&emsp;ZAB（ZooKeeper Atomic Broadcast 原子广播）协议是为分布式协调服务ZooKeeper专门设计的一种支持崩溃恢复的原子广播协议。在ZooKeeper中，主要依赖ZAB协议来实现分布式数据一致性，基于该协议，ZooKeeper实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。<br>&emsp;&emsp;ZAB协议包括两种基本模式：崩溃恢复和消息广播。</p><h2 id="崩溃恢复"><a href="#崩溃恢复" class="headerlink" title="崩溃恢复"></a>崩溃恢复</h2><p>&emsp;&emsp;当整个服务框架在启动过程中，或是当Leader服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。<br>&emsp;&emsp;当选举产生了新的Leader服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致。</p><h2 id="消息广播"><a href="#消息广播" class="headerlink" title="消息广播"></a>消息广播</h2><p>&emsp;&emsp;当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。<br>&emsp;&emsp;当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。<br>&emsp;&emsp;正如上文介绍中所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理。Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;集群&quot;&gt;&lt;a href=&quot;#集群&quot; class=&quot;headerlink&quot; title=&quot;集群&quot;&gt;&lt;/a&gt;集群&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;普通的集群模式一般是主备模式（Master/Slave模式），Master作为主服务器提供写服务，Slave作为从服务器，一般采用异步复制的方式获取Master的数据提供读服务。  &lt;/p&gt;</summary>
    
    
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/categories/zookeeper/"/>
    
    
    <category term="分布式" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper简述</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/11/md/zookeeper/zookeeper%E7%AE%80%E8%BF%B0/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/11/md/zookeeper/zookeeper%E7%AE%80%E8%BF%B0/</id>
    <published>2021-05-11T12:51:19.000Z</published>
    <updated>2021-05-12T11:42:39.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;从本质上来说，Zookeeper就是一种分布式协调服务，在分布式环境中协调和管理服务是一个复杂的过程。  </p><span id="more"></span><p>&emsp;&emsp;ZooKeeper的设计目标是将那些复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。<br>&emsp;&emsp;Zookeeper提供服务主要就是通过：<strong>数据结构+原语集+watcher机制到达的</strong>。<br>&emsp;&emsp;分布式应用程序结合Zookeeper可以实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master选举、分布式锁和分布式队列等功能。  </p><hr><h1 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h1><p>&emsp;&emsp;ZooKeeper本身就是一个分布式程序（只要半数以上节点存活，ZooKeeper就能正常服务）。<br>&emsp;&emsp;ZooKeeper将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因）。<br>&emsp;&emsp;ZooKeeper是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）<br>&emsp;&emsp;ZooKeeper有临时节点的概念。 当创建临时节点的客户端会话一直保持活动，瞬时节点就一直存在。而当会话终结时，瞬时节点被删除。持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。<br>&emsp;&emsp;ZooKeeper 底层其实只提供了两个功能：①管理（存储、读取）用户程序提交的数据；②为用户程序提交数据节点监听服务。</p><hr><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol><li><strong>顺序一致性</strong>：从同一个客户端发起的事务请求，最终将会严格按照其发起顺序被应用到ZooKeeper中。</li><li><strong>原子性</strong>：所有事务请求的结果在集群中所有机器上的应用情况是一致的，也就是说要么整个集群所有集群都成功应用了某一个事务，要么都没有应用，一定不会出现集群中部分机器应用了该事务，而另外一部分没有应用的情况。</li><li><strong>单一视图</strong>：无论客户端连接的是哪个ZooKeeper服务器，其看到的服务端数据模型都是一致的。</li><li><strong>可靠性</strong>：一旦服务端成功地应用了一个事务，并完成对客户端的响应，那么该事务所引起的服务端状态变更将会被一直保留下来，除非有另一个事务又对其进行了变更。</li><li><strong>实时性</strong>：通常人们看到实时性的第一反应是，一旦一个事务被成功应用，那么客户端能够立即从服务端上读取到这个事务变更后的最新数据状态。这里需要注意的是，ZooKeeper仅仅保证在一定的时间段内，客户端最终一定能够从服务端上读取到最新的数据状态。</li></ol><p>&emsp;&emsp;顺序一致性是通过ZXid来实现的，全局唯一，顺序递增，同一个session中请求是FIFO的；一次事务的应用，服务端状态的变更会以Zxid、Znode数据版本、数据、节点路径的形式保存下来。</p><hr><h1 id="zk数据模型-ZNode"><a href="#zk数据模型-ZNode" class="headerlink" title="zk数据模型(ZNode)"></a>zk数据模型(ZNode)</h1><p>&emsp;&emsp;zookeeper的数据模型和Unix的文件系统目录树很类似，拥有一个层次的命名空间。这里面的每一个节点都称为ZNode，节点可以拥有子节点，同时也允许少量数据节点存储在该节点之下。</p><h2 id="节点引用方式"><a href="#节点引用方式" class="headerlink" title="节点引用方式"></a>节点引用方式</h2><p>&emsp;&emsp;ZNode通过路径引用，如同Unix的文件路径。路径必须是要绝对的，因此他们必须有斜杠字符/来开头，除此之外，路径名必须是唯一的，且不能更改。<br>&emsp;&emsp;在dubbo的服务注册上，dubbo中有一个贯穿全局的URL类，dubbo中所有的配置信息都被存放在URL中传递，dubbo向注册中心注册时写下的节点名就是由URL中的URI和配置信息编码后组成的。</p><h2 id="ZNode结构"><a href="#ZNode结构" class="headerlink" title="ZNode结构"></a>ZNode结构</h2><p>&emsp;&emsp;ZNode兼具目录和文件两种特性，既像文件一样维护者数据，元信息，ACL，时间戳等数据结构，又像目录一样可以作为路径标识的一部分。<br>&emsp;ZNode由一下及部分组成：</p><ol><li>Stat数据结构<ol><li>操作控制表（ACL）-每个节点都有一个ACL来做节点的操作控制，这个列表规定了用户的权限，限定了特定用户对目标节点的操作。<ul><li>create：创建子节点的权限。</li><li>read：获取子节点数据和子节点列表的权限。</li><li>write：更新节点数据的权限。</li><li>delete：删除子节点的权限。</li><li>admin：设置节点ACL的权限。</li></ul></li><li>版本-ZNode有三个数据版本<ul><li>version：当前ZNode的版本。</li><li>cversion：当前ZNode子节点的版本。</li><li>aversion：当前ACL列表的版本。</li></ul></li><li>Zxid<ol><li>可以理解成Zookeeper中时间戳的一种表现形式，也可以理解成事务ID的概念。</li><li>如果Zxid1的值小于Zxid2的值，那么Zxid1所对应的事件发生在Zxid2所对应的事件之前。</li><li>ZooKeeper的每个节点维护者三个Zxid值，分别为：cZxid、mZxid、pZxid。<ol><li>cZxid：节点创建时间。</li><li>mZxid：节点最近一次修改时间。</li><li>pZxid：该节点的子节点列表最后一次被修改时的时间，子节点内容变更不会变更pZxid。</li></ol></li></ol></li></ol></li><li>data域</li><li>children节点</li></ol><h3 id="data域"><a href="#data域" class="headerlink" title="data域"></a>data域</h3><p>&emsp;&emsp;<strong>Zookeeper中每个节点存储的数据要被原子性的操作</strong>，也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。<br>&emsp;&emsp;Zookeeper虽然可以存储数据，但是并不是为了做数据库或者大数据存储，相反，它是用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等，这些数据通常是很小的数据，KB为大小单位。ZNode对数据大小也有限制，至多1M。实际上从这里，就可以推导出Zookeeper用于分布式配置中心的可行性。</p><h3 id="Zxid"><a href="#Zxid" class="headerlink" title="Zxid"></a>Zxid</h3><p>&emsp;&emsp;在Zookeeper中，能改变Zookeeper服务器状态的操作称为事务操作。一般包括数据节点创建，更新，删除和客户端会话创建与失效等操作。<strong>对每一个事务操作，Zookeeper都会为其分配唯一的全局事务ID，就是Zxid</strong>。<br>&emsp;&emsp;Zxid是一个64位的数字。前32位叫做epoch，用来标识Zookeeper 集群中的Leader节点，当Leader节点更换时，就会有一个新的epoch。<strong>后32位则为递增序列</strong>。从这些Zxid中可以间接地识别出ZooKeeper处理这些事务操作请求的全局顺序。</p><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>&emsp;&emsp;ZNode有四种节点类型：<strong>持久节点，临时节点，持久顺序节点，临时顺序节点</strong>。</p><ol><li>持久节点：该节点的生命周期不依赖于session，创建之后客户端断开连接，节点依旧存在，只用客户端执行删除操作，节点才能被删除。</li><li>临时节点：该节点的声明周期依赖于session，客户端断开连接，临时节点就会自动删除。另外，临时节点不允许有子节点。</li><li>顺序节点：当选择创建顺序节点时，ZooKeeper通过将10位的序列号附加到原始名称来设置znode的路径。顺序节点在锁定和同步中起重要作用。</li></ol><hr><h1 id="Watches"><a href="#Watches" class="headerlink" title="Watches"></a>Watches</h1><p>&emsp;&emsp;Watches，监听事件，是zookeeper中很重要的一个特性。允许用户在指定节点上注册一些Watcher，并在某些特定事件触发的时候，Zookeeper服务端会将事件异步通知到监听了的客户端上去。<br>&emsp;&emsp;Znode修改是与znode相关的数据的修改或znode的子项中的更改。只触发一次watches。如果客户端想要再次通知，则必须通过另一个读取操作来完成。当连接会话过期时，客户端将与服务器断开连接，相关的watches也将被删除。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>数据监听器</li><li>子节点监听器</li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>一次性，一个watcher只会被通知一次，被通知过后会立即删除，如果节点再次改变，则不会收到通知，除非重新设置了watcher。</li><li>有序性：当监听的对象发生改变时，将会触发watch对应的事件，事件则被异步的发送到客户端，客户端收到watcher通知后才能查看变化结果。</li></ol><h2 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h2><ol><li>setData将触发ZNode的数据watche。</li><li>create和delete操作将触发ZNode的数据watch和子节点watch。</li></ol><hr><h1 id="会话（Session）"><a href="#会话（Session）" class="headerlink" title="会话（Session）"></a>会话（Session）</h1><p>&emsp;&emsp;Session指的是Zookeeper服务端与客户端之间的会话。<br>&emsp;&emsp;在Zookeeper中，一个客户端连接指的是客户端和服务器之间的一个TCP长连接。<br>&emsp;&emsp;客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。<br>&emsp;&emsp;客户端以特定的时间间隔发送心跳以保持会话有效，如果ZooKeeper Server Ensembles在超过服务器开启时指定的期间（会话超时）都没有从客户端接收到心跳，则它会判定客户端死机。会话超时通常以毫秒为单位。当会话由于任何原因结束时，在该会话期间创建的临时节点也会被删除。<br>&emsp;&emsp; Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。<br>&emsp;&emsp;在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;从本质上来说，Zookeeper就是一种分布式协调服务，在分布式环境中协调和管理服务是一个复杂的过程。  &lt;/p&gt;</summary>
    
    
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/categories/zookeeper/"/>
    
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper集群安装使用</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/10/md/zookeeper/zookeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/10/md/zookeeper/zookeeper%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-10T11:40:29.000Z</published>
    <updated>2021-05-24T08:13:01.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;zookeeper的安装模式分为：单机模式，集群模式，伪集群模式。<br>&emsp;&emsp;伪集群模式就是在单机上模拟集群模式。<br>&emsp;&emsp;单机模式下的安安装已经记过了。</p><span id="more"></span><hr><h1 id="伪集群模式"><a href="#伪集群模式" class="headerlink" title="伪集群模式"></a>伪集群模式</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>&emsp;&emsp;在官网下载zookeeper指定版本，<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a>。<br>&emsp;&emsp;下载指定的压缩包apache-zookeeper-3.7.0-bin.tar.gz。<br>&emsp;&emsp;将下载的压缩包解压到三个不同的文件夹server1，server2，server3中。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>&emsp;&emsp;需要对三个zk实例进行不同配置，主要是配置端口，数据存放地址，通信地址等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The number of milliseconds of each tick</span></span><br><span class="line"><span class="comment"># 服务端与客户端之间的交互基本时间单元</span></span><br><span class="line">tickTime=2000</span><br><span class="line"><span class="comment"># The number of ticks that the initial </span></span><br><span class="line"><span class="comment"># synchronization phase can take</span></span><br><span class="line"><span class="comment"># 允许follower连接到leader之间，并同步到的初始化时间</span></span><br><span class="line">initLimit=10</span><br><span class="line"><span class="comment"># The number of ticks that can pass between </span></span><br><span class="line"><span class="comment"># sending a request and getting an acknowledgement</span></span><br><span class="line"><span class="comment"># Leader服务器与follower服务器之间信息同步允许的最大时间间隔，如果超过次间隔，默认follower服务器与leader服务器之间断开链接</span></span><br><span class="line">syncLimit=5</span><br><span class="line"><span class="comment"># the directory where the snapshot is stored.</span></span><br><span class="line"><span class="comment"># do not use /tmp for storage, /tmp here is just </span></span><br><span class="line"><span class="comment"># example sakes.</span></span><br><span class="line"><span class="comment"># 数据存放路径</span></span><br><span class="line">dataDir=/Program1/zookeepers/server1/tmp/zookeeper</span><br><span class="line">dataLogDir=/Program1/zookeepers/server1/<span class="built_in">log</span>/zookeeper</span><br><span class="line"><span class="comment"># the port at which the clients will connect</span></span><br><span class="line"><span class="comment"># 启动端口与连接端口</span></span><br><span class="line">clientPort=2181</span><br><span class="line"><span class="comment"># 这里的.后面的数字和下面myid</span></span><br><span class="line">server.1= 127.0.0.1:2888:3888</span><br><span class="line">server.2= 127.0.0.1:2889:3889</span><br><span class="line">server.3= 127.0.0.1:2890:3890</span><br><span class="line"><span class="comment"># the maximum number of client connections.</span></span><br><span class="line"><span class="comment"># increase this if you need to handle more clients</span></span><br><span class="line"><span class="comment">#maxClientCnxns=60</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to read the maintenance section of the </span></span><br><span class="line"><span class="comment"># administrator guide before turning on autopurge.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The number of snapshots to retain in dataDir</span></span><br><span class="line"><span class="comment">#autopurge.snapRetainCount=3</span></span><br><span class="line"><span class="comment"># Purge task interval in hours</span></span><br><span class="line"><span class="comment"># Set to &quot;0&quot; to disable auto purge feature</span></span><br><span class="line"><span class="comment">#autopurge.purgeInterval=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Metrics Providers</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># https://prometheus.io Metrics Exporter</span></span><br><span class="line"><span class="comment">#metricsProvider.className=org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span></span><br><span class="line"><span class="comment">#metricsProvider.httpPort=7000</span></span><br><span class="line"><span class="comment">#metricsProvider.exportJvmInfo=true</span></span><br><span class="line"><span class="comment"># 开启4字命令白名单，zkui会使用</span></span><br><span class="line">4lw.commands.whitelist=*</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;配置完成后建立myid文件，分别在每个实例对应的数据存放文件夹下建立myid文件，没有后缀名，内容填写为1、2、3即可。</p><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>&emsp;&emsp;分别启动3个实例。<br>&emsp;&emsp;未完全启动前会有报错，无法连接到其他实例，不用理会，继续启动即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> server1</span><br><span class="line">zkServer</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> server2</span><br><span class="line">zkServer</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> server3</span><br><span class="line">zkServer</span><br></pre></td></tr></table></figure><hr><h1 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h1><p>&emsp;&emsp;集群模式需要在不同物理机器上安装，最好在奇数台服务器上安装。<br>&emsp;&emsp;集群模式是目前最主要的应用场景模式。<br>&emsp;&emsp;其他配置与伪集群模式的配置相同。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;zookeeper的安装模式分为：单机模式，集群模式，伪集群模式。&lt;br&gt;&amp;emsp;&amp;emsp;伪集群模式就是在单机上模拟集群模式。&lt;br&gt;&amp;emsp;&amp;emsp;单机模式下的安安装已经记过了。&lt;/p&gt;</summary>
    
    
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/categories/zookeeper/"/>
    
    
    <category term="tool" scheme="http://linqiankun.gitee.io/hexoblog/tags/tool/"/>
    
    <category term="分布式" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper-leader选举</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/10/md/zookeeper/zookeeper-leader%E9%80%89%E4%B8%BE/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/10/md/zookeeper/zookeeper-leader%E9%80%89%E4%B8%BE/</id>
    <published>2021-05-10T11:39:32.000Z</published>
    <updated>2021-05-17T11:05:00.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;ZAB协议包括了两种基本模式：崩溃恢复，数据广播。<br>&emsp;&emsp;一旦Leader服务器出现崩溃或者由于网络原因导致Leader服务器失去了与过半Follower的联系，那么就会进入崩溃恢复模式。<br>&emsp;&emsp;崩溃恢复主要包括两部分：Leader选举和数据恢复。</p><span id="more"></span><h2 id="保证数据一致性"><a href="#保证数据一致性" class="headerlink" title="保证数据一致性"></a>保证数据一致性</h2><p>&emsp;&emsp;假设两种情况：</p><ol><li>一个事务在Leader上提交了，并且过半的Folower都响应Ack了，但是Leader在Commit消息发出之前挂了。</li><li>假设一个事务在Leader提出之后，Leader挂了。</li></ol><p>&emsp;&emsp;要满足上面这两个问题，必须做到：</p><ol><li><strong>确保已经被Leader提交的Proposal必须最终被所有的Follower服务器提交</strong>。</li><li><strong>确保丢弃已经被Leader提出的但是没有被提交的Proposal</strong>。</li></ol><p>&emsp;&emsp;新的Leader的必须满足：</p><ol><li><strong>新选举出来的Leader不能包含未提交的Proposal</strong>。</li><li><strong>新选举的Leader节点中含有最大的Zxid</strong>。</li></ol><h2 id="ZAB如何数据同步"><a href="#ZAB如何数据同步" class="headerlink" title="ZAB如何数据同步"></a>ZAB如何数据同步</h2><p>&emsp;&emsp;完成Leader选举后（新的Leader具有最高的Zxid），在正式开始工作之前（接收事务请求，然后提出新的Proposal），Leader服务器会首先确认事务日志中的所有的Proposal是否已经被集群中过半的服务器Commit。<br>&emsp;&emsp;Leader服务器需要确保所有的Follower服务器能够接收到每一条事务的Proposal，并且能将所有已经提交的事务Proposal应用到内存数据中。等到Follower将所有尚未同步的事务Proposal都从Leader服务器上同步过啦并且应用到内存数据中以后，Leader才会把该Follower加入到真正可用的Follower列表中。</p><h2 id="ZAB数据同步过程中，如何处理需要丢弃的Proposal"><a href="#ZAB数据同步过程中，如何处理需要丢弃的Proposal" class="headerlink" title="ZAB数据同步过程中，如何处理需要丢弃的Proposal"></a>ZAB数据同步过程中，如何处理需要丢弃的Proposal</h2><p>&emsp;&emsp;在ZAB的事务编号Zxid设计中，Zxid是一个64位的数字。<br>&emsp;&emsp;<strong>其中低32位可以看成一个简单的单增计数器，针对客户端每一个事务请求，Leader在产生新的Proposal事务时，都会对该计数器加1。而高32位则代表了Leader周期的epoch编号</strong>。  </p><blockquote><p>&emsp;&emsp;epoch编号可以理解为当前集群所处的年代，或者周期。每次Leader变更之后都会在epoch的基础上加1，这样旧的Leader崩溃恢复之后，其他Follower也不会听它的了，因为Follower只服从epoch最高的Leader命令。</p></blockquote><p>&emsp;&emsp;每当选举产生一个新的Leader，就会从这个Leader服务器上取出本地事务日志充最大编号Proposal的Zxid，并从Zxid中解析得到对应的epoch编号，然后再对其加1，之后该编号就作为新的epoch值，并将低32位数字归零，由0开始重新生成Zxid。<br>&emsp;&emsp;ZAB协议通过epoch编号来区分Leader变化周期，能够有效避免不同的Leader错误的使用了相同的Zxid编号提出了不一样的Proposal的异常情况。<br>&emsp;&emsp;当一个包含了上一个Leader周期尚未提交过的事务Proposal的服务器启动时，当这台机器加入集群中，以Follower角色连上Leader服务器上，Leader服务器会根据自己服务器上最后提交的Proposal来和Follower服务器的Proposal进行比对，比对的结果肯定是Leader要求Follower进行一个回退操作，回退到一个确实已经被集群中过半机器Commit的最新Proposal。</p><hr><h1 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h1><p>&emsp;&emsp;选举分为四个阶段：选举阶段，发现阶段，同步阶段，广播阶段。</p><h2 id="选举阶段"><a href="#选举阶段" class="headerlink" title="选举阶段"></a>选举阶段</h2><p>&emsp;&emsp;节点在一开始都处于选举阶段，只要一个节点得到超过半数节点的票数，他就可以当选准Leader，只有达到同步阶段，这个节点才能真正称为Leader。<br>&emsp;&emsp;Zookeeper规定所有有效的投票都必须在同一个轮次中，每个服务器在开始新一轮投票时，都会对自己维护的logicalClock进行自增操作。<br>&emsp;&emsp;每个服务器在广播自己的选票前，会将自己的投票箱（recvset）清空。该投票箱记录了所受到的选票。(3,2)这种格式，表示3投给了2。<br>&emsp;&emsp;广播选票后，会进行选票PK，选出准Leader。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/zab%E9%80%89%E4%B8%BE.png" alt="ZAB选举"></p><h2 id="发现阶段"><a href="#发现阶段" class="headerlink" title="发现阶段"></a>发现阶段</h2><p>&emsp;&emsp;在这个阶段，Followers和上一轮选举出的准Leader进行通信，同步Followers最近接收的事务Proposal。<br>&emsp;&emsp;<em>一个Follower只会连接一个Leader，如果一个 Follower节点拒绝另一个Follower节点，则会在尝试连接时被拒绝。被拒绝之后，该节点就会进入Leader Election阶段</em>。<br>&emsp;&emsp;这个阶段的主要目标是发现当前大多数节点接收的最新Proposal，并且准Leader生成新的epoch，让Follower接收，更新它们的acceptedEpoch。</p><h2 id="同步阶段"><a href="#同步阶段" class="headerlink" title="同步阶段"></a>同步阶段</h2><p>&emsp;&emsp;同步阶段主要是利用Leader前一阶段获得最新的Proposal历史，同步集群中所有的副本。<br>&emsp;&emsp;只有当超过半数节点都同步完成，准Leader才会称为真正的Leader。Follower只会接受Zxid比自己LastZxid大的Proposal。</p><h2 id="广播阶段"><a href="#广播阶段" class="headerlink" title="广播阶段"></a>广播阶段</h2><p>&emsp;&emsp;到了这个阶段，Zookeeper集群才能正式向外部提供服务，并且Leader进行消息广播。如果有新节点，对新节点进行数据同步。<br>&emsp;&emsp;Zookeeper不需要得到全部的Follower的ACK，超过一般数量的ACK，就饿可以Commit。</p><hr><h1 id="协议实现"><a href="#协议实现" class="headerlink" title="协议实现"></a>协议实现</h1><p>&emsp;&emsp;实际的实现跟上面有所不同，分为三个阶段，将发现和同步阶段合在一起。<br>&emsp;&emsp;实际分为，选举、恢复、广播三个阶段。</p><h2 id="选举阶段-1"><a href="#选举阶段-1" class="headerlink" title="选举阶段"></a>选举阶段</h2><p>&emsp;&emsp;选举阶段采用Fast Leader Election（FLE），会采用LastZxid最大的节点作为Leader，这样就省去了发现最新提议的阶段。<br>&emsp;&emsp;这是基于拥有最新提议的节点也拥有最新的提交记录。<br>&emsp;&emsp;称为Leader的条件：</p><ol><li>选epoch最大的。</li><li>epoch相等，选Zxid最大的。</li><li>若 epoch 和 zxid 相等，选择 server_id 最大的（zoo.cfg中的myid）。</li></ol><p>&emsp;&emsp;节点在选举开始时，都默认投票给自己，当接收其他节点的选票时，会根据上面的Leader条件 判断并且更改自己的选票，然后重新发送选票给其他节点。当有一个节点的得票超过半数，该节点会设置自己的状态为Leading ，其他节点会设置自己的状态为Following。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E9%80%89%E4%B8%BE.png" alt="选举"></p><h2 id="恢复阶段"><a href="#恢复阶段" class="headerlink" title="恢复阶段"></a>恢复阶段</h2><p>&emsp;&emsp;这一阶段Follower发送他们的lastZxid给Leader，Leader根据lastZxid决定如何同步数据。这里的实现跟前面的Phase 2有所不同：Follower收到TRUNC指令会终止L.lastCommitedZxid之后的Proposal，收到DIFF指令会接收新的Proposal。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E6%81%A2%E5%A4%8D.png" alt="恢复"></p><hr><h1 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h1><h2 id="已经被处理的请求不能丢"><a href="#已经被处理的请求不能丢" class="headerlink" title="已经被处理的请求不能丢"></a>已经被处理的请求不能丢</h2><p>&emsp;&emsp;就是发送Commit提交消息时，挂掉了。</p><ol><li>选举拥有proposal最大值（即zxid最大）的节点作为新的 leader。<blockquote><p>zxid最大也就是数据最新的节点保存了所有被COMMIT消息的proposal状态。</p></blockquote></li><li>新的leader将自己事务日志中proposal但未COMMIT的消息处理。</li><li>新的leader与follower建立先进先出的队列，先将自身有而 follower没有的proposal发送给follower，再将这些proposal的COMMIT命令发送给follower，以保证所有的follower都保存了所有的proposal、所有的follower都处理了所有的消息。通过以上策略，能保证已经被处理的消息不会丢。</li></ol><h2 id="没被处理的请求需要丢失"><a href="#没被处理的请求需要丢失" class="headerlink" title="没被处理的请求需要丢失"></a>没被处理的请求需要丢失</h2><p>&emsp;&emsp;当leader接收到消息请求生成proposal后就挂了，其他follower并没有收到此proposal，因此经过恢复模式重新选了leader后，这条消息是被跳过的。此时，之前挂了的leader重新启动并注册成了follower，他保留了被跳过消息的proposal状态，与整个系统的状态是不一致的，需要将其删除。<br>&emsp;&emsp;Zxid的设计的好处是旧的leader挂了后重启，它不会被选举为leader，因为此时它的zxid肯定小于当前的新leader。当旧的leader作为follower接入新的leader后，新的leader会让它将所有的拥有旧的epoch号的未被COMMIT的proposal清除。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;ZAB协议包括了两种基本模式：崩溃恢复，数据广播。&lt;br&gt;&amp;emsp;&amp;emsp;一旦Leader服务器出现崩溃或者由于网络原因导致Leader服务器失去了与过半Follower的联系，那么就会进入崩溃恢复模式。&lt;br&gt;&amp;emsp;&amp;emsp;崩溃恢复主要包括两部分：Leader选举和数据恢复。&lt;/p&gt;</summary>
    
    
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/categories/zookeeper/"/>
    
    
    <category term="分布式" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="zookeeper" scheme="http://linqiankun.gitee.io/hexoblog/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>HTTP HTTPS HTTP2</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/08/md/internet/HTTP-HTTPS-HTTP2/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/08/md/internet/HTTP-HTTPS-HTTP2/</id>
    <published>2021-05-08T08:17:13.000Z</published>
    <updated>2021-05-24T08:09:48.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>&emsp;&emsp;超文本传输协议，是从web服务器传输超文本标记语言到本地浏览器的传送协议，默认工作在80端口。</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;HTTP是一个基于TCP/IP协议来传输数据的应用层协议，传输的数据类型可以为，html文件、图片文件、查询结果等。<br>&emsp;&emsp;HTTP一般用于B/S架构（浏览器、服务器），浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。</p><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><ol><li>建立TCP/IP连接，客户端与服务器通过Socket三次握手进行连接。</li><li>客户端向服务端发起HTTP请求。</li><li>客户端发送请求头信息，请求内容，最后会发送一空白行，标示客户端请求完毕。</li><li>服务器做出应答，表示对于客户端请求的应答。</li><li>服务器向客户端发送应答头信息。</li><li>服务器向客户端发送请求头信息后，也会发送一空白行，标示应答头信息发送完毕，接着就以Content-type要求的数据格式发送数据给客户端。</li><li>服务端关闭TCP连接，如果服务器或者客户端增Connection:keep-alive就表示客户端与服务器端继续保存连接，在下次请求时可以继续使用这次的连接。</li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>HTTP协议支持客户端/服务端模式，也是一种请求/响应模式的协议。</li><li>简单快速，客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。</li><li>灵活：HTTP允许传输任意类型的数据对象。传输的类型由Content-Type加以标记。</li><li>无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录http状态的技术，一个叫做Cookie,一个叫做Session。</li><li>无状态：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>数据明文传输，容易被窃听截取</li><li>数据的完整性未校验，容易被篡改</li><li>双方没有验证身份，有冒充对方的风险</li></ol><h2 id="URL与URI"><a href="#URL与URI" class="headerlink" title="URL与URI"></a>URL与URI</h2><ul><li>URL：统一资源定位符。</li><li>URI：统一资源标识符。</li></ul><p>&emsp;&emsp;URL是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的URL。<br>&emsp;&emsp;URI是用来标示 一个具体的资源的，我们可以通过URI知道一个资源是什么。<br>&emsp;&emsp;HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接。</p><h2 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h2><ol><li>都包含请求头请求行，post多了请求body。</li><li>get多用来查询，请求参数放在url中，不会对服务器上的内容产生作用。post用来提交，如把账号密码放入body中。</li><li>GET是直接添加到URL后面的，直接就可以在URL中看到内容，而POST是放在报文内部的，用户无法直接看到。</li><li>GET提交的数据长度是有限制的，因为URL长度有限制，具体的长度限制视浏览器而定。而POST没有。</li></ol><hr><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>&emsp;&emsp;HTTPS就是为了解决上面HTTP的问题。默认工作在443端口。<br>&emsp;&emsp;HTTPS协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为HTTP+SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p><h2 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h2><p>&emsp;&emsp;SSL：安全套接字层，SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。<br>&emsp;&emsp;TLS：传输层安全，其前身是SSL，后来改名，目前使用最广泛的是TLS 1.1、TLS 1.2。</p><h2 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h2><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/https%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90.png" alt="密钥生成流程"></p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%B5%81%E7%A8%8B.gif" alt="数据传输"></p><ol><li>首先客户端通过URL访问服务器建立SSL连接。</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。（这个证书其实就是公钥，只是包含了很多信息）</li><li>客户端的服务器开始协商SSL连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。（会话密钥就是第一张图的随机key）</li><li>服务器利用自己的私钥解密出会话密钥，这里就是连接建立完成。</li><li>服务器利用会话密钥加密与客户端之间的通信。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>HTTPS协议多次握手，导致页面加载时间延长。</li><li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗。</li><li>SSL证书需要付费。</li><li>SSL涉及到的安全算法会消耗CPU资源，对服务器资源消耗较大。</li><li>技术难度相比HTTP大。</li><li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li><li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li></ol><h2 id="总结HTTPS和HTTP的区别"><a href="#总结HTTPS和HTTP的区别" class="headerlink" title="总结HTTPS和HTTP的区别"></a>总结HTTPS和HTTP的区别</h2><ol><li>HTTP明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li><li>使用HTTPS协议需要到CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy和GlobalSign等。</li><li>HTTP页面响应速度比HTTPS快，主要是因为HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包，而HTTPS除了TCP的三个包，还要加上ssl握手需要的9个包，所以一共是12个包。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>HTTPS其实就是建构在SSL/TLS之上的HTTP协议，所以，要比较HTTPS比HTTP要更耗费服务器资源。</li></ol><hr><h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><p>&emsp;&emsp;HTTP/2.0的目标是改善用户在使用Web时的速度体验。</p><h2 id="新特点"><a href="#新特点" class="headerlink" title="新特点"></a>新特点</h2><p><a href="https://juejin.cn/post/6844903545532071943">HTTP2.0新特性</a><br><a href="https://www.jianshu.com/p/1afebe13c63e">HTTPS和HTTP2.0详解</a><br><a href="https://www.jsahz.com/wz/15616.html">HTTP 2.0 详细介绍</a></p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>&emsp;&emsp;相对于HTTP1.0和HTTP1.1，2.0在应用层与传输层中间增加了一个二进制分帧层。<br>&emsp;&emsp;在二进制分帧层上，HTTP2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装。其中，HTTP1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。<br>&emsp;&emsp;HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流，相应的每个数据流以消息的形式发送。而消息由一或多个帧组成，这些帧可以乱序发送，然后根据每个帧首部的流标识符重新组装。  </p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>&emsp;&emsp;HTTP1.x每次通讯（请求或响应）都会携带首部信息用于描述资源属性。而HTTP2.0在客户端和服务端之间使用首部表来跟踪和存储之前发送的键值对。请求与响应首部的定义在HTTP2.0中基本没有变，只是所有首部键必须全部小写，而且要求行要独立为:method:、:scheme:、:host:、:path:这些键值对。<br>&emsp;&emsp;HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields（首部表）表，既避免了重复header的传输，又减小了需要传输的大小。</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>&emsp;&emsp;使报头更紧凑，更快速传输，有利于移动网络环境。减少每次通讯的数据量，使网络拥塞状态得以改善。</p><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><p>&emsp;&emsp;对于相同的数据，不再重新通过每次请求和响应发送。每个新的首部键值对要么追加到当前表的末尾，要么替换表中之前的值。首部表在HTTP2.0的链接存续期内始终存在，由客户端和服务端共同渐进的更新。</p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>&emsp;&emsp;HTTP2.0为数据流和连接的流量提供了一个简单的机制：</p><ol><li>流量基于HTTP链接的每一跳进行，而非端到端的控制。</li><li>流量控制基于窗口更新帧进行，即接收方广播自己准备接收某个数据流的多少字节，以及对整个链接要接收多少个字节。</li><li>流量控制有方向性，即接收方可能根据自己的情况为每个流乃至整个链接设置任意窗口大小。</li><li>流量控制可以由接收方禁用，包括针对个别的流和针对整个链接。</li><li>帧的类型决定了流量控制是否适用于帧，目前只有DATA帧服从流量控制，所有其他类型的帧并不会消耗流量控制窗口的空间。这保证了重要的控制帧不会被流量控制阻塞。</li></ol><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>&emsp;&emsp;基于二进制分帧层，HTTP2.0可以在共享TCP链接的基础上同时发送请求和响应。HTTP消息被分解为独立的帧，而不破坏消息本身的语义，交错发出去，在另一端根据流标识符和首部将他们重新组装起来。<br>&emsp;&emsp;即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面。</p><h4 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h4><ol><li>可以并行交错的发送请求和响应，这些请求和响应之间互不影响。</li><li>只使用一个链接即可并行发送多个请求和响应。</li><li>消除不必要的延迟，从而减少页面加载的时间。</li><li>不必再为绕过HTTP1.x限制而多做很多工作。</li></ol><h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>&emsp;&emsp;HTTP消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。</p><h4 id="优化-2"><a href="#优化-2" class="headerlink" title="优化"></a>优化</h4><p>&emsp;&emsp;服务器可以根据流的优先级控制资源分配（CPU、内存、宽带），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。浏览器可以在发现资源时立即分派请求，指定每个流的优先级，让服务器决定最优的响应次序。这样请求就不用排队了，既节省了时间，又最大限度的利用了每个连接。</p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>&emsp;&emsp;服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。<br>&emsp;&emsp;服务端根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。</p><h4 id="优化-3"><a href="#优化-3" class="headerlink" title="优化"></a>优化</h4><ol><li>减轻数据传送的冗余步骤。</li><li>加快页面响应速度。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;超文本传输协议，是从web服务器传输超文本标记语言到本地浏览器的传送协议，默认工作在80端口。&lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="HTTP" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E7%BD%91%E7%BB%9C/HTTP/"/>
    
    
    <category term="HTTP" scheme="http://linqiankun.gitee.io/hexoblog/tags/HTTP/"/>
    
    <category term="网络" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP与UDP</title>
    <link href="http://linqiankun.gitee.io/hexoblog/2021/05/07/md/internet/TCP%E4%B8%8EUDP/"/>
    <id>http://linqiankun.gitee.io/hexoblog/2021/05/07/md/internet/TCP%E4%B8%8EUDP/</id>
    <published>2021-05-07T08:22:52.000Z</published>
    <updated>2021-05-24T09:09:29.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;TCP是传输控制协议，UDP是用户数据报协议，均处在传输层。  </p><span id="more"></span><hr><h1 id="TCP-amp-UDP"><a href="#TCP-amp-UDP" class="headerlink" title="TCP&amp;UDP"></a>TCP&amp;UDP</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>&emsp;&emsp;TCP的目的是提供可靠的数据传输，并在相互进行通信的设备或服务之间保持一个虚拟连接。<br>&emsp;&emsp;TCP在数据包接收无序、丢失或在交付期间被破坏时，负责数据恢复。它通过为其发送的每个数据包提供一个序号来完成此恢复。<br>&emsp;&emsp;为确保正确地接收数据，TCP要求在目标计算机成功收到数据时发回一个确认（即 ACK）。如果在某个时限内未收到相应的 ACK，将重新传送数据包。如果网络拥塞，这种重新传送将导致发送的数据包重复。但是，接收计算机可使用数据包的序号来确定它是否为重复数据包，并在必要时丢弃它。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>&emsp;&emsp;UDP 与 TCP 的主要区别在于 UDP 不一定提供可靠的数据传输。<br>&emsp;&emsp;该协议不能保证数据准确无误地到达目的地。<br>&emsp;&emsp;许多程序将使用单独的TCP连接和单独的UDP连接。重要的状态信息随可靠的TCP连接发送，而主数据流通过UDP发送。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><a href="https://blog.csdn.net/qq_19525389/article/details/81502805">TCP和UDP、流量控制和拥塞控制</a><br><a href="https://blog.csdn.net/HuoqilinHeiqiji/article/details/89711111?spm=1001.2014.3001.5501">TCP、UDP区别和联系</a><br><a href="https://blog.csdn.net/jackson0714/article/details/110532400">怎么用 UDP 实现 TCP？</a></p><ol><li><strong>TCP面向连接，UDP无连接</strong>。建立TCP连接需要经过3次握手，释放TCP连接需要经过4次挥手。UDP是无连接的，即发送数据前不需要建立连接。</li><li><strong>TCP提供可靠的服务，UDP尽最大努力交付，不提供可靠的服务</strong>。TCP提供可靠的服务，通过TCP连接传输的数据，无差错，不重复，不丢失，且按顺序到达。UDP尽最大努力交付，不保证可靠交付。Tcp通过校验和重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li><strong>每一条TCP连接只能是点对点的，UDP可以是一对一，一对多，多对多的交互通信</strong>。</li><li><strong>TCP对系统资源要求比较多，UDP对系统资源要求比较少</strong>（这里主要是首部开销）。</li><li><strong>TCP面向字节流，UDP面向报文</strong>。</li><li>TCP提供全双工通信。</li><li>UDP没有拥塞机制，即网络拥塞不会使源主机的发送效率降低。</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>&emsp;&emsp;对实时性要求比较高，网络质量要求不高，或者多点通信的时候就需要使用UDP。<br>&emsp;&emsp;当对网络通信质量要求比较高的时候就需要用TCP。</p><table><thead><tr><th>应用</th><th>应用层协议</th><th>传输层协议</th></tr></thead><tbody><tr><td>名字转换</td><td>DNS域名系统</td><td>UDP</td></tr><tr><td>文件传送</td><td>TFTP简单文件传送协议</td><td>UDP</td></tr><tr><td>路由选择协议</td><td>RIP路由信息协议</td><td>UDP</td></tr><tr><td>IP地址管理</td><td>DHCP动态主机配置协议</td><td>UDP</td></tr><tr><td>网络管理</td><td>SNMP简单网络管理协议</td><td>UDP</td></tr><tr><td>远程文件服务器</td><td>NFS网络文件系统</td><td>UDP</td></tr><tr><td>多播</td><td>IGMP网际组管理协议</td><td>UDP</td></tr><tr><td>电子邮件</td><td>SMTP简单邮件传送协议</td><td>TCP</td></tr><tr><td>远程终端接入</td><td>TELNET远程终端协议</td><td>TCP</td></tr><tr><td>万维网</td><td>HTTP超文本传送协议</td><td>TCP</td></tr><tr><td>文件传送</td><td>FTP文件传送协议</td><td>TCP</td></tr></tbody></table><hr><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="如何用UDP实现TCP"><a href="#如何用UDP实现TCP" class="headerlink" title="如何用UDP实现TCP?"></a>如何用UDP实现TCP?</h2><p>&emsp;&emsp;根据TCP于UDP的区别进行补全即可。<br>&emsp;&emsp;采用三次或者四次UDP数据模拟三次握手和四次挥手，然后补全其他的确认机制等。<br>&emsp;&emsp;实现方式：</p><ol><li>将实现放到应用层，然后类似TCP，实现确认机制，重传机制，和窗口确认机制，即在应用层实现确认重传这些。</li><li>给数据包进行编号，按顺序接收并存储，接收端收到数据包后发送确认信息给发送端，发送端接收到确认信息后继续发送，若接收端接收的数据不是期望的顺序编号，则要求重发；（主要解决丢包和包无序的问题）。</li></ol><h2 id="TCP如何保证可靠传输？"><a href="#TCP如何保证可靠传输？" class="headerlink" title="TCP如何保证可靠传输？"></a>TCP如何保证可靠传输？</h2><p>&emsp;&emsp;TCP通过序列号、检验和、确认应答信号、重发控制、连接管理、窗口控制、流量控制、拥塞控制实现可靠性。</p><ol><li>应用数据被分割成TCP认为最适合发送的数据块。</li><li>TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。用于进行<strong>顺序控制</strong>。</li><li><strong>检验和</strong>：TCP包首部和数据计算得到的检验和，接收方会对这个检验和进行验证，如果有差错，TCP将丢弃这个报文段，并且不对这个报文段进行确认。</li><li>TCP的接收端会丢弃重复接收的数据。但是会<strong>发送确认</strong>，属于停止等待协议。</li><li><strong>流量控制</strong>：针对高效传输，TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。（TCP利用<strong>滑动窗口</strong>实现流量控制）</li><li><strong>拥塞控制</strong>：当网络拥塞时，减少数据的发送。开始启动时，有慢启动算法，防止启动时发送大量数据造成网络拥塞。</li><li><strong>停止等待协议</strong>：它的基本原理就是每发完一个分组就- 停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传</strong>：针对数据包丢失或者定时器超时。当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h2 id="URL访问网站时全过程？"><a href="#URL访问网站时全过程？" class="headerlink" title="URL访问网站时全过程？"></a>URL访问网站时全过程？</h2><p><a href="https://blog.csdn.net/accepted_accepted/article/details/107997540">浏览器输入URL到响应页面的全过程</a></p><p>&emsp;&emsp;这个过程基本分为：</p><ol><li>输入URL域名[<a href="http://www.baidu.com]">www.baidu.com]</a></li><li>域名解析成IP地址<ol><li>查找浏览器缓存，返回IP地址</li><li>查找系统缓存，返回IP地址（hosts文件）</li><li>路由器查找路由器缓存，返回IP地址</li><li>递归查询，本地域名服务器查询缓存，返回IP</li><li>迭代查询，本地域名服务器向跟域名查询</li><li>根域名服务器不返回直接的IP地址，根域名服务器告诉本地域名服务器，下一次应查询的顶级域名服务器dns.com的IP地址。</li><li>本地域名服务器向顶级域名服务器dns.com进行查询。</li><li>顶级域名服务器dns.com告诉本地域名服务器，下一次应查询的权限域名服务器dns.baidu.com的IP地址。</li><li>本地域名服务器向权限域名服务器dns.baidu.com进行查询。</li><li>权限域名服务器dns.baidu.com告诉本地域名服务器，所查询的主机<a href="http://www.baidu.com的ip地址./">www.baidu.com的IP地址。</a></li><li>本地域名服务器将查询结果返回客户主机，并加入自己的缓存。</li></ol></li><li>与目的主机进行TCP连接（三次握手建立连接）<ol><li>客户主机发出建立连接的请求</li><li>目的主机发出确认及建立连接的信息</li><li>客户主机发出确认信息</li></ol></li><li>发送与收取数据<ol><li>发送Http Request请求</li><li>应用服务器响应处理请求返回页面数据</li></ol></li><li>断开TCP连接（四次挥手释放连接）<ol><li>客户主机发送释放连接的请求</li><li>目的主机发出确认信息</li><li>目的主机发出释放连接的请求</li><li>客户主机发出确认信息，等待一段时间后释放链家</li></ol></li><li>客户端显示解析渲染</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;TCP是传输控制协议，UDP是用户数据报协议，均处在传输层。  &lt;/p&gt;</summary>
    
    
    
    <category term="网络" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="TCP" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E7%BD%91%E7%BB%9C/TCP/"/>
    
    <category term="UDP" scheme="http://linqiankun.gitee.io/hexoblog/categories/%E7%BD%91%E7%BB%9C/UDP/"/>
    
    
    <category term="网络" scheme="http://linqiankun.gitee.io/hexoblog/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="TCP" scheme="http://linqiankun.gitee.io/hexoblog/tags/TCP/"/>
    
    <category term="UDP" scheme="http://linqiankun.gitee.io/hexoblog/tags/UDP/"/>
    
  </entry>
  
</feed>
