<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Study</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="https://linqiankun.github.io/hexoblog/atom.xml" rel="self"/>
  
  <link href="https://linqiankun.github.io/hexoblog/"/>
  <updated>2021-07-01T08:26:22.287Z</updated>
  <id>https://linqiankun.github.io/hexoblog/</id>
  
  <author>
    <name>linqiankun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TODO</title>
    <link href="https://linqiankun.github.io/hexoblog/TODO/"/>
    <id>https://linqiankun.github.io/hexoblog/TODO/</id>
    <published>2022-12-31T15:59:59.000Z</published>
    <updated>2021-07-01T08:26:22.287Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><span id="more"></span><h2 id="QUEST-TODO"><a href="#QUEST-TODO" class="headerlink" title="QUEST_TODO"></a>QUEST_TODO</h2><ul><li><input disabled="" type="checkbox"> zk同时接收到创建节点请求</li><li><input disabled="" type="checkbox"> mysql分库分表</li></ul><h2 id="POSTS-TODO"><a href="#POSTS-TODO" class="headerlink" title="POSTS_TODO"></a>POSTS_TODO</h2><ul><li><input disabled="" type="checkbox"> rocketmq负载均衡代码</li><li><input disabled="" type="checkbox"> rocketmq消息可靠性消费重试代码</li><li><input disabled="" type="checkbox"> jekins安装和使用<ul><li><input disabled="" type="checkbox"> jekins安装过程</li><li><input disabled="" type="checkbox"> jekins基本使用</li></ul></li><li><input disabled="" type="checkbox"> B+树</li><li><input disabled="" type="checkbox"> deepin安装docker</li><li><input disabled="" type="checkbox"> jvm命令</li><li><input disabled="" type="checkbox"> jvm调优</li></ul><hr><h2 id="DRAFTS-TODO"><a href="#DRAFTS-TODO" class="headerlink" title="DRAFTS_TODO"></a>DRAFTS_TODO</h2><ul><li><input disabled="" type="checkbox"> AIO</li><li><input disabled="" type="checkbox"> kafka简介</li><li><input disabled="" type="checkbox"> rocketmq-Broker启动流程</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h1&gt;</summary>
    
    
    
    <category term="todo" scheme="https://linqiankun.github.io/hexoblog/categories/todo/"/>
    
    
    <category term="todo" scheme="https://linqiankun.github.io/hexoblog/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>网易一面（数据中台—java）</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E6%98%93%E4%B8%80%E9%9D%A2%EF%BC%88%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E2%80%94java%EF%BC%89/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E7%BD%91%E6%98%93%E4%B8%80%E9%9D%A2%EF%BC%88%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0%E2%80%94java%EF%BC%89/</id>
    <published>2021-07-03T11:55:15.000Z</published>
    <updated>2021-07-03T12:45:04.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>项目介绍</li><li>redis分布式锁怎么实现？</li><li>还有其他的实现思路？具体怎么实现？（数据库，zk）</li><li>redis分布式控制抢单，可不可以用数据库乐观锁？</li><li>数据库乐观锁怎么实现？</li><li>redis哨兵模式讲一下？</li><li>哨兵和机器间如何通信（ping，pong）?</li><li>哨兵如何选举leader?</li><li>mvcc讲一下？</li><li>mvcc的目的？原理？场景？</li><li>数据库隔离级别的作用？场景</li><li>redo log，undo log，bin log分别说一下？</li><li>这些是在什么阶段产生的？</li><li>mysql模块说一下？那些产生什么日志？</li><li>mysql索引讲一下？从你自己知道的角度讲？</li><li>聚簇索引和非聚簇索引的区别？</li><li>shiro讲一下？</li><li>shiro怎么存储session？</li><li>你们用shiro怎么存的（token）？</li><li>rocketmq和kafka的区别？</li><li>rocketmq怎么保证消息只会被一台机器消费？</li><li>jvm调优过没？</li><li>系统优化过没？</li><li>jvm垃圾回收器有哪些？</li><li>jvm垃圾回收算法有哪些？</li><li>项目中有什么印象深刻的？（异步获取结果）</li><li>用过大数据方面的东西没？（没有）</li><li>最近有在看什么书？</li><li>有什么想了解的？</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>多线程之死锁</title>
    <link href="https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/"/>
    <id>https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E6%AD%BB%E9%94%81/</id>
    <published>2021-07-02T07:46:24.000Z</published>
    <updated>2021-07-02T09:43:52.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;死锁是指两个或两个以上进程（在运行的过程中因争夺资源而造成的一种僵局），若无外力作用，这些线程，进程都将无法向前推进。</p><span id="more"></span><ul><li>参与死锁的进程（线程）至少为2个</li><li>参与死锁的进程（线程）均等待资源</li><li>参与死锁的进程（线程）至少有2个已经占有资源</li><li>死锁进程是系统中当前进程集合的一个子集</li><li>死锁会浪费大量系统资源，甚至导致系统崩溃</li></ul><hr><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p>&emsp;&emsp;所有的死锁都是对资源的争夺造成的，资源是一切的罪魁祸首。</p><h2 id="永久资源与临时资源"><a href="#永久资源与临时资源" class="headerlink" title="永久资源与临时资源"></a>永久资源与临时资源</h2><h3 id="永久资源"><a href="#永久资源" class="headerlink" title="永久资源"></a>永久资源</h3><p>&emsp;&emsp;永久资源可以被多次使用，如所有硬件。</p><ul><li>只能分配给一个进程使用，不允许多个进程共享</li><li>进程使用时，需按照请求资源、使用资源、释放资源的顺序</li><li>这种资源的数量是固定的，运行期间，不能创建，也不能销毁</li></ul><h3 id="临时资源"><a href="#临时资源" class="headerlink" title="临时资源"></a>临时资源</h3><p>&emsp;&emsp;是在运行期间动态创建和销毁的资源。</p><ul><li>数量在运行期间是不断变化的，有可能为0</li><li>在运行过程中，可以不断的创建这种资源，将它们放入缓冲区，增加资源数量</li><li>也可以在运行过程中，请求几个临时资源，用于运行中的消耗</li></ul><p>&emsp;&emsp;一般由生产者进程产生，消费者进程消耗，如何用于通信的消息。</p><h2 id="可抢占资源和不可抢占资源"><a href="#可抢占资源和不可抢占资源" class="headerlink" title="可抢占资源和不可抢占资源"></a>可抢占资源和不可抢占资源</h2><h3 id="可抢占资源"><a href="#可抢占资源" class="headerlink" title="可抢占资源"></a>可抢占资源</h3><p>&emsp;&emsp;可抢占资源指某进程在获得这类资源后，该类资源可以被其他进程或系统抢占，也就是大家共享，这类资源不会引起死锁。比如CPU和内存。</p><h3 id="不可抢占资源"><a href="#不可抢占资源" class="headerlink" title="不可抢占资源"></a>不可抢占资源</h3><p>&emsp;&emsp;一旦系统将某资源分配给该进程后，就不能将其强行收回，只能在进程使用完后自己释放。比如打印机。</p><hr><h1 id="死锁原因"><a href="#死锁原因" class="headerlink" title="死锁原因"></a>死锁原因</h1><ul><li>竞争不可抢占资源引起死锁<blockquote><p>通常系统中的不可抢占资源，其数量不足以满足同时运行，使得在运行过程中，会因资源抢占而进入僵局，造成死锁。</p></blockquote></li><li>竞争可消耗资源引起死锁</li><li>进程推进顺序不当引起死锁<blockquote><p>运行过程中，请求和释放资源的顺序不科学，也会造成死锁，我等你，你等我的情况。<br>信号量使用不当也会死锁，进程间彼此相互等待对方发来的消息，结果也会使得这 些进程间无法继续向前推进。</p></blockquote></li></ul><h2 id="不可抢占资源造成死锁"><a href="#不可抢占资源造成死锁" class="headerlink" title="不可抢占资源造成死锁"></a>不可抢占资源造成死锁</h2><h2 id="可消耗资源造成死锁"><a href="#可消耗资源造成死锁" class="headerlink" title="可消耗资源造成死锁"></a>可消耗资源造成死锁</h2><h2 id="推进不当造成死锁"><a href="#推进不当造成死锁" class="headerlink" title="推进不当造成死锁"></a>推进不当造成死锁</h2><hr><h1 id="死锁条件"><a href="#死锁条件" class="headerlink" title="死锁条件"></a>死锁条件</h1><h2 id="互斥条件"><a href="#互斥条件" class="headerlink" title="互斥条件"></a>互斥条件</h2><h2 id="不可剥夺条件"><a href="#不可剥夺条件" class="headerlink" title="不可剥夺条件"></a>不可剥夺条件</h2><h2 id="请求与保持"><a href="#请求与保持" class="headerlink" title="请求与保持"></a>请求与保持</h2><h2 id="循环等待"><a href="#循环等待" class="headerlink" title="循环等待"></a>循环等待</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;死锁是指两个或两个以上进程（在运行的过程中因争夺资源而造成的一种僵局），若无外力作用，这些线程，进程都将无法向前推进。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/categories/java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/tags/java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深圳雪球科技（NFC）二面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E6%B7%B1%E5%9C%B3%E9%9B%AA%E7%90%83%E7%A7%91%E6%8A%80%EF%BC%88NFC%EF%BC%89%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E6%B7%B1%E5%9C%B3%E9%9B%AA%E7%90%83%E7%A7%91%E6%8A%80%EF%BC%88NFC%EF%BC%89%E4%BA%8C%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-07-02T03:16:49.000Z</published>
    <updated>2021-07-02T07:19:47.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>目前情况<ol><li>姓名等个人信息</li><li>在职状态</li><li>薪资</li></ol></li><li>项目介绍<ol><li>业务</li><li>技术栈</li><li>遇到问题</li><li>如何解决</li></ol></li><li>redis分布式锁实现</li><li>redis模板（jedis、redisTemplate）</li><li>多线程<ol><li> 多线程死锁怎么解决</li><li> DeadLock</li><li>多线程线程数量设计<ol><li> 慢IO</li><li> CPU密集</li></ol></li></ol></li><li>项目中的多线程代码是你写的吗</li><li>线程池原理</li><li>后面的规划（技术，管理）</li><li>基建怎么建设（自建机房，阿里云）</li><li>发布流程（有发布系统，用jekins）</li><li>容器化<ol><li> 有没有容器化</li><li> k8s</li><li> docker使用</li><li> 目前是本地虚拟机没有容器化</li></ol></li><li>抗压能力，加班情况</li><li>为什么换工作</li><li>换工作选择什么行业</li></ol><p><img src="https://raw.githubusercontent.com/LinQiankun/picurl/main/java%E5%86%99%E9%9D%A2%E7%BB%8F%EF%BC%8C%E6%94%92%E4%BA%BA%E5%93%81_00.jpg" alt="写面经，攒人品"></p><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>MQ消息幂等</title>
    <link href="https://linqiankun.github.io/hexoblog/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/MQ%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89/"/>
    <id>https://linqiankun.github.io/hexoblog/md/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/MQ%E6%B6%88%E6%81%AF%E5%B9%82%E7%AD%89/</id>
    <published>2021-07-01T06:47:42.000Z</published>
    <updated>2021-07-01T08:08:12.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;MQ中的消息可靠性主要靠两个方面实现：</p><ol><li>消息落地</li><li>消息超时，重传，确认</li></ol><span id="more"></span><p>&emsp;&emsp;整个消息体系由<strong>发送端、服务端、存储设施、接收端</strong>四块结构构成。<br>&emsp;&emsp;为保证消息的可达性，超时、重传、确认机制可能导致消息总线、或者业务方 收到重复的消息，从而对业务产生影响。</p><p>&emsp;&emsp;<a href="../../../%E5%88%86%E5%B8%83%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E7%9A%84%E5%AE%9E%E7%8E%B0">幂等介绍</a></p><hr><h1 id="上半场幂等设计"><a href="#上半场幂等设计" class="headerlink" title="上半场幂等设计"></a>上半场幂等设计</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/mq%E4%B8%8A%E5%8D%8A%E5%9C%BA.png" alt="mq结构"></p><p>&emsp;&emsp;消息发送的上半场就是图中的1、2、3过程，表示了消息的发送，保存过程。<br>&emsp;&emsp;如果3丢失，发送端MQ-client超时后会重发消息，可能导致服务端MQ-server收到重复消息。</p><blockquote><p>这里的重新发送方是Client，而不是实际的业务发送方。</p></blockquote><p>&emsp;&emsp;此时重发是MQ-client发起的，消息的处理是MQ-server，为了避免步骤2落地重复的消息，对每条消息， MQ系统内部必须生成一个msgId，作为去重和幂等的依据。<br>&emsp;&emsp;这个msgId的规则必须是：</p><ol><li><p>全局唯一</p></li><li><p>MQ生成，具备业务无关性，对消息发送方和消息接收方屏蔽</p><p>&emsp;&emsp;有了这个msgId，就能保证上半场重发，也只有1条消息落到MQ-server的DB中，实现上半场幂等。<br>&emsp;&emsp;而业务方收到发送失败而重新发送的消息，对mq而言，会被认为是不同的消息（一条新的消息），只是这条重新发送的消息和上一条内容一样而已，这条重新发送的消息，会生成新的msgId。</p></li></ol><hr><h1 id="下半场幂等设计"><a href="#下半场幂等设计" class="headerlink" title="下半场幂等设计"></a>下半场幂等设计</h1><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/mq%E4%B8%8A%E5%8D%8A%E5%9C%BA.png" alt="mq结构"></p><p>&emsp;&emsp;消息消费的下半场就是图中的4、5、6过程，表示消息的投递，消费过程。<br>&emsp;&emsp;接收端MQ-client回ACK给服务端MQ-server，是消息消费业务方的主动调用行为，不能由MQ-client自动发起，因为MQ系统不知道消费方什么时候真正消费成功。<br>&emsp;&emsp;如果5丢失，服务端MQ-server超时后会重发消息，可能导致MQ-client收到重复的消息，这样有可能造成重复消费。<br>&emsp;&emsp;此时重发是MQ-server发起的，消息的处理是消息消费业务方，消息重发势必导致业务方重复消费，为了保证业务幂等性 ，业务消息体中，必须有一个biz-id，作为去重和幂等的依据。<br>&emsp;&emsp;这个biz-id的规则是：</p><ol><li>对于同一个业务场景，全局唯一</li><li>由业务消息发送方生成，业务相关，对MQ透明</li><li>由业务消息消费方负责判重，以保证幂等</li></ol><p>&emsp;&emsp;有了这个业务ID，才能够保证下半场消息消费业务方即使收到重复消息，也只有1条消息被消费，保证了幂等。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="上半场"><a href="#上半场" class="headerlink" title="上半场"></a>上半场</h2><p>&emsp;&emsp;MQ-client生成inner-msg-id，保证上半场幂等。<br>&emsp;&emsp;这个ID全局唯一，业务无关，由MQ保证。</p><h2 id="下半场"><a href="#下半场" class="headerlink" title="下半场"></a>下半场</h2><p>&emsp;&emsp;业务 发送方带入biz-id，业务 接收方去重保证幂等。<br>&emsp;&emsp;这个ID对单业务唯一，业务相关，对MQ透明。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>&emsp;&emsp;幂等性，不仅对MQ有要求，对业务上下游也有要求。<br>&emsp;&emsp;实际上，MQ只实现了自己内部的幂等性，对于业务的幂等性，消息重投之类的，MQ并没有做处理，业务的幂等性，需要自己手动实现。</p><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://www.cnblogs.com/chx9832/p/12325871.html">RocketMQ解决幂等性问题</a></li><li><a href="https://blog.csdn.net/gwd1154978352/article/details/80655338">RocketMQ——消息幂等问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;MQ中的消息可靠性主要靠两个方面实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息落地&lt;/li&gt;
&lt;li&gt;消息超时，重传，确认&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="消息中间件" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq/"/>
    
    
    <category term="消息中间件" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="rocketmq" scheme="https://linqiankun.github.io/hexoblog/tags/rocketmq/"/>
    
    <category term="幂等" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%B9%82%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>涂鸦智能一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E6%B6%82%E9%B8%A6%E6%99%BA%E8%83%BD%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E6%B6%82%E9%B8%A6%E6%99%BA%E8%83%BD%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-06-30T12:44:16.000Z</published>
    <updated>2021-07-01T05:51:45.803Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>项目介绍</li><li>线程创建的几个方式</li><li>callable的使用场景（*）</li><li>多线程情况下的资源安全（锁，*）</li><li>线程池的工作原理</li><li>服务调用的方式</li><li>dubbo的协议（*）</li><li>dubbo的序列化方式（*）</li><li>分布式事务<ol><li> 二阶段提交</li><li> mq事务消息</li></ol></li><li>jvm内存模型</li><li>redis分布式锁的问题（碰到过没有）</li><li>学习的方法</li><li>反问<ol><li> lot为什么需要客户管理系统</li><li> 技术栈</li></ol></li></ol><p><img src="https://raw.githubusercontent.com/LinQiankun/picurl/main/java%E5%86%99%E9%9D%A2%E7%BB%8F%EF%BC%8C%E6%94%92%E4%BA%BA%E5%93%81_00.jpg" alt="写面经，攒人品"></p><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>接口幂等的实现</title>
    <link href="https://linqiankun.github.io/hexoblog/md/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>https://linqiankun.github.io/hexoblog/md/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-06-30T08:42:13.000Z</published>
    <updated>2021-07-01T08:00:18.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是幂等"><a href="#什么是幂等" class="headerlink" title="什么是幂等"></a>什么是幂等</h1><p>&emsp;&emsp;接口幂等性的实质就是：<strong>接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的。</strong><br>&emsp;&emsp;有些接口天然支持幂等性，比如查询接口；而增加、更新、删除都要人工保持幂等性。</p><span id="more"></span><hr><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><p>&emsp;&emsp;全局的唯一ID，就是根据业务操作和内容生成一个全局ID，在执行操作之前，先根据这个全局唯一ID是否存在，来判断这个操作是否已经执行。<br>&emsp;&emsp;如果不存在则把全局ID，存储到存储系统中，比如Redis、Mysql等。如果存在表示该操作已经执行。  </p><p>&emsp;&emsp;全局唯一IP是一个通用方案，可以支持插入、更新、删除业务操作。</p><h2 id="去重表"><a href="#去重表" class="headerlink" title="去重表"></a>去重表</h2><p>&emsp;&emsp;适用于在业务中有唯一标识的插入场景中，比如一个订单只会支付一次，可以将订单ID作为唯一标识。<br>&emsp;&emsp;这时，我们就可以建一张去重表，并且把唯一标识作为唯一索引，在我们实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。</p><h2 id="插入唯一主键"><a href="#插入唯一主键" class="headerlink" title="插入唯一主键"></a>插入唯一主键</h2><p>&emsp;&emsp;这种适用于插入并且有唯一索引的情况，比如我们要关联商品品类，其中商品的ID和品类的ID可以构成唯一索引，并且在数据表中也增加了唯一索引。这时就可以使用InsertOrUpdate操作。</p><h2 id="多版本控制（MVCC）"><a href="#多版本控制（MVCC）" class="headerlink" title="多版本控制（MVCC）"></a>多版本控制（MVCC）</h2><p>&emsp;&emsp;这种适用于更新场景，通过在更新的接口中添加版本号来实现幂等。</p><h2 id="状态机控制"><a href="#状态机控制" class="headerlink" title="状态机控制"></a>状态机控制</h2><p>&emsp;&emsp;这种方法适合在有状态机流转的情况下，通过状态字段的值的大小来做幂等，状态只能顺着一个方向流转。</p><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://blog.csdn.net/yuhaiyang_1/article/details/81040967">什么是幂等，什么情况下需要幂等，如何实现幂等</a></li><li><a href="https://www.jianshu.com/p/22c788a04a95">幂等设计</a></li><li><a href="https://cloud.tencent.com/developer/article/1526642">如何做到接口的幂等性</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是幂等&quot;&gt;&lt;a href=&quot;#什么是幂等&quot; class=&quot;headerlink&quot; title=&quot;什么是幂等&quot;&gt;&lt;/a&gt;什么是幂等&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;接口幂等性的实质就是：&lt;strong&gt;接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的。&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;有些接口天然支持幂等性，比如查询接口；而增加、更新、删除都要人工保持幂等性。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://linqiankun.github.io/hexoblog/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="分布式" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="幂等" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%B9%82%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>深圳雪球科技（NFC）一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E6%B7%B1%E5%9C%B3%E9%9B%AA%E7%90%83%E7%A7%91%E6%8A%80%EF%BC%88NFC%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E6%B7%B1%E5%9C%B3%E9%9B%AA%E7%90%83%E7%A7%91%E6%8A%80%EF%BC%88NFC%EF%BC%89%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-06-25T10:20:43.000Z</published>
    <updated>2021-07-01T03:44:06.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>项目介绍</li><li>dubbo中如何找到调用的节点（服务调用过程）</li><li>zookeeper的选举机制</li><li>redis分布式锁原理</li><li>12306设计（自己关注点问题，感觉防止超卖）<ol><li>很多人抢票中的问题</li></ol></li><li>事务的隔离级别</li><li>用过oracle吗</li><li>你们用的隔离级别</li><li>一个事务读了数据，另一个修改了，再去读会，会不一样，这是那个级别会发生的问题</li><li>反问（公司规模，具体业务）</li></ol><p><img src="https://raw.githubusercontent.com/LinQiankun/picurl/main/java%E5%86%99%E9%9D%A2%E7%BB%8F%EF%BC%8C%E6%94%92%E4%BA%BA%E5%93%81_00.jpg" alt="写面经，攒人品"></p><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>B+树</title>
    <link href="https://linqiankun.github.io/hexoblog/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B+%E6%A0%91/"/>
    <id>https://linqiankun.github.io/hexoblog/md/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/B+%E6%A0%91/</id>
    <published>2021-06-24T02:09:57.000Z</published>
    <updated>2021-06-24T08:17:38.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据结构" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>端点科技一面面经</title>
    <link href="https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E7%AB%AF%E7%82%B9%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"/>
    <id>https://linqiankun.github.io/hexoblog/%E9%9D%A2%E7%BB%8F/%E7%AB%AF%E7%82%B9%E7%A7%91%E6%8A%80%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/</id>
    <published>2021-06-23T09:11:24.000Z</published>
    <updated>2021-07-01T03:39:32.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><span id="more"></span><p>写面经，攒人品</p><ol><li>自我介绍</li><li>项目介绍</li><li>项目中使用到的技术（亮点）</li><li>分布式锁<ol><li>redis实现与zk实现的区别</li><li>redis单机挂的情况</li><li>多应用服务器抢占redis锁，造成redis服务器CPU飙红</li></ol></li><li>Rocketmq - 使用场景</li><li>索引</li><li>B+树<ol><li>结构</li><li>如何优化查询</li><li>原理等</li></ol></li><li>CountDownLatch原理</li><li>线程池<ol><li> 线程池的参数</li></ol></li><li>非阻塞IO与阻塞IO</li></ol><p><img src="https://raw.githubusercontent.com/LinQiankun/picurl/main/java%E5%86%99%E9%9D%A2%E7%BB%8F%EF%BC%8C%E6%94%92%E4%BA%BA%E5%93%81_00.jpg" alt="写面经，攒人品"></p><hr><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="redis实现与zk实现的区别"><a href="#redis实现与zk实现的区别" class="headerlink" title="redis实现与zk实现的区别"></a>redis实现与zk实现的区别</h3><h3 id="redis单机挂的情况"><a href="#redis单机挂的情况" class="headerlink" title="redis单机挂的情况"></a>redis单机挂的情况</h3><p>&emsp;&emsp;redis单机挂的情况下，考虑使用集群作为分布式锁的载体，使用redlock作为分布式锁的实现，这里的集群采用redis cluster而不采用主从复制模式，主从复制模式下，故障转移可能导致锁丢失，cluster的几率小很多。</p><h3 id="多应用服务器抢占redis锁，造成redis服务器CPU飙红"><a href="#多应用服务器抢占redis锁，造成redis服务器CPU飙红" class="headerlink" title="多应用服务器抢占redis锁，造成redis服务器CPU飙红"></a>多应用服务器抢占redis锁，造成redis服务器CPU飙红</h3><p>&emsp;&emsp;redlock模式下，加分布式锁是给每一台redis服务器一台一台加锁的，加锁成功一半以后，就认为是分布式加锁成功。<br>&emsp;&emsp;检查当前锁状态只是一次读而已，写入锁也只是一次写入。本质上就是读写，另外单次锁状态的读取和写入数据量都很小。理论上来说你的业务量没有大到一定程度，锁的操作不会带来redis服务器的太多压力，如果有，那么你的其他业务的读写可能更要值得关注了。另外真有问题，就锁这一块的读写也不会引起CPU飙升。</p><h2 id="mysql种索引结构"><a href="#mysql种索引结构" class="headerlink" title="mysql种索引结构"></a>mysql种索引结构</h2><p>&emsp;&emsp;索引结构分为两种，Hash索引和B+树索引。</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h3 id="如何优化查询"><a href="#如何优化查询" class="headerlink" title="如何优化查询"></a>如何优化查询</h3><p>&emsp;&emsp;减少IO次数。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;面经&quot;&gt;&lt;a href=&quot;#面经&quot; class=&quot;headerlink&quot; title=&quot;面经&quot;&gt;&lt;/a&gt;面经&lt;/h1&gt;</summary>
    
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="https://linqiankun.github.io/hexoblog/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>redis缓存淘汰策略</title>
    <link href="https://linqiankun.github.io/hexoblog/md/redis/redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/"/>
    <id>https://linqiankun.github.io/hexoblog/md/redis/redis%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</id>
    <published>2021-06-22T07:28:26.000Z</published>
    <updated>2021-06-22T09:53:44.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;在redis中，如果定期删除漏掉了很多键，而又没有及时删除，很容易就会造成内存耗尽。<br>&emsp;&emsp;内存淘汰机制专门是处理在内存耗尽时，删除旧数据，保证新数据能保存成功。</p><span id="more"></span><hr><h1 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h1><p>&emsp;&emsp;redis提供了8种内存置换策略。</p><table><thead><tr><th>策略</th><th>解析</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集中挑选将要过期的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td>volatile-lfu</td><td>从已设置过期时间的数据集挑选使用频率最低的数据淘汰</td></tr><tr><td>allkeys-lru</td><td>从数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>allkeys-lfu</td><td>从数据集中挑选使用频率最低的数据淘汰</td></tr><tr><td>allkeys-random</td><td>从数据集（server.db[i].dict）中任意选择数据淘汰</td></tr><tr><td>no-enviction</td><td>当内存不足写入新数据时，写入操作会报错，同时不删除数据（默认策略）</td></tr></tbody></table><p>&emsp;&emsp;它们可以分为4类，lru、lfu、random、ttl。它们的触发条件都是内存使用达到阈值。</p><hr><h1 id="淘汰机制的实现"><a href="#淘汰机制的实现" class="headerlink" title="淘汰机制的实现"></a>淘汰机制的实现</h1><p>&emsp;&emsp;淘汰机制的实现主要就是用于过期主键的删除。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在redis中，如果定期删除漏掉了很多键，而又没有及时删除，很容易就会造成内存耗尽。&lt;br&gt;&amp;emsp;&amp;emsp;内存淘汰机制专门是处理在内存耗尽时，删除旧数据，保证新数据能保存成功。&lt;/p&gt;</summary>
    
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/categories/redis/"/>
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的MVCC</title>
    <link href="https://linqiankun.github.io/hexoblog/md/mysql/mysql%E4%B8%AD%E7%9A%84MVCC/"/>
    <id>https://linqiankun.github.io/hexoblog/md/mysql/mysql%E4%B8%AD%E7%9A%84MVCC/</id>
    <published>2021-06-21T09:55:39.000Z</published>
    <updated>2021-06-24T08:07:42.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;MVCC全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。</p><span id="more"></span><h2 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h2><ul><li><strong>当前读：</strong> 它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。像<code>select lock in share mode(共享锁); select for update, update, insert, delete(排他锁)</code>这些都是当前读。  </li><li><strong>快照读：</strong> 像不加锁的select操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行化，串行化会使得快照读退化成当前读。（串行化下，一切都是串行，不存在并发的情况）<blockquote><p>&emsp;&emsp;出现快照读是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即MVCC。<br>&emsp;&emsp;可以认为MVCC是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本</p></blockquote></li></ul><p>&emsp;&emsp;MVCC就是为了实现读写冲突不加锁，这里的读是快照读，当前读是一种加锁操作，是一种悲观锁。</p><h2 id="MVCC与读操作"><a href="#MVCC与读操作" class="headerlink" title="MVCC与读操作"></a>MVCC与读操作</h2><p>&emsp;&emsp;MVCC指的是<strong>维持一个数据的多个版本，使得读写操作没有冲突</strong>。<br>&emsp;&emsp;快照读就是MySQL为我们实现MVCC理想模型的一个具体功能；而当前读就是悲观锁的表现。<br>&emsp;&emsp;MVCC模型在MySQL中的具体实现则是由3个隐式字段，undo日志，Read View等去完成的。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><h3 id="数据库的并发情况"><a href="#数据库的并发情况" class="headerlink" title="数据库的并发情况"></a>数据库的并发情况</h3><p>&emsp;&emsp;数据库的并发情况分为三种：</p><ul><li>读-读：不存在任何问题，不需要并发控制。</li><li>读-写：有线程安全问题，可能会造成事务隔离性问题，脏读、幻读、不可重复读。</li><li>写-写：有线程安全问题，可能丢失更新，第一类、第二类丢失更新。</li></ul><h3 id="MVCC作用"><a href="#MVCC作用" class="headerlink" title="MVCC作用"></a>MVCC作用</h3><p>&emsp;&emsp;MVCC使用来解决<strong>读写</strong>冲突的<strong>无锁并发机制</strong>，也就是为事务分配单向增长的时间戳，为每一次修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库快照。</p><ul><li>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作不用阻塞读操作，提高了数据库并发读写的性能。</li><li>同时还可以解决脏读、幻读、不可重复读的问题，但不能解决丢失更新。</li></ul><p>&emsp;&emsp;可以使用<code>MVCC+悲观锁/乐观锁</code>来解决并发冲突问题。</p><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;MVCC的目的就是多版本并发控制，在数据中就是为了解决读写冲突。<br>&emsp;&emsp;的实现原理主要是依赖记录中的 3个隐式字段，undo日志，Read View来实现的。所以我们先来看看这个三个point的概念。</p><h2 id="隐式字段"><a href="#隐式字段" class="headerlink" title="隐式字段"></a>隐式字段</h2><p>&emsp;&emsp;数据库表除了我们定义的字段外，还有三个隐式字段：</p><ul><li>DB_TRX_ID：6Byte，最近修改或插入的事务ID，记录创建这条记录/最后一次修改该记录的事务ID。</li><li>DB_ROLL_PTR：7Byte，回滚指针，指向这条记录的上一个版本。</li><li>DB_ROW_ID：6Byte，隐含的自增主键，我们在没有指定主键的时候Innodb会使用隐式主键产生聚簇索引。</li></ul><h2 id="undo日志"><a href="#undo日志" class="headerlink" title="undo日志"></a>undo日志</h2><p>&emsp;&emsp;undo log日志主要分为两种：</p><ul><li>insert undo log：代表事务在插入新纪录时产生的undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃。</li><li>uodate undo log：事务在修改或者删除时产生的undo log，不仅在事务回滚时需要，在快照读时也需要，所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除。</li></ul><h2 id="Read-View"><a href="#Read-View" class="headerlink" title="Read View"></a>Read View</h2><p>&emsp;&emsp;Read View是在事务进行快照读的时候产生的，该事务会在快照读的那一刻会生成数据库事务的快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)。<br>&emsp;&emsp;Read View主要是用来做可见性判断的，即当我们某个事务执行快照读的时候，对该记录创建一个Read View读视图，把它比作条件用来判断当前事务能够看到哪个版本的数据，既可能是当前最新的数据，也有可能是该行记录的undo log里面的某个版本的数据。<br>&emsp;&emsp;Read View遵循一个可见性算法，主要是将要被修改的数据的最新记录中的DB_TRX_ID（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果DB_TRX_ID跟Read View的属性做了某些比较，不符合可见性，那就通过DB_ROLL_PTR回滚指针去取出Undo Log中的DB_TRX_ID再比较，即遍历链表的DB_TRX_ID（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的DB_TRX_ID, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新老版本。<br>&emsp;&emsp;不同的隔离级别生成Read View的时间是不一样的，可重复读是第一次读的时候生成的，之后每一次都是第一次的Read View，而读已提交则是每次都会生成。（这里是指当前读的时候）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;简单的说：是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据是一致的。根据事务开始的时间不同，每个事物对同一张表，同一时刻看到的数据可能是不一样的。</p><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://blog.csdn.net/SnailMann/article/details/94724197">【MySQL笔记】正确的理解MySQL的MVCC及实现原理</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;MVCC全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。&lt;/p&gt;</summary>
    
    
    
    <category term="数据库" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="mysql" scheme="https://linqiankun.github.io/hexoblog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"/>
    
    
    <category term="数据类型" scheme="https://linqiankun.github.io/hexoblog/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    <category term="mysql" scheme="https://linqiankun.github.io/hexoblog/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis过期键删除</title>
    <link href="https://linqiankun.github.io/hexoblog/md/redis/redis%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4/"/>
    <id>https://linqiankun.github.io/hexoblog/md/redis/redis%E8%BF%87%E6%9C%9F%E9%94%AE%E5%88%A0%E9%99%A4/</id>
    <published>2021-06-21T07:38:16.000Z</published>
    <updated>2021-06-29T07:25:22.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;Redis的过期键删除指的是，对redis中因有效时间到了而对失效数据的处理策略。<br>&emsp;&emsp;Redis的内存淘汰策略指的是，当操作系统分配给Redis的内存不够使用时，在有新数据存入时，对老数据的处理逻辑。</p><span id="more"></span><hr><h1 id="Redis的过期键删除策略"><a href="#Redis的过期键删除策略" class="headerlink" title="Redis的过期键删除策略"></a>Redis的过期键删除策略</h1><p>&emsp;&emsp;因为Redis时完全内存操作的，所以对其来说，内存资源是非常宝贵的，如果一些过期键不删除，就会造成内存资源的大量浪费。</p><h2 id="常见的删除策略"><a href="#常见的删除策略" class="headerlink" title="常见的删除策略"></a>常见的删除策略</h2><p>&emsp;&emsp;常见的删除策略有三种：</p><ol><li>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。</li><li>惰性删除：不主动处理过期键，等待每次从键空间中获取键时，判断该键是否过期，如果过期就删除该键，如果没有，就返回该键。</li><li>定期删除：每隔一定时间，程序对数据库进行一次检查，删除里面的过期键。</li></ol><h2 id="定时删除策略"><a href="#定时删除策略" class="headerlink" title="定时删除策略"></a>定时删除策略</h2><p>&emsp;&emsp;在设置键的同时，同时给该键创建一个定时器Timer，定时器会在键的过期时间来临时，立即对键进行删除操作。</p><ul><li>对内存是最友好的：通过定时器可以保证过期的键及时被删除，不浪费内存空间。</li><li>对CPU是最不友好的：在过期键比较多的情况下，删除过期键可能会占用大量的CPU时间，在内存不紧张但是CPU时间非常紧张的情况下，将CPU时间用在删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。</li><li>除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件，也就是说这个模式并不高效。</li></ul><h2 id="惰性删除策略"><a href="#惰性删除策略" class="headerlink" title="惰性删除策略"></a>惰性删除策略</h2><p>&emsp;&emsp;不主动处理键，每次获取键时，检查该键是否过期，如果过期就删除该键，如果没有，就返回该键。</p><ul><li>对CPU友好，程序只有在取出键时才会进行检查，这样可以保证只有非做不可的时候才会执行删除操作，而且只会删除相关的键，不会将CPU时间浪费在不相关的键上。</li><li>对内存是最不友好的，如果一个键已经过期，没有及时清除，就会占用大量的内存空间，这些内存空间并不会主动释放（除非内存空间不足，内存淘汰）。</li></ul><h2 id="定期删除策略"><a href="#定期删除策略" class="headerlink" title="定期删除策略"></a>定期删除策略</h2><p>&emsp;&emsp;这是定时删除和惰性删除的一种折中方式。<br>&emsp;&emsp;每隔一端时间，程序就对数据库进行一次检查，删除里面的过期键。检查多少个数据库，删除多少键则由算法决定。<br>&emsp;&emsp;<strong>并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，同时，通过定期删除过期键，也有效地减少了因为过期键而带来的内存浪费。</strong></p><p>&emsp;&ensp;定期删除的问题在于，确定删除操作的执行时间和频率:</p><ul><li>时间过长，频率过高会占用大量的CPU时间，会逐渐退化为定时删除策略。</li><li>时间太短，频率太少就不能及时删除过期数据，占用大量内存空间，会退化为惰性删除策略。</li></ul><hr><h1 id="过期键删除实现"><a href="#过期键删除实现" class="headerlink" title="过期键删除实现"></a>过期键删除实现</h1><p>&emsp;&emsp;Redis服务器实际上使用的是惰性删除策略和定期删除策略。</p><h2 id="惰性删除的实现"><a href="#惰性删除的实现" class="headerlink" title="惰性删除的实现"></a>惰性删除的实现</h2><p>&emsp;&emsp;过期键的惰性删除策略由<code>expireIfNeeded</code>函数实现，所有读写Redis数据库的操作在执行之前都会调用<code>expireIfNeeded</code>函数对键进行检查：</p><ul><li>如果输入键已经过期，那么将输入键从数据库中删除。</li><li>如果输入键未过期，那么不做任何处理。</li></ul><h2 id="定期删除的实现"><a href="#定期删除的实现" class="headerlink" title="定期删除的实现"></a>定期删除的实现</h2><p>&emsp;&emsp;过期键的定期删除策略由<code>activeExpireCycle</code>函数实现，每当Redis服务器周期性执行<code>serverCron</code>函数时，<code>activeExpireCycle</code>函数就会被调用，他在规定的时间内，分多次遍历服务器中的各个数据库（Redis共16个数据库），从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。（随机抽取的办法）<br>&emsp;&emsp;函数每次运行，会全局的遍历所有的数据库，本次检查0号数据库，下次检查1号数据库，直到15号库，又从0号库开始检查，这样保证每个库都被检查到。每次检查都会从检查的库中抽取一定数量的键来进行检查。<br>&emsp;&emsp;随机检查的键，一般由算法决定，比如LRU（最近最少使用），LFU（使用频率最低）。</p><hr><h1 id="过期键对备份文件的影响"><a href="#过期键对备份文件的影响" class="headerlink" title="过期键对备份文件的影响"></a>过期键对备份文件的影响</h1><h2 id="对RDB文件的影响"><a href="#对RDB文件的影响" class="headerlink" title="对RDB文件的影响"></a>对RDB文件的影响</h2><h3 id="生成RDB文件时"><a href="#生成RDB文件时" class="headerlink" title="生成RDB文件时"></a>生成RDB文件时</h3><p>&emsp;&emsp;在执行<code>save</code>命令或者<code>bgsave</code>命令进行持久化时，程序会对数据库中的键进行检查，<strong>已经过期的键不会保存在RDB文件中</strong>。  </p><h3 id="载入RDB文件时"><a href="#载入RDB文件时" class="headerlink" title="载入RDB文件时"></a>载入RDB文件时</h3><p>&emsp;&emsp;在启动Redis服务器时，如果服务器只开启了RDB持久化，那么服务器将会载入RDB文件：</p><ul><li>如果是主服务器，文件中过期的键则不会被加载进数据库中，未过期的键才会加载进数据库中。</li><li>如果是从服务器，则全被加载。（主从同步时，从服务器的数据会被清空）</li></ul><h2 id="对AOF文件的影响"><a href="#对AOF文件的影响" class="headerlink" title="对AOF文件的影响"></a>对AOF文件的影响</h2><h3 id="AOF文件写入"><a href="#AOF文件写入" class="headerlink" title="AOF文件写入"></a>AOF文件写入</h3><p>&emsp;&emsp;当过期键被惰性删除或者定期删除后，程序会向AOF文件追加一条DEL命令，显式记录该键已被删除。</p><h3 id="AOF文件重写"><a href="#AOF文件重写" class="headerlink" title="AOF文件重写"></a>AOF文件重写</h3><p>在执行AOF文件重写时，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。</p><hr><h1 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h1><p>&emsp;&emsp;服务器运行在集群模式下时，从服务器的过期键删除操作由主服务器控制：</p><ul><li>主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。</li><li>从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。</li><li>从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。</li></ul><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://blog.csdn.net/weixin_43934607/article/details/109591618">【Redis实现系列】过期键处理</a></li><li><a href="https://www.cnblogs.com/zwwhnly/p/12689792.html">Redis系列(五)：Redis的过期键删除策略</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;Redis的过期键删除指的是，对redis中因有效时间到了而对失效数据的处理策略。&lt;br&gt;&amp;emsp;&amp;emsp;Redis的内存淘汰策略指的是，当操作系统分配给Redis的内存不够使用时，在有新数据存入时，对老数据的处理逻辑。&lt;/p&gt;</summary>
    
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/categories/redis/"/>
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>缓存与数据库双写一致性</title>
    <link href="https://linqiankun.github.io/hexoblog/md/redis/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    <id>https://linqiankun.github.io/hexoblog/md/redis/%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7/</id>
    <published>2021-06-21T07:37:42.000Z</published>
    <updated>2021-06-22T07:54:34.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在缓存的使用中，通常会面临一个更新的问题，当数据源产生变化，如何去更新到数据库与缓存之中，并且尽量保证安全与性能。</p><span id="more"></span><p>&emsp;&emsp;读缓存的情况一般包括下面几种情况：</p><ol><li><strong>失效：</strong> 应用程序先从cache取数据，没有得到，则从数据库取数据，成功后，放到缓存中。</li><li><strong>命中：</strong> 应用程序先从cache中取数据，取到后返回。</li><li><strong>更新：</strong> 先把数据存到数据库中，成功后，再让缓存失效。</li></ol><p>&emsp;&emsp;读的地方没有争议，都是先读缓存，没有则取数据库数据，并写入缓存，但是写的地方就有了争议。</p><hr><h1 id="先更新缓存，再写数据库"><a href="#先更新缓存，再写数据库" class="headerlink" title="先更新缓存，再写数据库"></a>先更新缓存，再写数据库</h1><p>&emsp;&emsp;这种情况一般不考虑使用，在多线程情况下，会有线程安全问题。如：</p><ul><li>线程A更新了数据库</li><li>线程B更新了数据库</li><li>线程B更新了缓存</li><li>线程A更新了缓存</li></ul><p>&emsp;&emsp;正常情况下，A线程先更新的数据库，也应该先更新缓存，但是因为网络等原因，导致A更新缓存晚于B更新缓存，这种会导致数据库与缓存不一致，存在脏数据。</p><hr><h1 id="先删除缓存，在更新数据库"><a href="#先删除缓存，在更新数据库" class="headerlink" title="先删除缓存，在更新数据库"></a>先删除缓存，在更新数据库</h1><p>&emsp;&emsp;这种模式在一个写线程和一个读线程到来时也会发生线程安全问题，造成脏数据。</p><ul><li>线程A到来，删除缓存，需要进行写操作</li><li>线程B到来，查询发现缓存为空，就去查询数据库</li><li>线程B在数据库查到未更新前的旧值</li><li>线程B将查到的旧值写入缓存</li><li>线程A写入数据库，更新数据</li></ul><p>&emsp;&emsp;这种情况下，缓存的就是旧数据，而数据库则是新数据，造成脏数据，如果不设置缓存过期策略，这些数据就会成永久脏数据。<br>&emsp;&emsp;对于这种，一般采用延时双删的办法，就是在更新数据库后，过一段时间后在删除一次数据库。流程基本就是：</p><ul><li>先删除缓存</li><li>在更新数据库</li><li>休眠一段时间，在删除缓存，将休眠时间内的脏数据删除<blockquote><p>这个一段时间，一般需要指定为，读数据业务逻辑加一点点，就是稍大于读业务逻辑，在读写分离架构中，这个时间还需要加上主从同步时间。</p></blockquote></li></ul><p>&emsp;&emsp;这种主要会是有线程，在删除缓存后，和操作数据库的间隙中，进行读操作，而写数据库时，会有写锁无法读取，所以，等待一次读的时间，足够将间隙读操作造成的脏数据清理掉。<br>&emsp;&emsp;这种同步双删的策略，会导致吞吐量降低，毕竟改了库，一定会等待一段时间，可以重启一个线程，异步进行第二次删除。  </p><hr><h1 id="先更新数据库，在删除缓存"><a href="#先更新数据库，在删除缓存" class="headerlink" title="先更新数据库，在删除缓存"></a>先更新数据库，在删除缓存</h1><p>&emsp;&emsp;这种模式一般比较常用，也是facebook的策略。<br>&emsp;&emsp;这种模式在模拟情况下，一样会有并发问题，但实际上可以忽略不记。</p><ul><li>缓存刚好失效</li><li>A线程查询数据库得到一个旧值</li><li>B线程更新数据库</li><li>B线程删除缓存</li><li>A线程将查到的旧值，写入缓存</li></ul><p>&emsp;&emsp;这种情况只有在数据的读速度慢于写速度的情况下才会发生，这种一般不会发生。即使发生也可以用延时双删策略进行保证一致性。  </p><h2 id="删除失败导致脏数据"><a href="#删除失败导致脏数据" class="headerlink" title="删除失败导致脏数据"></a>删除失败导致脏数据</h2><p>&emsp;&emsp;上面两种策略，删除缓存失败了，或者延时双删，第二次失败，都会产生脏数据。<br>&emsp;&emsp;通过一个保障重试的机制来重试删除缓存。可以将需要删除的key放入消息队列中，利用消息队列的失败机制进行重试。</p><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/rjzheng/p/9041659.html">【原创】分布式之数据库和缓存双写一致性方案解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/59167071">Redis与Mysql双写一致性方案解析</a></li><li><a href="https://www.jianshu.com/p/2936a5c65e6b">如何保证数据库与缓存的双写一致性</a></li><li><a href="https://www.cnblogs.com/mseddl/p/11570647.html">浅析数据库与缓存的双写一致性问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;缓存由于其高并发和高性能的特性，已经在项目中被广泛使用。在缓存的使用中，通常会面临一个更新的问题，当数据源产生变化，如何去更新到数据库与缓存之中，并且尽量保证安全与性能。&lt;/p&gt;</summary>
    
    
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/categories/redis/"/>
    
    
    <category term="mysql" scheme="https://linqiankun.github.io/hexoblog/tags/mysql/"/>
    
    <category term="redis" scheme="https://linqiankun.github.io/hexoblog/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>juc之AQS源码二</title>
    <link href="https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E4%BA%8C/"/>
    <id>https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E4%BA%8C/</id>
    <published>2021-06-18T06:13:27.000Z</published>
    <updated>2021-06-29T09:58:50.682Z</updated>
    
    <content type="html"><![CDATA[<h1 id="共享方式"><a href="#共享方式" class="headerlink" title="共享方式"></a>共享方式</h1><p>&emsp;&emsp;juc之AQS源码一中讲了独占方式的源码，这里分析共享方式的源码。</p><span id="more"></span><h2 id="acquireShared共享方式获取资源"><a href="#acquireShared共享方式获取资源" class="headerlink" title="acquireShared共享方式获取资源"></a>acquireShared共享方式获取资源</h2><h3 id="acquireShared方法"><a href="#acquireShared方法" class="headerlink" title="acquireShared方法"></a>acquireShared方法</h3><p>&emsp;&emsp;acquireShared方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">doAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。<br>&emsp;&emsp;所以函数流程如下：</p><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回。</li><li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li></ol><h3 id="doAcquireShared方法"><a href="#doAcquireShared方法" class="headerlink" title="doAcquireShared方法"></a>doAcquireShared方法</h3><p>&emsp;&emsp;此方法用于将当前线程加入等待队列尾部休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 加入队列尾部</span>    <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 是否成功的标志</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 是否有外部中断的标志</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 拿到前驱节点</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 尝试获取资源</span>                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                    <span class="token comment">// 如果有剩余资源唤醒后面的线程，这里就是和独占式的区别</span>                    <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>                    <span class="token comment">// 如果有外部中断，补充中断</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>interrupted<span class="token punctuation">)</span>                        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这个方法和acquireQueued方法很相似，只不过这里将补充中断的位置搬进来了。</p><h3 id="setHeadAndPropagate方法"><a href="#setHeadAndPropagate方法" class="headerlink" title="setHeadAndPropagate方法"></a>setHeadAndPropagate方法</h3><p>&emsp;&emsp;这个方法在自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> propagate<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// Record old head for check below</span>    <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>propagate <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">||</span> h <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>        <span class="token punctuation">(</span>h <span class="token operator">=</span> head<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment">// 这里调用了唤醒线程的方法，唤醒后面的线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">isShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;基本流程：</p><ol><li><code>tryAcquireShared()</code>尝试获取资源，成功则直接返回。</li><li>失败则通过<code>doAcquireShared()</code>进入等待队列<code>park()</code>，直到被<code>unpark()/interrupt()</code>并成功获取到资源才返回。整个等待过程也是忽略中断的。</li></ol><p>&emsp;&emsp;跟acquire的流程相似，多了个自己拿到资源后，还回去唤醒后面的线程。</p><h2 id="releaseShared共享方式释放资源"><a href="#releaseShared共享方式释放资源" class="headerlink" title="releaseShared共享方式释放资源"></a>releaseShared共享方式释放资源</h2><h3 id="releaseShared方法"><a href="#releaseShared方法" class="headerlink" title="releaseShared方法"></a>releaseShared方法</h3><p>&emsp;&emsp;此方法是共享模式下线程释放共享资源的顶层入口。<br>&emsp;&emsp;它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 尝试释放资源</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 唤醒后面的线程</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;释放掉资源后，唤醒后继。<br>&emsp;&emsp;跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求（只要有释放，就回去唤醒），共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。</p><h3 id="doReleaseShared方法"><a href="#doReleaseShared方法" class="headerlink" title="doReleaseShared方法"></a>doReleaseShared方法</h3><p>&emsp;&emsp;这个方法用于唤醒后继节点。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h <span class="token operator">!=</span> tail<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> ws <span class="token operator">=</span> h<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>            <span class="token comment">// 该状态表示后继节点需要唤醒</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token comment">// loop to recheck cases</span>                <span class="token comment">// 唤醒后继节点</span>                <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>                     <span class="token operator">!</span><span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>PROPAGATE<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token comment">// loop on failed CAS</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> head<span class="token punctuation">)</span>                   <span class="token comment">// loop if head changed</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;共享方式&quot;&gt;&lt;a href=&quot;#共享方式&quot; class=&quot;headerlink&quot; title=&quot;共享方式&quot;&gt;&lt;/a&gt;共享方式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;juc之AQS源码一中讲了独占方式的源码，这里分析共享方式的源码。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/categories/java/"/>
    
    <category term="juc" scheme="https://linqiankun.github.io/hexoblog/categories/java/juc/"/>
    
    <category term="AQS" scheme="https://linqiankun.github.io/hexoblog/categories/java/juc/AQS/"/>
    
    <category term="Java" scheme="https://linqiankun.github.io/hexoblog/categories/Java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/tags/java/"/>
    
    <category term="juc" scheme="https://linqiankun.github.io/hexoblog/tags/juc/"/>
    
    <category term="AQS" scheme="https://linqiankun.github.io/hexoblog/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>juc之AQS源码一</title>
    <link href="https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E4%B8%80/"/>
    <id>https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS%E6%BA%90%E7%A0%81%E4%B8%80/</id>
    <published>2021-06-17T09:31:48.000Z</published>
    <updated>2021-06-29T09:50:33.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两种资源共享方式"><a href="#两种资源共享方式" class="headerlink" title="两种资源共享方式"></a>两种资源共享方式</h1><p>&emsp;&emsp;AQS定义了两种资源共享方式：</p><ol><li>Exclusive：独占方式，只有一个线程能执行，如ReentrantLock。</li><li>Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier。</li></ol><span id="more"></span><p>&emsp;&emsp;对应的，在不同的资源共享模式下，就有了不同的源码。<br>&emsp;&emsp;值得注意的是，acquire()和acquireShared()两种方法下，线程在等待队列中都是忽略中断的。AQS也支持响应中断的，<code>acquireInterruptibly()/acquireSharedInterruptibly()</code>即是。</p><hr><h1 id="独占方式"><a href="#独占方式" class="headerlink" title="独占方式"></a>独占方式</h1><p>&emsp;独占方式下，获取资源与释放资源的一组为<code>acquire()</code>和<code>release()</code>方法。</p><h2 id="Acquire独占模式获取资源"><a href="#Acquire独占模式获取资源" class="headerlink" title="Acquire独占模式获取资源"></a>Acquire独占模式获取资源</h2><h3 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h3><p>&emsp;&emsp;acquire方法时独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响，获取到资源后线程就可以执行其临界区代码了。  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;函数流程如下：</p><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回（这里体现了非公平锁，每个线程获取锁时会尝试直接抢占加塞一次，而CLH队列中可能还有别的线程在等待）。</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式。</li><li>acquireQueued()使线程阻塞在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><h3 id="tryAcquire方法"><a href="#tryAcquire方法" class="headerlink" title="tryAcquire方法"></a>tryAcquire方法</h3><p>&emsp;&emsp;此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这个方法在AQS中定义了空方法体，需要各个自定义同步器自己去重写这个方法，如CountDownLatch的Sync。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里就是模板方法模式的典型应用。<br>&emsp;&emsp;这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。</p><h3 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h3><p>&emsp;&emsp;用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。这里会将每一个线程封装成一个Node，Node中有一个Tread属性用来保存当前线程。等待队列可以看作是一个双向链表，一个CLH队列，一个虚拟的双向队列。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span> mode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> mode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Try the fast path of enq; backup to full enq on failure</span>    <span class="token class-name">Node</span> pred <span class="token operator">=</span> tail<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pred <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">enq</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;enq方法将节点加入队尾。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Node</span> <span class="token function">enq</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// Must initialize</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetHead</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                tail <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> t<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetTail</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                t<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span> t<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="acquireQueued方法"><a href="#acquireQueued方法" class="headerlink" title="acquireQueued方法"></a>acquireQueued方法</h3><p>&emsp;&emsp;通过<code>tryAcquire()</code>和<code>addWaiter()</code>，该线程获取资源失败，已经被放入等待队列尾部了。<br>&emsp;&emsp;<code>acquireQueued()</code>用于<strong>在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回。</strong><br>&emsp;&emsp;进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 标记是否成功拿到资源，没有拿到资源</span>    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 标记等待过程中是否被中断过</span>        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token comment">// 拿到前驱节点</span>            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 如果前驱是head，即该结点已是第二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                <span class="token comment">// 拿到资源后，将自己设置为head，所以head指向的节点就是拿到资源的节点</span>                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 将head的前驱断开连接，就是为了放弃以前的有助于GC</span>                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>                <span class="token comment">// 成功拿到资源</span>                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token comment">// 返回等待过程中是否被中断，如果被中断了，就是获取失败了</span>                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token comment">// 如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待。</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// 表示被中断了</span>                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="shouldParkAfterFailedAcquire方法"><a href="#shouldParkAfterFailedAcquire方法" class="headerlink" title="shouldParkAfterFailedAcquire方法"></a>shouldParkAfterFailedAcquire方法</h4><p>&emsp;&emsp;这个方法主要用于检查状态，这里主要就是前驱节点的状态。<br>&emsp;&emsp;整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心去休息，需要去找个安心的休息点，同时可以再尝试下看有没有机会轮到自己拿号。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span><span class="token class-name">Node</span> pred<span class="token punctuation">,</span> <span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 拿到前驱的状态</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> pred<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">==</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span>        <span class="token comment">// 如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//  如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span>        <span class="token comment">//  注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span>        <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>            node<span class="token punctuation">.</span>prev <span class="token operator">=</span> pred <span class="token operator">=</span> pred<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>pred<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        pred<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// 如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>pred<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token class-name">Node</span><span class="token punctuation">.</span>SIGNAL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="parkAndCheckInterrupt方法"><a href="#parkAndCheckInterrupt方法" class="headerlink" title="parkAndCheckInterrupt方法"></a>parkAndCheckInterrupt方法</h4><p>&emsp;&emsp;这个方法用于将前驱节点的状态设置好后，真正进入等待状态。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 使线程进入waiting状态</span>    <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 清除中断状态</span>    <span class="token comment">//如果被唤醒，查看自己是不是被中断的。</span>    <span class="token keyword">return</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>&emsp;&emsp;acquireQueued方法的流程就是：</p><ol><li>结点进入队尾后，检查状态，找到安全休息点。</li><li>调用park()进入waiting状态，等待unpark()或interrupt()唤醒自己。</li><li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过。如果没拿到，继续流程1。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;整个流程就是：</p><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回。</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式。</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。<ol><li>这里检测自己是否能拿到资源，拿到就会返回</li><li>这里面会判断是否有被中断过</li><li>如果有被中断，这里面会清除中断过程，不响应中断，外面会将中断补上</li><li>如果没有被中断，这里面会返回false，表示没有中断，外面就不会补</li></ol></li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/AQSACquire.png" alt="acquire流程"></p><h2 id="Release独占模式释放资源"><a href="#Release独占模式释放资源" class="headerlink" title="Release独占模式释放资源"></a>Release独占模式释放资源</h2><h3 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h3><p>&emsp;&emsp;此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。<br>&emsp;&emsp;它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="tryRelease方法"><a href="#tryRelease方法" class="headerlink" title="tryRelease方法"></a>tryRelease方法</h3><p>&emsp;&emsp;跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。<br>&emsp;&emsp;正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可(state-=arg)，也不需要考虑线程安全的问题。<br>&emsp;&emsp;但要注意它的返回值，上面已经提到了，release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UnsupportedOperationException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="unparkSuccessor方法"><a href="#unparkSuccessor方法" class="headerlink" title="unparkSuccessor方法"></a>unparkSuccessor方法</h3><p>&emsp;&emsp;此方法用于唤醒等待队列中下一个线程。原理就是<strong>用unpark()唤醒等待队列中最前边的那个未放弃线程。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span><span class="token class-name">Node</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 这里，node一边为当前线程所在节点</span>    <span class="token keyword">int</span> ws <span class="token operator">=</span> node<span class="token punctuation">.</span>waitStatus<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ws <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token comment">//置零当前线程所在的结点状态，允许失败。</span>        <span class="token function">compareAndSetWaitStatus</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> ws<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 找到下一个需要唤醒的节点</span>    <span class="token class-name">Node</span> s <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token comment">// 如果为空或已取消</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> s<span class="token punctuation">.</span>waitStatus <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        s <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token comment">// 从后向前找</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span> t <span class="token operator">=</span> tail<span class="token punctuation">;</span> t <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> t <span class="token operator">!=</span> node<span class="token punctuation">;</span> t <span class="token operator">=</span> t<span class="token punctuation">.</span>prev<span class="token punctuation">)</span>            <span class="token comment">// 从这里可以看出，&lt;=0 的结点，都是还有效的结点，这里找到最前面的待唤醒的节点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>waitStatus <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                s <span class="token operator">=</span> t<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>        <span class="token comment">// 唤醒</span>        <span class="token class-name">LockSupport</span><span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里我们也用s来表示吧。此时，再和<code>acquireQueued()</code>联系起来，s被唤醒后，进入<code>if (p == head &amp;&amp; tryAcquire(arg))</code>的判断（即使p!=head也没关系，它会再进入<code>shouldParkAfterFailedAcquire()</code>寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过<code>shouldParkAfterFailedAcquire()</code>的调整，s也必然会跑到head的next结点，下一次自旋<code>p==head</code>就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>&emsp;&emsp;release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。<br>&emsp;&emsp;<strong>如果获取锁的线程在release时异常了，没有unpark队列中的其他结点，这时队列中的其他结点会怎么办？这时队列中的其他节点就没法被唤醒了。</strong> 产生异常的可能如下：</p><blockquote><ol><li>线程突然死掉了？可以通过thread.stop来停止线程的执行，但该函数的执行条件要严苛的多，而且函数注明是非线程安全的，已经标明Deprecated；</li><li>线程被interupt了？线程在运行态是不响应中断的，所以也不会抛出异常；</li><li>release代码有bug，抛出异常了？目前来看，Doug Lea的release方法还是比较健壮的，没有看出能引发异常的情形（如果有，恐怕早被用户吐槽了）。除非自己写的tryRelease()有bug，那就没啥说的，自己写的bug只能自己含着泪去承受了。</li></ol></blockquote><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;两种资源共享方式&quot;&gt;&lt;a href=&quot;#两种资源共享方式&quot; class=&quot;headerlink&quot; title=&quot;两种资源共享方式&quot;&gt;&lt;/a&gt;两种资源共享方式&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;AQS定义了两种资源共享方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Exclusive：独占方式，只有一个线程能执行，如ReentrantLock。&lt;/li&gt;
&lt;li&gt;Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier。&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/categories/java/"/>
    
    <category term="juc" scheme="https://linqiankun.github.io/hexoblog/categories/java/juc/"/>
    
    <category term="AQS" scheme="https://linqiankun.github.io/hexoblog/categories/java/juc/AQS/"/>
    
    <category term="Java" scheme="https://linqiankun.github.io/hexoblog/categories/Java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/tags/java/"/>
    
    <category term="juc" scheme="https://linqiankun.github.io/hexoblog/tags/juc/"/>
    
    <category term="AQS" scheme="https://linqiankun.github.io/hexoblog/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>juc之AQS</title>
    <link href="https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS/"/>
    <id>https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BAQS/</id>
    <published>2021-06-17T07:08:59.000Z</published>
    <updated>2021-06-29T08:58:19.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。<br>&emsp;&emsp;AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。</p><span id="more"></span><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;AQS的核心思想，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果请求的资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。<br>&emsp;&emsp;CLH（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。<br><strong>AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）</strong>，来实现锁的分配。<br>&emsp;&emsp;Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。  </p><p>&emsp;&emsp;<em>用大白话来说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</em></p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/AQS-CLH.png" alt="AQS原理"></p><p>&emsp;&emsp;实现了AQS的锁有：自旋锁、互斥锁、读锁写锁、条件产量、信号量、栅栏（Latch）都是AQS的衍生物。</p><hr><h1 id="两种资源共享方式"><a href="#两种资源共享方式" class="headerlink" title="两种资源共享方式"></a>两种资源共享方式</h1><p>&emsp;&emsp;AQS定义了两种资源共享方式：</p><ol><li>Exclusive：独占方式，只有一个线程能执行，如ReentrantLock。</li><li>Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier。</li></ol><p>&emsp;&emsp;AQS底层使用了模板方法模式，如果需要自定义同步器一般的方式是这样：</p><ol><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。如CountDownLatch中的Sync，在CountDownLatch中使用共有的Sync即可。</li></ol><p>&emsp;&emsp;自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了（AbstractQueuedSynchronizer中已经实现了）。自定义同步器实现的时候主要实现下面几种方法：</p><ul><li><strong>isHeldExclusively()：</strong> 该线程是否正在独占资源。只有用到condition才需要去实现它。</li><li><strong>tryAcquire(int)：</strong> 独占方式。尝试获取资源，成功则返回true，失败则返回false。</li><li><strong>tryRelease(int)：</strong> 独占方式。尝试释放资源，成功则返回true，失败则返回false。</li><li><strong>tryAcquireShared(int)：</strong> 共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li><li><strong>tryReleaseShared(int)：</strong> 共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li></ul><p>&emsp;&emsp;一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p><hr><h1 id="NODE节点"><a href="#NODE节点" class="headerlink" title="NODE节点"></a>NODE节点</h1><p>&emsp;&emsp;Node结点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值<strong>CANCELLED、SIGNAL、CONDITION、PROPAGATE、0</strong>。  </p><ul><li><strong>CANCELLED(1)：</strong> 表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li><li><strong>SIGNAL(-1)：</strong> 表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。</li><li><strong>CONDITION(-2)：</strong> 表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。</li><li><strong>PROPAGATE(-3)：</strong> 共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li><strong>0：</strong> 新结点入队时的默认状态。</li></ul><p>&emsp;&emsp;负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用&gt;0、&lt;0来判断结点的状态是否正常。</p><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.cnblogs.com/waterystone/p/4920797.html">Java并发之AQS详解</a></li><li><a href="https://blog.csdn.net/mulinsen77/article/details/84583716">AQS详解（面试）</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。&lt;br&gt;&amp;emsp;&amp;emsp;AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch…。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/categories/java/"/>
    
    <category term="juc" scheme="https://linqiankun.github.io/hexoblog/categories/java/juc/"/>
    
    <category term="AQS" scheme="https://linqiankun.github.io/hexoblog/categories/java/juc/AQS/"/>
    
    <category term="Java" scheme="https://linqiankun.github.io/hexoblog/categories/Java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/tags/java/"/>
    
    <category term="juc" scheme="https://linqiankun.github.io/hexoblog/tags/juc/"/>
    
    <category term="AQS" scheme="https://linqiankun.github.io/hexoblog/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>多线程基础概念</title>
    <link href="https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</id>
    <published>2021-06-16T08:59:16.000Z</published>
    <updated>2021-06-17T09:24:47.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h1><p><strong>进程：</strong> 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是<strong>系统进行资源分配和调度的基本单位</strong>，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p><strong>线程：</strong> 线程（thread）是操作系统能够<strong>进行运算<a href="https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6">调度</a>的最小单位</strong>。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位。线程分为用户线程和内核线程。</p><span id="more"></span><p><strong>多线程：</strong> 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p><p><strong>并行：</strong> 多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时运行。</p><p><strong>并发：</strong> 使用CPU调度算法，使用户看起来在同时运行，其实并不是在同时运行。并发一般发生在对系统中的公用资源操作时。</p><p><strong>线程安全：</strong> 指的是希望多线程的执行顺序对执行结果没有影响，用户只需要关心CPU及其他资源是否够用即可。反之，如果不同的执行顺序导致不同的执行结果，那么就说是线程不安全的。</p><p><strong>同步：</strong> 指通过人为干预的情况下达到线程安全的程度。</p><h2 id="进程VS线程："><a href="#进程VS线程：" class="headerlink" title="进程VS线程："></a>进程VS线程：</h2><ol><li> 地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li><li> 通信：通信方式不同，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</li><li> 调度和切换：线程上下文切换比进程上下文切换要快得多。</li><li> 在多线程OS中，进程不是一个可执行的实体。</li></ol><hr><h1 id="线程的状态："><a href="#线程的状态：" class="headerlink" title="线程的状态："></a>线程的状态：</h1><p>Java 给多线程编程提供了内置的支持。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.jpg" alt="线程状态切换"></p><p><strong>新建状态</strong>：一个新产生的线程从新状态开始了它的生命周期。它保持这个状态直到程序start这个线程。此过程线程并未执行。</p><p><strong>就绪状态</strong>：表明线程可以运行，但不是真的在运行，此状态下需要获取cpu才能运行。调用线程的star方法、获取到对象的锁，阻塞状态解除、cpu时间片用完，调用yield()方法、jvm中断此线程。</p><p><strong>运行状态</strong>：线程在阻塞状态获取到cpu使用权，开始实际执行。此状态线程进入run()方法执行方法体。</p><p><strong>阻塞状态</strong>：线程放弃了cpu，调用wait()，sleep()，或同步锁，同步代码块时，失去了所占用的资源，由运行态进入阻塞态，线程将会进入阻塞队列。执行了wait()方法后使线程进入到等待阻塞状态、在进入synchronized代码块，获取同步锁失败时进入同步阻塞、当调用sleep()，join()，或io时进入其它阻塞队列，等待sleep()结束，join()等待其它线程结束，io结束时继续进入就绪状态。</p><p><strong>死亡状态</strong>：线程结束运行后就进入死亡状态。死亡后不会再进入新生态，调用start()方法会报错。通常run()方法运行结束时死亡，或一个未捕获的异常导致猝死。</p><p><strong>超时等待</strong>：处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p><hr><h1 id="队列："><a href="#队列：" class="headerlink" title="队列："></a>队列：</h1><p>等待队列：线程wait()后进入等待队列，等待被其它线程使用notify()或notifyAll()唤醒。</p><p>同步队列：线程被唤醒后，进入同步同步队列，在此队列中，互相竞争对象的锁，当获取到对象的锁之后就进入了就绪状态等待获取cpu时间片运行。</p><hr><h1 id="线程优先级："><a href="#线程优先级：" class="headerlink" title="线程优先级："></a>线程优先级：</h1><p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p><p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p><p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p><p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p><hr><h1 id="参考资料-amp-鸣谢"><a href="#参考资料-amp-鸣谢" class="headerlink" title="参考资料 &amp; 鸣谢"></a>参考资料 &amp; 鸣谢</h1><ul><li><a href="https://my.oschina.net/linqiankun/blog/3193359">多线程之基础概念</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;概念：&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;进程：&lt;/strong&gt; 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是&lt;strong&gt;系统进行资源分配和调度的基本单位&lt;/strong&gt;，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程：&lt;/strong&gt; 线程（thread）是操作系统能够&lt;strong&gt;进行运算&lt;a href=&quot;https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6&quot;&gt;调度&lt;/a&gt;的最小单位&lt;/strong&gt;。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程是独立调度和分派的基本单位。线程分为用户线程和内核线程。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/categories/java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/categories/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/tags/java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>juc之CountDownLatch</title>
    <link href="https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BCountDownLatch/"/>
    <id>https://linqiankun.github.io/hexoblog/md/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/juc%E4%B9%8BCountDownLatch/</id>
    <published>2021-06-16T08:51:34.000Z</published>
    <updated>2021-06-17T06:45:11.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;根据文档：<strong>允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。</strong><br>&emsp;&emsp;一般被称为计数器，可以用做流程控制之类的作用。通常用来让一个线程等待其他的完成过后再继续执行。<br>&emsp;&emsp;通过一个计数器实现，计数器的初始值可以是线程的数量，每当一个线程执行完，计数器的值减一，当计数器的值为0时，表示所有线程都执行完毕，等待的线程就可以继续执行了。</p><span id="more"></span><hr><h1 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h1><p>&emsp;&emsp;一般来说有两种使用模式：</p><ol><li>作为启动信号，让多个线程等待</li><li>作为结束信号，让单个线程等待</li></ol><h2 id="作为启动信号，让多个线程等待"><a href="#作为启动信号，让多个线程等待" class="headerlink" title="作为启动信号，让多个线程等待"></a>作为启动信号，让多个线程等待</h2><p>&emsp;&emsp;实现多个线程开始执行任务的最大并行性，强调的是多个线程在某一时刻同时开始执行。<br>&emsp;&emsp;做法是初始化一个共享的CountDownLatch(1)，将其计算器初始化为1，多个线程在开始执行任务前首先countdownlatch.await()，当主线程调用countDown()时，计数器变为0，多个线程同时被唤醒。<br>&emsp;&emsp;将CountDownLatch的计数器初始化为new CountDownLatch(n)，每当一个任务线程执行完毕，就将计数器减1 countdownLatch.countDown()，当计数器的值变为0时，在CountDownLatch上await()的线程就会被唤醒。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token comment">//准备完毕……运动员都阻塞在这，等待号令</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">String</span> parter <span class="token operator">=</span> <span class="token string">"【"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"，时间："</span><span class="token operator">+</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"】"</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>parter <span class="token operator">+</span> <span class="token string">"开始执行……"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"发令开始....."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;运行结果：</p><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">发令开始.....【Thread-0，时间：1623897582895】开始执行……【Thread-4，时间：1623897582895】开始执行……【Thread-3，时间：1623897582895】开始执行……【Thread-2，时间：1623897582895】开始执行……【Thread-1，时间：1623897582895】开始执行……<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="作为结束信号，让一个线程等待"><a href="#作为结束信号，让一个线程等待" class="headerlink" title="作为结束信号，让一个线程等待"></a>作为结束信号，让一个线程等待</h2><p>&emsp;&emsp;某个线程在开始运行前等待n个线程执行完毕。例如，启动一个服务时，主线程需要等待多个组件加载完毕，之后继续执行。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testtwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> index <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">+</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"finish，"</span> <span class="token operator">+</span> index <span class="token operator">+</span> <span class="token string">"，"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 主线程在阻塞，当计数器==0，就唤醒主线程往下执行</span>    countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"主线程:在所有任务运行完成后，进行结果汇总"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;运行结果：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">finish，4，Thread-4finish，2，Thread-2finish，3，Thread-3finish，0，Thread-0finish，1，Thread-1主线程:在所有任务运行完成后，进行结果汇总<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="官方demo，可以参考"><a href="#官方demo，可以参考" class="headerlink" title="官方demo，可以参考"></a>官方demo，可以参考</h2><p>&emsp;&emsp;demo1，这是一个将启动信号和结束信号结合起来。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Driver</span> <span class="token punctuation">&#123;</span> <span class="token comment">// ...</span>    <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CountDownLatch</span> startSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">CountDownLatch</span> doneSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment">// create and start threads</span>            <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Worker</span><span class="token punctuation">(</span>startSignal<span class="token punctuation">,</span> doneSignal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// don't let run yet</span>        startSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// let all threads proceed</span>        <span class="token function">doSomethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        doneSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// wait for all to finish</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Worker</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> startSignal<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> doneSignal<span class="token punctuation">;</span>    <span class="token class-name">Worker</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> startSignal<span class="token punctuation">,</span> <span class="token class-name">CountDownLatch</span> doneSignal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>startSignal <span class="token operator">=</span> startSignal<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>doneSignal <span class="token operator">=</span> doneSignal<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            startSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            doneSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// return;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;典型的主线程等待子线程完成的例子。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Driver2</span> <span class="token punctuation">&#123;</span> <span class="token comment">// ...</span>    <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">CountDownLatch</span> doneSignal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token class-name">N</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Executor</span> e <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token comment">// create and start threads</span>            e<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">WorkerRunnable</span><span class="token punctuation">(</span>doneSignal<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        doneSignal<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// wait for all to finish</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">WorkerRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">CountDownLatch</span> doneSignal<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token class-name">WorkerRunnable</span><span class="token punctuation">(</span><span class="token class-name">CountDownLatch</span> doneSignal<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>doneSignal <span class="token operator">=</span> doneSignal<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>i <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token function">doWork</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            doneSignal<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// return;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">void</span> <span class="token function">doWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>&emsp;&emsp;简单来说，是通过一个计数器来实现的，计数器的初始值为线程的数量或者指定的值，调用<code>await()</code>方法的线程会被阻塞，直到计数器减到0时才能继续往下执行。<br>&emsp;&emsp;CountDownLatch底层基于AQS实现，构造函数中指定的count直接赋阻值给AQS的state，每次countDown都是release(1)减一，最后减到0时unpark阻塞线程。而调用await()方法时，当前线程就会判断state属性是否为0，如果为0，则继续往下执行，如果不为0，则使当前线程进入等待状态，直到某个线程将state属性置为0，其就会唤醒在await()方法中等待的线程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Sync</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractQueuedSynchronizer</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">4982264981922014374L</span><span class="token punctuation">;</span>    <span class="token class-name">Sync</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">setState</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Decrement count; signal when transition to zero</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 这里表示如果资源已经释放，就不能在释放一次</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token comment">// 本次计数剩余量</span>            <span class="token keyword">int</span> nextc <span class="token operator">=</span> c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token comment">// 设置剩余量</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment">// 等于0表示，本次计数完成后，释放资源了，await方法就不再阻塞</span>                <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"count &lt; 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sync <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sync</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    sync<span class="token punctuation">.</span><span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span>        <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里调用tryAcquireShared方法尝试获取资源，返回负数表示失败，返回整数则表示成功，失败了就加入同步队列。<br>&emsp;&emsp;tryAcquireShared方法中则根据计数来判断是否成功，如果计数为0，则计数完毕，返回成功。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    sync<span class="token punctuation">.</span><span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// AQS</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 如果资源释放了，唤醒同步队列中的线程</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// unpark</span>        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&emsp;&emsp;这里面会尝试进行资源释放，如果资源释放了就唤醒同步队列中的线程。</p><h2 id="大概流程"><a href="#大概流程" class="headerlink" title="大概流程"></a>大概流程</h2><ol><li>创建一个CountDownLatch，并赋予一个数值，这个值表示需要计数的次数，每次countdown算一次。</li><li>在主线程调用await方法，表示计数器完成前都不能动，await方法的内部实现依赖于内部的AQS，调用await方法的时候会尝试去获取资源，成功条件是state=0，也就是说除非countdown了count次之后，才能成功，失败的话当前线程进行休眠。</li><li>在子线程调用countDown方法，每次调用都会使内部的state-1，state为0时资源释放，await方法不在阻塞。</li></ol><hr><h1 id="参考资料-amp-鸣谢"><a href="#参考资料-amp-鸣谢" class="headerlink" title="参考资料 &amp; 鸣谢"></a>参考资料 &amp; 鸣谢</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/148231820">CountDownLatch的两种常用场景</a></li><li><a href="https://www.cnblogs.com/Lee_xy_z/p/10470181.html">CountDownLatch的理解和使用</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;根据文档：&lt;strong&gt;允许一个或多个线程等待直到在其他线程中执行的一组操作完成的同步辅助。&lt;/strong&gt;&lt;br&gt;&amp;emsp;&amp;emsp;一般被称为计数器，可以用做流程控制之类的作用。通常用来让一个线程等待其他的完成过后再继续执行。&lt;br&gt;&amp;emsp;&amp;emsp;通过一个计数器实现，计数器的初始值可以是线程的数量，每当一个线程执行完，计数器的值减一，当计数器的值为0时，表示所有线程都执行完毕，等待的线程就可以继续执行了。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/categories/java/"/>
    
    <category term="juc" scheme="https://linqiankun.github.io/hexoblog/categories/java/juc/"/>
    
    <category term="Java" scheme="https://linqiankun.github.io/hexoblog/categories/Java/"/>
    
    <category term="多线程" scheme="https://linqiankun.github.io/hexoblog/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/tags/java/"/>
    
    <category term="juc" scheme="https://linqiankun.github.io/hexoblog/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用</title>
    <link href="https://linqiankun.github.io/hexoblog/md/java/IO/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>https://linqiankun.github.io/hexoblog/md/java/IO/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2021-06-08T09:55:46.000Z</published>
    <updated>2021-06-09T06:13:38.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;IO多路复用是一个IO模型，指的是复用同一个线程监控多路网络连接。<br>&emsp;&emsp;现在大多的IO多路复用都是同步模型，Reactor模式。  </p><span id="more"></span><h2 id="Reactor和Proactor"><a href="#Reactor和Proactor" class="headerlink" title="Reactor和Proactor"></a>Reactor和Proactor</h2><p>&emsp;&emsp;两种多路复用IO方案。<br>&emsp;&emsp;在进行IO编程中，通常用到两种模式：Reactor和Proactor。<br>&emsp;&emsp;Reactor模式是基于同步IO的，而Proactor模式是和异步IO相关的。<br>&emsp;&emsp;Java的NIO就是Reactor，当有事件触发时，服务器端得到通知，进行相应的处理。AIO引入的是Proactor模式。  </p><hr><h1 id="多路复用解决的问题"><a href="#多路复用解决的问题" class="headerlink" title="多路复用解决的问题"></a>多路复用解决的问题</h1><p>&emsp;&emsp;IO实现主要有BIO和NIO两种机制，AIO用的比较少。<br>&emsp;&emsp;他们都会有多多少少的问题。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><ol><li>每个请求都需要创建独立的线程，与对应的客户端进行数据处理。</li><li>当并发数大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则当前线程会一直阻塞在 Read 操作上，造成线程资源浪费。</li></ol><hr><h1 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h1><p>&emsp;&emsp;IO多路复用在底层实现上主要有三种实现方式：select、poll、epoll。<br>&emsp;&emsp;这些方法是操作系统提供给应用的接口，毕竟所有的IO最终都是落实在操作系统的IO上。<br>&emsp;&emsp;一个个人理解，java中的NIO包，在使用Selector的情况下就是使用了IO多路复用，windows下底层用的是poll方法。</p><p><a href="https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA">一举拿下 I/O 多路复用！</a></p><p>&emsp;&emsp;在linux中一切皆是文件传输，网络的Socket通信也是，所以会为每一个Socket建立一个文件描述符，保存在操作系统内核空间中，select，poll，epoll采用不同的机构来存储这些文件描述符。<br>&emsp;&emsp;这里的文件描述符也可以认为就是Socket。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>&emsp;&emsp;select 实现多路复用的方式是，将已连接的Socket都放到一个文件描述符集合，然后调用select函数将文件描述符集合拷贝到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过遍历文件描述符集合的方式，当检查到有事件产生后，将此Socket标记为可读或可写， 接着再把整个文件描述符集合拷贝回用户态里，然后用户态还需要再通过遍历的方法找到可读或可写的Socket，然后再对其处理。这个过程中需要用户态到内核态，内核态到用户态两次拷贝。<br>&emsp;&emsp;select使用固定长度的BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在Linux系统中，由内核中的FD_SETSIZE限制， 默认最大值为1024，只能监听0~1023的文件描述符。<br>&emsp;&emsp;对于select这种方式，需要进行2次「遍历」文件描述符集合，一次是在内核态里，一个次是在用户态里 ，而且还会发生2次「拷贝」文件描述符集合，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>&emsp;&emsp;poll与select相比没有什么变化，相对于select，poll不在使用BitsMap存储所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了select的文件描述符个数限制，当然还会受到系统文件描述符限制。<br>&emsp;&emsp;都是使用「线性结构」存储进程关注的Socket集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>&emsp;&emsp;epoll在内核中采用红黑树存储所有的文件描述符，将需要监控的Socket通过epoll_ctl()函数加入内核的红黑树里，这样就不需要像select/poll每次操作时都传入整个socket集合，只需要传入一个待检测的socket，减少了内核和用户空间大量的数据拷贝和内存分配。<br>&emsp;&emsp;epoll采用事件驱动机制，内部维护了一个链表来记录就绪事件，当某个socket有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用epoll_wait()函数时，只会返回有事件发生的文件描述符的个数，不需要像select/poll那样轮询扫描整个socket集合，大大提高了检测的效率。</p><p><img src="https://gitee.com/linqiankun/picurl/raw/master/java/epoll%E5%8E%9F%E7%90%86.jpg" alt="epoll原理"></p><h3 id="事件触发模式"><a href="#事件触发模式" class="headerlink" title="事件触发模式"></a>事件触发模式</h3><p>&emsp;&emsp;epoll支持两种事件触发模式，分别是边缘触发（ET）和水平触发（LT）。epoll默认采用水平触发模式，select/poll只有水平触发模式。  </p><ul><li><strong>边缘触发：</strong> 使用边缘触发模式时，当被监控的Socket描述符上有可读事件发生时，服务器端只会从epoll_wait中苏醒一次，即使进程没有调用read函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完。<strong>边缘触发模式一般和非阻塞IO一起搭配使用</strong>，因为边缘模式下一般会循环的从文件描述符（Socket）读取数据，如果是阻塞的，阻塞IO就会阻塞，程序无法继续执行。</li><li><strong>水平触发：</strong> 使用水平触发模式时，当被监控的Socket上有可读事件发生时，服务器端不断地从epoll_wait中苏醒，直到内核缓冲区数据被read函数读完才结束，目的是告诉我们有数据需要读取。</li></ul><p>&emsp;&emsp;一般而言边缘触发的效率高于水平触发。<br>&emsp;&emsp;水平触发的意思是只要满足事件的条件，比如内核中有数据需要读，就一直不断地把这个事件传递给用户；而边缘触发的意思是只有第一次满足条件的时候才触发，之后就不会再传递同样的事件了。np</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>&emsp;&emsp;一切因文件描述符而起。</p><table><thead><tr><th>—</th><th>select</th><th>poll</th><th>epoll</th></tr></thead><tbody><tr><td>数据结构</td><td>bitmap</td><td>动态数组</td><td>红黑树</td></tr><tr><td>最大连接数</td><td>1024</td><td>无上线</td><td>无上限</td></tr><tr><td>fd拷贝</td><td>每次调用select拷贝</td><td>每次调用poll拷贝</td><td>fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝</td></tr><tr><td>工作效率</td><td>轮询：O(n)</td><td>轮询：O(n)</td><td>回调：O(1)</td></tr></tbody></table><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;网路通信中的IO模型，从最基础的阻塞IO模型，到多进程，多线程模型，在发展到多路复用IO模型。<br>&emsp;&emsp;传统的多线程、多进程模型，多个进程、线程的调度，和资源的消耗，上下文切换都会称为它们的瓶颈。<br>&emsp;&emsp;多路复用IO解决了上面的问题，linux下提供了三种API：select，poll，epoll。<br>&emsp;&emsp;select和poll 并没有本质区别，它们内部都是使用「线性结构」来存储进程关注的Socket集合。它们的缺陷在于，当客户端越多，Socket集合越大时，它的遍历和拷贝会带来很大的开销。</p><hr><h1 id="参考文献-amp-鸣谢"><a href="#参考文献-amp-鸣谢" class="headerlink" title="参考文献 &amp; 鸣谢"></a>参考文献 &amp; 鸣谢</h1><ul><li><a href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？</a></li><li><a href="https://segmentfault.com/a/1190000037714804">理解什么是BIO/AIO/NIO</a></li><li><a href="https://juejin.cn/post/6844904200141438984">彻底理解IO多路复用</a></li><li><a href="https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA">一举拿下 I/O 多路复用！</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;IO多路复用是一个IO模型，指的是复用同一个线程监控多路网络连接。&lt;br&gt;&amp;emsp;&amp;emsp;现在大多的IO多路复用都是同步模型，Reactor模式。  &lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/categories/java/"/>
    
    <category term="io" scheme="https://linqiankun.github.io/hexoblog/categories/java/io/"/>
    
    
    <category term="io" scheme="https://linqiankun.github.io/hexoblog/tags/io/"/>
    
    <category term="java" scheme="https://linqiankun.github.io/hexoblog/tags/java/"/>
    
    <category term="NIO" scheme="https://linqiankun.github.io/hexoblog/tags/NIO/"/>
    
  </entry>
  
</feed>
